<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>你走吧</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://nizouba.com/"/>
  <updated>2018-07-20T02:45:43.526Z</updated>
  <id>http://nizouba.com/</id>
  
  <author>
    <name>zwxbest</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>new test</title>
    <link href="http://nizouba.com/2018/07/20/new-test/"/>
    <id>http://nizouba.com/2018/07/20/new-test/</id>
    <published>2018-07-20T02:45:43.000Z</published>
    <updated>2018-07-20T02:45:43.526Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>《高性能MySQL》读书笔记</title>
    <link href="http://nizouba.com/2018/07/19/%E3%80%8A%E9%AB%98%E6%80%A7%E8%83%BDMySQL%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>http://nizouba.com/2018/07/19/《高性能MySQL》读书笔记/</id>
    <published>2018-07-19T04:42:29.000Z</published>
    <updated>2018-07-19T04:42:29.824Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>《MySQL技术内幕：InnoDB存储引擎》读书笔记</title>
    <link href="http://nizouba.com/2018/07/19/%E3%80%8AMySQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95%EF%BC%9AInnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>http://nizouba.com/2018/07/19/《MySQL技术内幕：InnoDB存储引擎》读书笔记/</id>
    <published>2018-07-19T04:34:53.000Z</published>
    <updated>2018-07-19T04:34:53.759Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>test</title>
    <link href="http://nizouba.com/2018/07/18/test/"/>
    <id>http://nizouba.com/2018/07/18/test/</id>
    <published>2018-07-18T11:04:47.000Z</published>
    <updated>2018-07-18T11:04:47.842Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>锁优化</title>
    <link href="http://nizouba.com/2018/07/17/%E9%94%81%E4%BC%98%E5%8C%96/"/>
    <id>http://nizouba.com/2018/07/17/锁优化/</id>
    <published>2018-07-17T04:09:14.000Z</published>
    <updated>2018-07-17T04:19:30.000Z</updated>
    
    <content type="html"><![CDATA[<ol><li>减小锁持有时间</li><li>减小锁粒度</li><li>读写分离锁替换独占锁</li><li>锁分离，比如LinkedBlockingQueue,插入在队尾，取出在队头。</li><li>锁粗化。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;减小锁持有时间&lt;/li&gt;
&lt;li&gt;减小锁粒度&lt;/li&gt;
&lt;li&gt;读写分离锁替换独占锁&lt;/li&gt;
&lt;li&gt;锁分离，比如LinkedBlockingQueue,插入在队尾，取出在队头。&lt;/li&gt;
&lt;li&gt;锁粗化。&lt;/li&gt;
&lt;/ol&gt;

      
    
    </summary>
    
    
      <category term="并发" scheme="http://nizouba.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>JDK的并发容器</title>
    <link href="http://nizouba.com/2018/07/17/JDK%E7%9A%84%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/"/>
    <id>http://nizouba.com/2018/07/17/JDK的并发容器/</id>
    <published>2018-07-17T01:39:45.000Z</published>
    <updated>2018-07-17T04:07:36.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h1><h1 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h1><p>读取不需要加锁，写入也不会阻塞读取操作，写入和写入需要同步等待</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>在写入操作时，进行一次自我复制，并不修改原有的内容，写完之后，再将副本替换原来的数据。</p><h1 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h1><p>高效的读写队列，使用cas无锁</p><h1 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h1><p>数据共享通道</p><h1 id="ConcurrentSkipListMap"><a href="#ConcurrentSkipListMap" class="headerlink" title="ConcurrentSkipListMap"></a>ConcurrentSkipListMap</h1><p>跳表，用来快速查找的</p><h1 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h1><h1 id="Collections工具类包装线程安全"><a href="#Collections工具类包装线程安全" class="headerlink" title="Collections工具类包装线程安全"></a>Collections工具类包装线程安全</h1><p>使用synchronize锁保证线程安全</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ConcurrentHashMap&quot;&gt;&lt;a href=&quot;#ConcurrentHashMap&quot; class=&quot;headerlink&quot; title=&quot;ConcurrentHashMap&quot;&gt;&lt;/a&gt;ConcurrentHashMap&lt;/h1&gt;&lt;h1 id=&quot;CopyO
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java并发之volatile</title>
    <link href="http://nizouba.com/2018/07/17/Java%E5%B9%B6%E5%8F%91%E4%B9%8Bvolatile/"/>
    <id>http://nizouba.com/2018/07/17/Java并发之volatile/</id>
    <published>2018-07-17T01:34:51.000Z</published>
    <updated>2018-07-17T01:37:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>volatile能保证可见性和有序性</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;volatile能保证可见性和有序性&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>synchronized与线程安全</title>
    <link href="http://nizouba.com/2018/07/17/synchronized%E4%B8%8E%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/"/>
    <id>http://nizouba.com/2018/07/17/synchronized与线程安全/</id>
    <published>2018-07-17T01:23:04.000Z</published>
    <updated>2018-07-17T01:30:54.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线程的3个特性"><a href="#线程的3个特性" class="headerlink" title="线程的3个特性"></a>线程的3个特性</h1><p>VOA</p><ol><li>原子性 atom，指一个操作是不可中断的 </li><li>可见性 当一个变量修改了某一个共享变量的值，其他线程是否能够立即得知这个修改。</li><li><p>有序性 程序在执行时，可能会进行指令重排。</p><h1 id="synchronized的3种用法"><a href="#synchronized的3种用法" class="headerlink" title="synchronized的3种用法"></a>synchronized的3种用法</h1></li><li><p>指定加锁对象</p></li><li>直接作用于实例方法</li><li>直接作用于静态方法</li></ol><h1 id="能保证的地方"><a href="#能保证的地方" class="headerlink" title="能保证的地方"></a>能保证的地方</h1><ol><li>可见性</li><li></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;线程的3个特性&quot;&gt;&lt;a href=&quot;#线程的3个特性&quot; class=&quot;headerlink&quot; title=&quot;线程的3个特性&quot;&gt;&lt;/a&gt;线程的3个特性&lt;/h1&gt;&lt;p&gt;VOA&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;原子性 atom，指一个操作是不可中断的 &lt;/li&gt;
&lt;li&gt;可见
      
    
    </summary>
    
    
      <category term="并发" scheme="http://nizouba.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Elasticsearch索引的创建、数据的增删该查操作</title>
    <link href="http://nizouba.com/2018/07/16/Elasticsearch%E7%B4%A2%E5%BC%95%E7%9A%84%E5%88%9B%E5%BB%BA%E3%80%81%E6%95%B0%E6%8D%AE%E7%9A%84%E5%A2%9E%E5%88%A0%E8%AF%A5%E6%9F%A5%E6%93%8D%E4%BD%9C/"/>
    <id>http://nizouba.com/2018/07/16/Elasticsearch索引的创建、数据的增删该查操作/</id>
    <published>2018-07-16T13:23:03.000Z</published>
    <updated>2018-07-17T00:59:28.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1、创建Maven工程"><a href="#1、创建Maven工程" class="headerlink" title="1、创建Maven工程"></a>1、创建Maven工程</h1><pre><code>&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;groupId&gt;com.sun.elasticsearch&lt;/groupId&gt;    &lt;artifactId&gt;Elasticsearch01&lt;/artifactId&gt;    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;    &lt;dependencies&gt;        &lt;!-- Elasticsearch核心依赖包 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.elasticsearch.client&lt;/groupId&gt;            &lt;artifactId&gt;transport&lt;/artifactId&gt;            &lt;version&gt;5.5.2&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;junit&lt;/groupId&gt;            &lt;artifactId&gt;junit&lt;/artifactId&gt;            &lt;version&gt;4.12&lt;/version&gt;            &lt;scope&gt;test&lt;/scope&gt;        &lt;/dependency&gt;        &lt;!-- 日志依赖 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;            &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;            &lt;version&gt;1.7.21&lt;/version&gt;            &lt;scope&gt;test&lt;/scope&gt;        &lt;/dependency&gt;        &lt;!-- https://mvnrepository.com/artifact/org.apache.logging.log4j/log4j-core --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;            &lt;artifactId&gt;log4j-core&lt;/artifactId&gt;            &lt;version&gt;2.8.2&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- https://mvnrepository.com/artifact/com.google.code.gson/gson --&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.google.code.gson&lt;/groupId&gt;            &lt;artifactId&gt;gson&lt;/artifactId&gt;            &lt;version&gt;2.8.0&lt;/version&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;&lt;/project&gt;</code></pre><h1 id="2、通过Java程序连接Elasticsearch"><a href="#2、通过Java程序连接Elasticsearch" class="headerlink" title="2、通过Java程序连接Elasticsearch"></a>2、通过Java程序连接Elasticsearch</h1><pre><code>package com.sun.elasticsearch;import java.net.InetAddress;import java.net.UnknownHostException;import org.elasticsearch.client.transport.TransportClient;import org.elasticsearch.common.settings.Settings;import org.elasticsearch.common.transport.InetSocketTransportAddress;import org.elasticsearch.transport.client.PreBuiltTransportClient;import org.junit.Test;import org.slf4j.Logger;import org.slf4j.LoggerFactory;/*** Elasticsearch的基本测试* @ClassName: ElasticsearchTest1  * @author sunt  * @date 2017年11月22日 * @version V1.0*/public class ElasticsearchTest1 {    private Logger logger = LoggerFactory.getLogger(ElasticsearchTest1.class);    public final static String HOST = &quot;192.168.1.140&quot;;    public final static int PORT = 9300;//http请求的端口是9200，客户端是9300    /**    * 测试Elasticsearch客户端连接    * @Title: test1     * @author sunt      * @date 2017年11月22日    * @return void    * @throws UnknownHostException     */    @SuppressWarnings(&quot;resource&quot;)    @Test    public void test1() throws UnknownHostException {        //创建客户端        TransportClient client = new PreBuiltTransportClient(Settings.EMPTY).addTransportAddresses(                                new InetSocketTransportAddress(InetAddress.getByName(HOST),PORT));        logger.debug(&quot;Elasticsearch connect info:&quot; + client.toString());        //关闭客户端        client.close();    }}</code></pre><h1 id="3、Elasticsearch索引库的创建"><a href="#3、Elasticsearch索引库的创建" class="headerlink" title="3、Elasticsearch索引库的创建"></a>3、Elasticsearch索引库的创建</h1><pre><code>private Logger logger = LoggerFactory.getLogger(ElasticsearchTest2.class);public final static String HOST = &quot;192.168.1.140&quot;;public final static int PORT = 9300; //http请求的端口是9200，客户端是9300private TransportClient client = null;/** * 获取客户端连接信息 * @Title: getConnect  * @author sunt   * @date 2017年11月23日 * @return void * @throws UnknownHostException  */@SuppressWarnings({ &quot;resource&quot;, &quot;unchecked&quot; })@Beforepublic void getConnect() throws UnknownHostException {    client = new PreBuiltTransportClient(Settings.EMPTY).addTransportAddresses(             new InetSocketTransportAddress(InetAddress.getByName(HOST),PORT));    logger.info(&quot;连接信息:&quot; + client.toString());}/** * 关闭连接 * @Title: closeConnect  * @author sunt   * @date 2017年11月23日 * @return void */@After</code></pre><p>4、向索引库中添加json字符串<br>    public void closeConnect() {<br>        if(null != client) {<br>            logger.info(“执行关闭连接操作…”);<br>            client.close();<br>        }<br>    }</p><pre><code>/** * 创建索引库 * @Title: addIndex1 * @author sunt   * @date 2017年11月23日 * @return void * 需求:创建一个索引库为：msg消息队列,类型为：tweet,id为1 * 索引库的名称必须为小写 * @throws IOException  */@Testpublic void addIndex1() throws IOException {    IndexResponse response = client.prepareIndex(&quot;msg&quot;, &quot;tweet&quot;, &quot;1&quot;).setSource(XContentFactory.jsonBuilder()            .startObject().field(&quot;userName&quot;, &quot;张三&quot;)            .field(&quot;sendDate&quot;, new Date())            .field(&quot;msg&quot;, &quot;你好李四&quot;)            .endObject()).get();    logger.info(&quot;索引名称:&quot; + response.getIndex() + &quot;\n类型:&quot; + response.getType()                + &quot;\n文档ID:&quot; + response.getId() + &quot;\n当前实例状态:&quot; + response.status());}PS: 索引库名称必须为小写，如果为大写会包如下错误信息</code></pre><h1 id="4、向索引库中添加json字符串"><a href="#4、向索引库中添加json字符串" class="headerlink" title="4、向索引库中添加json字符串"></a>4、向索引库中添加json字符串</h1><pre><code>/**    * 添加索引:传入json字符串    * @Title: addIndex2     * @author sunt      * @date 2017年11月23日    * @return void    */    @Test    public void addIndex2() {        String jsonStr = &quot;{&quot; +                &quot;\&quot;userName\&quot;:\&quot;张三\&quot;,&quot; +                &quot;\&quot;sendDate\&quot;:\&quot;2017-11-30\&quot;,&quot; +                &quot;\&quot;msg\&quot;:\&quot;你好李四\&quot;&quot; +            &quot;}&quot;;        IndexResponse response = client.prepareIndex(&quot;weixin&quot;, &quot;tweet&quot;).setSource(jsonStr,XContentType.JSON).get();        logger.info(&quot;json索引名称:&quot; + response.getIndex() + &quot;\njson类型:&quot; + response.getType()        + &quot;\njson文档ID:&quot; + response.getId() + &quot;\n当前实例json状态:&quot; + response.status());    }</code></pre><h1 id="5、向索引库添加一个Map集合"><a href="#5、向索引库添加一个Map集合" class="headerlink" title="5、向索引库添加一个Map集合"></a>5、向索引库添加一个Map集合</h1><p>/**</p><pre><code> * 创建索引-传入Map对象 * @Title: addIndex3  * @author sunt   * @date 2017年11月23日 * @return void */@Testpublic void addIndex3() {    Map&lt;String, Object&gt; map = new HashMap&lt;String,Object&gt;();    map.put(&quot;userName&quot;, &quot;张三&quot;);    map.put(&quot;sendDate&quot;, new Date());    map.put(&quot;msg&quot;, &quot;你好李四&quot;);    IndexResponse response = client.prepareIndex(&quot;momo&quot;, &quot;tweet&quot;).setSource(map).get();    logger.info(&quot;map索引名称:&quot; + response.getIndex() + &quot;\n map类型:&quot; + response.getType()    + &quot;\n map文档ID:&quot; + response.getId() + &quot;\n当前实例map状态:&quot; + response.status());}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1、创建Maven工程&quot;&gt;&lt;a href=&quot;#1、创建Maven工程&quot; class=&quot;headerlink&quot; title=&quot;1、创建Maven工程&quot;&gt;&lt;/a&gt;1、创建Maven工程&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;&amp;lt;project xmlns=&amp;quot;ht
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>HashSet、TreeSet和LinkedHashSet的区别</title>
    <link href="http://nizouba.com/2018/07/16/HashSet%E3%80%81TreeSet%E5%92%8CLinkedHashSet%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://nizouba.com/2018/07/16/HashSet、TreeSet和LinkedHashSet的区别/</id>
    <published>2018-07-16T11:24:04.000Z</published>
    <updated>2018-07-16T11:48:28.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Set接口"><a href="#Set接口" class="headerlink" title="Set接口"></a>Set接口</h1><p>Set不允许包含相同的元素，如果试图把两个相同元素加入同一个集合中，add方法返回false。</p><h2 id="HashSet类"><a href="#HashSet类" class="headerlink" title="HashSet类"></a>HashSet类</h2><p>HashSet有以下特点</p><ol><li>不能保证元素的排列顺序，顺序有可能发生变化</li><li>不是同步的</li><li>集合元素可以是null,但只能放入一个null<br>当向HashSet结合中存入一个元素时，HashSet会调用该对象的hashCode()方法来得到该对象的hashCode值，然后根据 hashCode值来决定该对象在HashSet中存储位置。<br>简单的说，HashSet集合判断两个元素相等的标准是两个对象通过equals方法比较相等，并且两个对象的hashCode()方法返回值相 等<br>注意，如果要把一个对象放入HashSet中，重写该对象对应类的equals方法，也应该重写其hashCode()方法。其规则是如果两个对 象通过equals方法比较返回true时，其hashCode也应该相同。另外，对象中用作equals比较标准的属性，都应该用来计算 hashCode的值。</li></ol><h2 id="LinkedHashSet类"><a href="#LinkedHashSet类" class="headerlink" title="LinkedHashSet类"></a>LinkedHashSet类</h2><p>LinkedHashSet集合同样是根据元素的hashCode值来决定元素的存储位置，但是它同时使用链表维护元素的次序。这样使得元素看起 来像是以插入顺序保存的，也就是说，当遍历该集合时候，LinkedHashSet将会以元素的添加顺序访问集合的元素。<br>LinkedHashSet在迭代访问Set中的全部元素时，性能比HashSet好，但是插入时性能稍微逊色于HashSet。</p><h2 id="TreeSet类"><a href="#TreeSet类" class="headerlink" title="TreeSet类"></a>TreeSet类</h2><p>TreeSet是SortedSet接口的唯一实现类，TreeSet可以确保集合元素处于排序状态。TreeSet支持两种排序方式，自然排序 和定制排序，其中自然排序为认的排序方式。向TreeSet中加入的应该是同一个类的对象。默<br>TreeSet判断两个对象不相等的方式是两个对象通过equals方法返回false，或者通过CompareTo方法比较没有返回0<br>自然排序<br>自然排序使用要排序元素的CompareTo（Object obj）方法来比较元素之间大小关系，然后将元素按照升序排列。<br>Java提供了一个Comparable接口，该接口里定义了一个compareTo(Object obj)方法，该方法返回一个整数值，实现了该接口的对象就可以比较大小。<br>obj1.compareTo(obj2)方法如果返回0，则说明被比较的两个对象相等，如果返回一个正数，则表明obj1大于obj2，如果是 负数，则表明obj1小于obj2。<br>如果我们将两个对象的equals方法总是返回true，则这两个对象的compareTo方法返回应该返回0<br>定制排序<br>自然排序是根据集合元素的大小，以升序排列，如果要定制排序，应该使用Comparator接口，实现 int compare(T o1,T o2)方法</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Set接口&quot;&gt;&lt;a href=&quot;#Set接口&quot; class=&quot;headerlink&quot; title=&quot;Set接口&quot;&gt;&lt;/a&gt;Set接口&lt;/h1&gt;&lt;p&gt;Set不允许包含相同的元素，如果试图把两个相同元素加入同一个集合中，add方法返回false。&lt;/p&gt;
&lt;h2 id
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java GC工作原理以及Minor GC、Major GC、Full GC简单总结</title>
    <link href="http://nizouba.com/2018/07/16/Java-GC%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8AMinor-GC%E3%80%81Major-GC%E3%80%81Full-GC%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93/"/>
    <id>http://nizouba.com/2018/07/16/Java-GC工作原理以及Minor-GC、Major-GC、Full-GC简单总结/</id>
    <published>2018-07-16T04:01:50.000Z</published>
    <updated>2018-07-16T04:08:52.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h1><p>GC：垃圾收集器</p><p>Minor GC：新生代GC，指发生在新生代的垃圾收集动作，所有的Minor GC都会触发全世界的暂停（stop-the-world），停止应用程序的线程，不过这个过程非常短暂。</p><p>Major GC/Full GC：老年代GC，指发生在老年代的GC。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>众所周知，所有通过new创建的对象的内存都在堆中分配，堆被划分为新生代和老年代，新生代又被进一步划分为Eden和Survivor区，而Survivor由FromSpace和ToSpace组成。</p><h3 id="新生代"><a href="#新生代" class="headerlink" title="新生代"></a>新生代</h3><p>新创建的对象都是用新生代分配内存，Eden空间不足时，触发Minor GC，这时会把存活的对象转移进Survivor区。</p><h3 id="老年代"><a href="#老年代" class="headerlink" title="老年代"></a>老年代</h3><p>老年代用于存放经过多次Minor GC之后依然存活的对象。</p><h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><p>每个线程执行每个方法的时候都会在栈中申请一个栈帧，每个栈帧包括局部变量区和操作数栈，用于存放此次方法调用过程中的临时变量、参数和中间结果。</p><p>#本地方法栈</p><p>用于支持native方法的执行，存储了每个native方法调用的状态。</p><h1 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h1><p>存放了要加载的类信息、静态变量、final类型的常量、属性和方法信息。JVM用持久代(PermanetGeneration)来存放方法区。</p><h1 id="JVM垃圾回收机制"><a href="#JVM垃圾回收机制" class="headerlink" title="JVM垃圾回收机制"></a>JVM垃圾回收机制</h1><p>JVM分别对新生代和老年代采用不同的垃圾回收机制。</p><p>GC触发条件：Eden区满了触发Minor GC，这时会把Eden区存活的对象复制到Survivor区，当对象在Survivor区熬过一定次数的Minor GC之后，就会晋升到老年代（当然并不是所有的对象都是这样晋升的到老年代的），当老年代满了，就会报OutofMemory异常。</p><h2 id="新生代的GC（Minor-GC）："><a href="#新生代的GC（Minor-GC）：" class="headerlink" title="新生代的GC（Minor GC）："></a>新生代的GC（Minor GC）：</h2><p>新生代通常存活时间较短基于Copying算法进行回收，所谓Copying算法就是扫描出存活的对象，并复制到一块新的完全未使用的空间中，对应于新生代，就是在Eden和FromSpace或ToSpace之间copy。新生代采用空闲指针的方式来控制GC触发，指针保持最后一个分配的对象在新生代区间的位置，当有新的对象要分配内存时，用于检查空间是否足够，不够就触发GC。当连续分配对象时，对象会逐渐从Eden到Survivor，最后到老年代。</p><p>在执行机制上JVM提供了串行GC(SerialGC)、并行回收GC(ParallelScavenge)和并行GC(ParNew)：</p><p>串行GC</p><p>在整个扫描和复制过程采用单线程的方式来进行，适用于单CPU、新生代空间较小及对暂停时间要求不是非常高的应用上，是client级别默认的GC方式，可以通过-XX:+UseSerialGC来强制指定。</p><p>并行回收GC</p><p>在整个扫描和复制过程采用多线程的方式来进行，适用于多CPU、对暂停时间要求较短的应用上，是server级别默认采用的GC方式，可用-XX:+UseParallelGC来强制指定，用-XX:ParallelGCThreads=4来指定线程数。</p><p>并行GC</p><p>与老年代的并发GC配合使用。</p><h2 id="老年代的GC（Major-GC-Full-GC）："><a href="#老年代的GC（Major-GC-Full-GC）：" class="headerlink" title="老年代的GC（Major GC/Full GC）："></a>老年代的GC（Major GC/Full GC）：</h2><p>老年代与新生代不同，老年代对象存活的时间比较长、比较稳定，因此采用标记(Mark)算法来进行回收，所谓标记就是扫描出存活的对象，然后再进行回收未被标记的对象，回收后对用空出的空间要么进行合并、要么标记出来便于下次进行分配，总之目的就是要减少内存碎片带来的效率损耗。</p><p>在执行机制上JVM提供了串行GC(Serial MSC)、并行GC(Parallel MSC)和并发GC(CMS)。</p><p>串行GC（Serial MSC）</p><p>client模式下的默认GC方式，可通过-XX:+UseSerialGC强制指定。每次进行全部回收，进行Compact，非常耗费时间。</p><p>并行GC（Parallel MSC）(吞吐量大，但是GC的时候响应很慢)</p><p>server模式下的默认GC方式，也可用-XX:+UseParallelGC=强制指定。可以在选项后加等号来制定并行的线程数。</p><p>并发GC（CMS）(响应比并行gc快很多，但是牺牲了一定的吞吐量)</p><p>使用CMS是为了减少GC执行时的停顿时间，垃圾回收线程和应用线程同时执行，可以使用-XX:+UseConcMarkSweepGC=指定使用，后边接等号指定并发线程数。CMS每次回收只停顿很短的时间，分别在开始的时候（Initial Marking），和中间（Final Marking）的时候，第二次时间略长。CMS一个比较大的问题是碎片和浮动垃圾问题（Floating Gabage）。碎片是由于CMS默认不对内存进行Compact所致，可以通过-XX:+UseCMSCompactAtFullCollection。</p><p>虚拟机给每个对象定义了一个对象年龄（Age）计数器。如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor区，并将对象年龄设为 1。对象在Survivor区中每熬过一次Minor GC，年龄就增加1，当它的年龄增加到一定程度（默认为15）时，就会被晋升到老年代中。对象晋升老年代的年龄阈值，可以通过参数 -XX:MaxTenuringThreshold 来设置。</p><p>GC判断对象是否”存活”或”死去”（GC回收的对象）：</p><p>1.引用计数器算法</p><p>给对象中添加一个引用计数器，每当有一个地方引用它时，计数器的值加1；当引用失效时，计数器的值减；当该对象的计数器的值为0时，标志该对象失效。</p><p>2.跟搜索算法</p><p>基本思路：通过一系列的名为“GCRoots”的对象作为起始点，从这些节点开始向下搜索，搜索过的路径称为引用链，当一个对象到GCRoots没有任何引用链相连（用图论的话来说就是从GC Roots到这个对象不可达）时，则证明对象是不可用的。</p><p>附JVM GC组合方式：</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;术语&quot;&gt;&lt;a href=&quot;#术语&quot; class=&quot;headerlink&quot; title=&quot;术语&quot;&gt;&lt;/a&gt;术语&lt;/h1&gt;&lt;p&gt;GC：垃圾收集器&lt;/p&gt;
&lt;p&gt;Minor GC：新生代GC，指发生在新生代的垃圾收集动作，所有的Minor GC都会触发全世界的暂停（st
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>MySQL的热备份和冷备份</title>
    <link href="http://nizouba.com/2018/07/16/MySQL%E7%9A%84%E7%83%AD%E5%A4%87%E4%BB%BD%E5%92%8C%E5%86%B7%E5%A4%87%E4%BB%BD/"/>
    <id>http://nizouba.com/2018/07/16/MySQL的热备份和冷备份/</id>
    <published>2018-07-16T03:48:25.000Z</published>
    <updated>2018-07-16T03:51:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="冷备份"><a href="#冷备份" class="headerlink" title="冷备份"></a>冷备份</h1><p>冷备份（OFF， 慢， 时间点上恢复）<br>冷备份发生在数据库已经正常关闭的情况下，当正常关闭时会提供给我们一个完整的数据库。冷备份是将关键性文件拷贝到另外位置的一种说法。对于备份数据库信息而言，冷备份是最快和最安全的方法。</p><p>冷备份的优点：<br>1．是非常快速的备份方法（只需拷贝文件）<br>2．容易归档（简单拷贝即可）<br>3．容易恢复到某个时间点上（只需将文件再拷贝回去）<br>4．能与归档方法相结合，作数据库“最新状态”的恢复。<br>5．低度维护，高度安全。</p><p>冷备份的缺点：<br>1．单独使用时，只能提供到“某一时间点上”的恢复。<br>2．在实施备份的全过程中，数据库必须要作备份而不能作其它工作。也就是说，在冷备份过程中，数据库必须是关闭状态。<br>3．若磁盘空间有限，只能拷贝到磁带等其它外部存储设备上，速度会很慢。<br>4．不能按表或按用户恢复。<br>值得注意的是冷备份必须在数据库关闭的情况下进行，当数据库处于打开状态时，执行数据库文件系统备份是无效的 。而且在恢复后一定要把数据库文件的属组和属主改为mysql。</p><h1 id="热备份"><a href="#热备份" class="headerlink" title="热备份"></a>热备份</h1><p>热备份 （ON，快）<br>热备份是在数据库运行的情况下，备份数据库操作的sql语句，当数据库发生问题时，可以重新执行一遍备份的sql语句。</p><p>热备份的优点：<br>1．可在表空间或数据文件级备份，备份时间短。<br>2．备份时数据库仍可使用。<br>3．可达到秒级恢复（恢复到某一时间点上）。<br>4．可对几乎所有数据库实体作恢复。<br>5．恢复是快速的，在大多数情况下在数据库仍工作时恢复。</p><p>热备份的缺点：<br>1．不能出错，否则后果严重。<br>2．若热备份不成功，所得结果不可用于时间点的恢复。<br>3．因难于维护，所以要特别仔细小心，不允许“以失败而告终”。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;冷备份&quot;&gt;&lt;a href=&quot;#冷备份&quot; class=&quot;headerlink&quot; title=&quot;冷备份&quot;&gt;&lt;/a&gt;冷备份&lt;/h1&gt;&lt;p&gt;冷备份（OFF， 慢， 时间点上恢复）&lt;br&gt;冷备份发生在数据库已经正常关闭的情况下，当正常关闭时会提供给我们一个完整的数据库。冷备
      
    
    </summary>
    
      <category term="MySQL" scheme="http://nizouba.com/categories/MySQL/"/>
    
    
  </entry>
  
  <entry>
    <title>支付宝——开放平台第三方应用安全开发指南</title>
    <link href="http://nizouba.com/2018/07/16/%E6%94%AF%E4%BB%98%E5%AE%9D%E2%80%94%E2%80%94%E5%BC%80%E6%94%BE%E5%B9%B3%E5%8F%B0%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/"/>
    <id>http://nizouba.com/2018/07/16/支付宝——开放平台第三方应用安全开发指南/</id>
    <published>2018-07-16T02:59:28.000Z</published>
    <updated>2018-07-16T03:05:03.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="常见开发场景安全开发指南"><a href="#常见开发场景安全开发指南" class="headerlink" title="常见开发场景安全开发指南"></a>常见开发场景安全开发指南</h1><h2 id="敏感信息使用场景"><a href="#敏感信息使用场景" class="headerlink" title="敏感信息使用场景"></a>敏感信息使用场景</h2><p>敏感信息指用户的 身份证号、银行卡号、手机号 等身份信息。重要敏感信息的脱敏规范如下。</p><p>敏感信息类型    展示规范<br>身份证    显示前 1 位 + <em>(实际位数) + 后 1 位，如： 3<strong><strong><strong><em>**</em></strong></strong></strong>3<br>银行卡    显示前 6 位 + </em>(实际位数) + 后 4 位，如：622575<strong>**</strong>1496<br>手机号    显示前 3 位 + <strong><strong> + 后 2 位，如：137**</strong></strong>50</p><h2 id="敏感信息用于展示的场景"><a href="#敏感信息用于展示的场景" class="headerlink" title="敏感信息用于展示的场景"></a>敏感信息用于展示的场景</h2><p>原则：敏感信息的展示请严格按照脱敏规范进行脱敏</p><ul><li>说明：脱敏的逻辑必须在服务端完成，不能使用 Javascript 在客户端进行脱敏，包括代码注释、隐藏域、url 参数、cookies 等处的数据也必须脱敏。</li><li>说明：不能使用可逆的编码/加密方式，如 base64 编码等代替脱敏规范。</li><li>说明：若敏感信息明文展示在应用中，没有按照脱敏规范完成脱敏。支付宝开放平台将有权暂停敏感数据相关接口的开放。</li></ul><h2 id="敏感信息用于身份校验的场景"><a href="#敏感信息用于身份校验的场景" class="headerlink" title="敏感信息用于身份校验的场景"></a>敏感信息用于身份校验的场景</h2><p>原则：不要直接将敏感信息的明文信息在客户端与服务端之间传递</p><ul><li>说明：可以将敏感信息在服务端关联到用户标识 ID，在客户端保存用户标识 ID 并提交到服务端，服务端根据 ID 取出对应信息后进行校验。</li></ul><p><a href="https://blog.csdn.net/yangyang_01/article/details/79195191" target="_blank" rel="noopener">https://blog.csdn.net/yangyang_01/article/details/79195191</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;常见开发场景安全开发指南&quot;&gt;&lt;a href=&quot;#常见开发场景安全开发指南&quot; class=&quot;headerlink&quot; title=&quot;常见开发场景安全开发指南&quot;&gt;&lt;/a&gt;常见开发场景安全开发指南&lt;/h1&gt;&lt;h2 id=&quot;敏感信息使用场景&quot;&gt;&lt;a href=&quot;#敏感信息使
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>NIO之缓冲区Buffer</title>
    <link href="http://nizouba.com/2018/07/16/NIO%E4%B9%8B%E7%BC%93%E5%86%B2%E5%8C%BABuffer/"/>
    <id>http://nizouba.com/2018/07/16/NIO之缓冲区Buffer/</id>
    <published>2018-07-15T16:24:59.000Z</published>
    <updated>2018-07-15T16:36:22.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h1><h2 id="容量-Capacity"><a href="#容量-Capacity" class="headerlink" title="容量 Capacity"></a>容量 Capacity</h2><p>默认为分配大小 ，固定的</p><h2 id="上限-limit"><a href="#上限-limit" class="headerlink" title="上限 limit"></a>上限 limit</h2><p>默认为分配大小，可改变</p><h2 id="位置-Postion"><a href="#位置-Postion" class="headerlink" title="位置 Postion"></a>位置 Postion</h2><p>默认为0，可改变</p><h2 id="标记-Mark"><a href="#标记-Mark" class="headerlink" title="标记 Mark"></a>标记 Mark</h2><p>最初未定义</p><h2 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h2><p>0&lt;=mark&lt;=postion&lt;=limit&lt;=capacity</p><h1 id="API"><a href="#API" class="headerlink" title="API"></a>API</h1><h1 id="存取"><a href="#存取" class="headerlink" title="存取"></a>存取</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;属性&quot;&gt;&lt;a href=&quot;#属性&quot; class=&quot;headerlink&quot; title=&quot;属性&quot;&gt;&lt;/a&gt;属性&lt;/h1&gt;&lt;h2 id=&quot;容量-Capacity&quot;&gt;&lt;a href=&quot;#容量-Capacity&quot; class=&quot;headerlink&quot; title=&quot;容量 
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>java堆</title>
    <link href="http://nizouba.com/2018/07/15/jvm%E4%B9%8B%E8%80%81%E5%B9%B4%E4%BB%A3/"/>
    <id>http://nizouba.com/2018/07/15/jvm之老年代/</id>
    <published>2018-07-15T15:15:05.000Z</published>
    <updated>2018-07-15T15:44:18.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h1><h2 id="新生代"><a href="#新生代" class="headerlink" title="新生代"></a>新生代</h2><p>eden区，s0或者from区，s1或者to区，s0和s1是两块大小相等，可以互换的空间。</p><h2 id="老年代"><a href="#老年代" class="headerlink" title="老年代"></a>老年代</h2><p>tenured</p><h3 id="新生代到老年代"><a href="#新生代到老年代" class="headerlink" title="新生代到老年代"></a>新生代到老年代</h3><p>首先分配在eden区，一次新生代回收后，如果还存活，就会进入s0或者s1，每经过1次回收如果活着年龄加1，年龄达到一定条件之后进入老年代。</p><h3 id="何时要进入老年代"><a href="#何时要进入老年代" class="headerlink" title="何时要进入老年代"></a>何时要进入老年代</h3><p>参数MaxnuringThreshold，默认是15个，也就是回收15次进入老年代。</p><p>未达到年龄也有可能晋升老年代。</p><h3 id="大对象进入老年代"><a href="#大对象进入老年代" class="headerlink" title="大对象进入老年代"></a>大对象进入老年代</h3><p>体积过大也可能会晋升老年代，通过PretenureSizeThresold来设置晋升老年代的阈值。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;组成&quot;&gt;&lt;a href=&quot;#组成&quot; class=&quot;headerlink&quot; title=&quot;组成&quot;&gt;&lt;/a&gt;组成&lt;/h1&gt;&lt;h2 id=&quot;新生代&quot;&gt;&lt;a href=&quot;#新生代&quot; class=&quot;headerlink&quot; title=&quot;新生代&quot;&gt;&lt;/a&gt;新生代&lt;/h2&gt;&lt;p
      
    
    </summary>
    
    
      <category term="JVM" scheme="http://nizouba.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>排序算法</title>
    <link href="http://nizouba.com/2018/07/15/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>http://nizouba.com/2018/07/15/排序算法/</id>
    <published>2018-07-15T11:50:22.000Z</published>
    <updated>2018-07-16T12:49:03.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中，ri=rj，且ri在rj之前，而在排序后的序列中，ri仍在rj之前，则称这种排序算法是稳定的；否则称为不稳定的。</p><h2 id="冒泡"><a href="#冒泡" class="headerlink" title="冒泡"></a>冒泡</h2><h3 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h3><p>两两比较相邻记录的关键字，如果反序则交换，直到没有反序的记录为止。</p><h3 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h3><p>冒泡排序就是把小的元素往前调或者把大的元素往后调。比较是相邻的两个元素比较，交换也发生在这两个元素之间。所以，如果两个元素相等，我想你是不会再无 聊地把他们俩交换一下的；如果两个相等的元素没有相邻，那么即使通过前面的两两交换把两个相邻起来，这时候也不会交换，所以相同元素的前后顺序并没有改 变，所以冒泡排序是一种稳定排序算法。</p><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><h3 id="思想-1"><a href="#思想-1" class="headerlink" title="思想"></a>思想</h3><p>每一趟在n-i+1个记录中选区关键字最小的记录作为有序序列的第i个记录，</p><h3 id="稳定性-1"><a href="#稳定性-1" class="headerlink" title="稳定性"></a>稳定性</h3><p>选择排序是给每个位置选择当前元素最小的，比如给第一个位置选择最小的，在剩余元素里面给第二个元素选择第二小的，依次类推，直到第n-1个元素，第n个 元素不用选择了，因为只剩下它一个最大的元素了。那么，在一趟选择，如果当前元素比一个元素小，而该小的元素又出现在一个和当前元素相等的元素后面，那么 交换后稳定性就被破坏了。比较拗口，举个例子，序列5 8 5 2 9， 我们知道第一遍选择第1个元素5会和2交换，那么原序列中2个5的相对前后顺序就被破坏了，所以选择排序不是一个稳定的排序算法。</p><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><h3 id="思想-2"><a href="#思想-2" class="headerlink" title="思想"></a>思想</h3><p>将一个记录插入到已经排好序的有序表中，从而得到一个新的、记录数增1的有序表。</p><h3 id="稳定性-2"><a href="#稳定性-2" class="headerlink" title="稳定性"></a>稳定性</h3><p>插入排序是在一个已经有序的小序列的基础上，一次插入一个元素。当然，刚开始这个有序的小序列只有1个元素，就是第一个元素。比较是从有序序列的末尾开 始，也就是想要插入的元素和已经有序的最大者开始比起，如果比它大则直接插入在其后面，否则一直往前找直到找到它该插入的位置。如果碰见一个和插入元素相等的，那么插入元素把想插入的元素放在相等元素的后面。所以，相等元素的前后顺序没有改变，从原无序序列出去的顺序就是排好序后的顺序，所以插入排序是稳定的。</p><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>将待排序列划分为若干组，在每一组内进行插入排序，以使整个序列基本有序，然后再对整个序列进行插入排序。</p><h3 id="思想-3"><a href="#思想-3" class="headerlink" title="思想"></a>思想</h3><h3 id="稳定性-3"><a href="#稳定性-3" class="headerlink" title="稳定性"></a>稳定性</h3><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><h3 id="思想-4"><a href="#思想-4" class="headerlink" title="思想"></a>思想</h3><p>通过一趟排序将待排记录分割成独立的两部分，其中一部分记录的关键字比另一部分记录的关键字小，则可分别对这两部分记录进行排序，已达到整个序列有序的目的。</p><h3 id="稳定性-4"><a href="#稳定性-4" class="headerlink" title="稳定性"></a>稳定性</h3><p>快速排序有两个方向，左边的i下标一直往右走，当a[i] &lt;= a[center_index]，其中center_index是中枢元素的数组下标，一般取为数组第0个元素。而右边的j下标一直往左走，当a[j] &gt; a[center_index]。如果i和j都走不动了，i &lt;= j, 交换a[i]和a[j],重复上面的过程，直到i&gt;j。 交换a[j]和a[center_index]，完成一趟快速排序。在中枢元素和a[j]交换的时候，很有可能把前面的元素的稳定性打乱，比如序列为 5 3 3 4 3 8 9 10 11， 现在中枢元素5和3(第5个元素，下标从1开始计)交换就会把元素3的稳定性打乱，所以快速排序是一个不稳定的排序算法，不稳定发生在中枢元素和a[j] 交换的时刻。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h1&gt;&lt;p&gt;假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中，ri=rj，且ri在rj之前
      
    
    </summary>
    
      <category term="算法" scheme="http://nizouba.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="排序" scheme="http://nizouba.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>Java ArrayList工作原理及实现</title>
    <link href="http://nizouba.com/2018/07/15/Java-ArrayList%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/"/>
    <id>http://nizouba.com/2018/07/15/Java-ArrayList工作原理及实现/</id>
    <published>2018-07-15T08:00:59.000Z</published>
    <updated>2018-07-15T08:06:42.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>以数组实现。节约空间，但数组有容量限制。超出限制时会增加50%容量，用System.arraycopy()复制到新的数组，因此最好能给出数组大小的预估值。默认第一次插入元素时创建大小为10的数组。</p><p>按数组下标访问元素—get(i)/set(i,e) 的性能很高，这是数组的基本优势。</p><p>直接在数组末尾加入元素—add(e)的性能也高，但如果按下标插入、删除元素—add(i,e), remove(i), remove(e)，则要用System.arraycopy()来移动部分受影响的元素，性能就变差了，这是基本劣势。</p><h1 id="add函数"><a href="#add函数" class="headerlink" title="add函数"></a>add函数</h1><p>也就是说，当增加数据的时候，如果ArrayList的大小已经不满足需求时，那么就将数组变为原长度的1.5倍，之后的操作就是把老的数组拷到新的数组里面。例如，默认的数组大小是10，也就是说当我们add10个元素之后，再进行一次add时，就会发生自动扩容，数组长度由10变为了15具体情况如下</p><h1 id="set和get函数"><a href="#set和get函数" class="headerlink" title="set和get函数"></a>set和get函数</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;以数组实现。节约空间，但数组有容量限制。超出限制时会增加50%容量，用System.arraycopy()复制到新的数组，因此最好能给出数组
      
    
    </summary>
    
      <category term="Java" scheme="http://nizouba.com/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>MySQL的X锁和S锁</title>
    <link href="http://nizouba.com/2018/07/15/MySQL%E7%9A%84X%E9%94%81%E5%92%8CS%E9%94%81/"/>
    <id>http://nizouba.com/2018/07/15/MySQL的X锁和S锁/</id>
    <published>2018-07-15T06:44:29.000Z</published>
    <updated>2018-07-15T06:45:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>mysql X锁和S锁基本的封锁类型有两种:</p><p>排它锁(X锁)和共享锁(S锁)：</p><h1 id="X锁"><a href="#X锁" class="headerlink" title="X锁"></a>X锁</h1><p>所谓X锁,是事务T对数据A加上X锁时,只允许事务T读取和修改数据A</p><h1 id="S锁"><a href="#S锁" class="headerlink" title="S锁"></a>S锁</h1><p>所谓S锁,是事务T对数据A加上S锁时,其他事务只能再对数据A加S锁,而不能加X锁,直到T释放A上的S锁</p><p>若事务T对数据对象A加了S锁,则T就可以对A进行读取,但不能进行更新(S锁因此又称为读锁),在T释放A上的S锁以前,其他事务可以再对A加S锁,但不能加X锁,从而可以读取A,但不能更新A.</p><p><a href="http://www.cnblogs.com/digdeep/archive/2015/11/16/4968453.html" target="_blank" rel="noopener">http://www.cnblogs.com/digdeep/archive/2015/11/16/4968453.html</a></p><p>学习了mysql加锁机制，RC，RR，与字段的索引还有关系，如何防止死锁，不同情况的加锁。</p><p>学习where条件的过滤</p><p>给定一条SQL，如何提取其中的where条件？where条件中的每个子条件，在SQL执行的过程中有分别起着什么样的作用？</p><p><a href="http://hedengcheng.com/?p=577" target="_blank" rel="noopener">http://hedengcheng.com/?p=577</a></p><p>Index Key 索引查找，第一遍找出最小值，随后需要逐个比较是否满足最大值的条件，得到最大值。</p><p>Index First Key — Index Last Key</p><p>Index Filter 索引过滤，对于索引查找出的值，均需要与索引过滤条件对比</p><p>Table Filter 对于没有命中索引的字段，需要回表查出完整记录，对其进行过滤</p><p>作者：健身编码工<br>链接：<a href="https://www.jianshu.com/p/342f526dbbc2" target="_blank" rel="noopener">https://www.jianshu.com/p/342f526dbbc2</a><br>來源：简书<br>简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;mysql X锁和S锁基本的封锁类型有两种:&lt;/p&gt;
&lt;p&gt;排它锁(X锁)和共享锁(S锁)：&lt;/p&gt;
&lt;h1 id=&quot;X锁&quot;&gt;&lt;a href=&quot;#X锁&quot; class=&quot;headerlink&quot; title=&quot;X锁&quot;&gt;&lt;/a&gt;X锁&lt;/h1&gt;&lt;p&gt;所谓X锁,是事务T对数据A加上X
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>MySQL binlog_format (Mixed,Statement,Row)</title>
    <link href="http://nizouba.com/2018/07/15/MySQL-binlog-format-Mixed-Statement-Row/"/>
    <id>http://nizouba.com/2018/07/15/MySQL-binlog-format-Mixed-Statement-Row/</id>
    <published>2018-07-15T05:15:30.000Z</published>
    <updated>2018-07-15T05:33:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>MySQL 5.5 中对于二进制日志 (binlog) 有 3 种不同的格式可选：Mixed,Statement,Row，默认格式是 Statement。总结一下这三种格式日志的优缺点。</p><p>MySQL Replication 复制可以是基于一条语句 (Statement Level) ，也可以是基于一条记录 (Row Level)，可以在 MySQL 的配置参数中设定这个复制级别，不同复制级别的设置会影响到 Master 端的 bin-log 日志格式。</p><h1 id="Row"><a href="#Row" class="headerlink" title="Row"></a>Row</h1><p>日志中会记录成每一行数据被修改的形式，然后在 slave 端再对相同的数据进行修改。</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>在 row 模式下，bin-log 中可以不记录执行的 SQL 语句的上下文相关的信息，仅仅只需要记录那一条记录被修改了，修改成什么样了。所以 row 的日志内容会非常清楚的记录下每一行数据修改的细节，非常容易理解。而且不会出现某些特定情况下的存储过程或 function ，以及 trigger 的调用和触发无法被正确复制的问题。</p><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>在 row 模式下，所有的执行的语句当记录到日志中的时候，都将以每行记录的修改来记录，这样可能会产生大量的日志内容，比如有这样一条 update 语句</p><p>UPDATE product SET owner_member_id = ‘b’ WHERE owner_member_id = ‘a’</p><p>执行之后，日志中记录的不是这条 update 语句所对应的事件 (MySQL 以事件的形式来记录 bin-log 日志) ，而是这条语句所更新的每一条记录的变化情况，这样就记录成很多条记录被更新的很多个事件。自然，bin-log 日志的量就会很大。尤其是当执行 alter table 之类的语句的时候，产生的日志量是惊人的。因为 MySQL 对于 alter table 之类的表结构变更语句的处理方式是整个表的每一条记录都需要变动，实际上就是重建了整个表。那么该表的每一条记录都会被记录到日志中。</p><h1 id="Statement"><a href="#Statement" class="headerlink" title="Statement"></a>Statement</h1><p>每一条会修改数据的 SQL 都会记录到 master 的 bin-log 中。slave 在复制的时候 SQL 进程会解析成和原来 master 端执行过的相同的 SQL 再次执行。</p><h2 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h2><p>在 statement 模式下，首先就是解决了 row 模式的缺点，不需要记录每一行数据的变化，减少了 bin-log 日志量，节省 I/O 以及存储资源，提高性能。因为他只需要记录在 master 上所执行的语句的细节，以及执行语句时候的上下文的信息。</p><h2 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h2><p>在 statement 模式下，由于他是记录的执行语句，所以，为了让这些语句在 slave 端也能正确执行，那么他还必须记录每条语句在执行的时候的一些相关信息，也就是上下文信息，以保证所有语句在 slave 端杯执行的时候能够得到和在 master 端执行时候相同的结果。另外就是，由于 MySQL 现在发展比较快，很多的新功能不断的加入，使 MySQL 的复制遇到了不小的挑战，自然复制的时候涉及到越复杂的内容，bug 也就越容易出现。在 statement 中，目前已经发现的就有不少情况会造成 MySQL 的复制出现问题，主要是修改数据的时候使用了某些特定的函数或者功能的时候会出现，比如：sleep() 函数在有些版本中就不能被正确复制，在存储过程中使用了 last_insert_id() 函数，可能会使 slave 和 master 上得到不一致的 id 等等。由于 row 是基于每一行来记录的变化，所以不会出现类似的问题。</p><h1 id="Mixed"><a href="#Mixed" class="headerlink" title="Mixed"></a>Mixed</h1><p>从官方文档中看到，之前的 MySQL 一直都只有基于 statement 的复制模式，直到 5.1.5 版本的 MySQL 才开始支持 row 复制。从 5.0 开始，MySQL 的复制已经解决了大量老版本中出现的无法正确复制的问题。但是由于存储过程的出现，给 MySQL Replication 又带来了更大的新挑战。另外，看到官方文档说，从 5.1.8 版本开始，MySQL 提供了除 Statement 和 Row 之外的第三种复制模式：Mixed，实际上就是前两种模式的结合。在 Mixed 模式下，MySQL 会根据执行的每一条具体的 SQL 语句来区分对待记录的日志形式，也就是在 statement 和 row 之间选择一种。新版本中的 statment 还是和以前一样，仅仅记录执行的语句。而新版本的 MySQL 中对 row 模式也被做了优化，并不是所有的修改都会以 row 模式来记录，比如遇到表结构变更的时候就会以 statement 模式来记录，如果 SQL 语句确实就是 update 或者 delete 等修改数据的语句，那么还是会记录所有行的变更。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;MySQL 5.5 中对于二进制日志 (binlog) 有 3 种不同的格式可选：Mixed,Statement,Row，默认格式是 Statement。总结一下这三种格式日志的优缺点。&lt;/p&gt;
&lt;p&gt;MySQL Replication 复制可以是基于一条语句 (State
      
    
    </summary>
    
      <category term="MySQL" scheme="http://nizouba.com/categories/MySQL/"/>
    
    
  </entry>
  
  <entry>
    <title>MySQL使用可重复读作为默认隔离级别的原因之一</title>
    <link href="http://nizouba.com/2018/07/15/MySQL%E4%BD%BF%E7%94%A8%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E4%BD%9C%E4%B8%BA%E9%BB%98%E8%AE%A4%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E7%9A%84%E5%8E%9F%E5%9B%A0%E4%B9%8B%E4%B8%80/"/>
    <id>http://nizouba.com/2018/07/15/MySQL使用可重复读作为默认隔离级别的原因之一/</id>
    <published>2018-07-15T03:28:53.000Z</published>
    <updated>2018-07-15T06:42:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>一般的DBMS系统，默认都会使用读提交（Read-Comitted，RC）作为默认隔离级别，如Oracle、SQL Server等，而MySQL却使用可重复读（Read-Repeatable，RR）。要知道，越高的隔离级别，能解决的数据一致性问题越多，理论上性能损耗更大，可并发性越低。隔离级别依次为</p><p>RU&lt;RC&lt;RR&lt;SERIALIZABLE</p><p>在SQL标准中，4个隔离级别解决5种并发问题。对应解决了第一类丢失、脏读、（不可重复读+第二类丢失）、幻象读</p><ol><li>从Binlog说起<br>Binlog是MySQL的逻辑操作日志，广泛应用于复制和恢复。MySQL 5.1以前，Statement是Binlog的默认格式，即依次记录系统接受的SQL请求；5.1及以后，MySQL提供了Row和Mixed两个Binlog格式。</li></ol><p>从MySQL 5.1开始，Binlog为Statement，就不支持RC和Read-Uncommited隔离级别。要想使用RC隔离级别，必须使用Mixed或Row格式。</p><pre><code>mysql&gt; set tx_isolation=&#39;read-committed&#39;;Query OK, 0 rows affected (0.00 sec)mysql&gt; insert into t1 values(1,1);ERROR 1598 (HY000): Binary logging not possible. Message: Transaction level &#39;READ-COMMITTED&#39; in InnoDB is not safe for binlog mode &#39;STATEMENT&#39;</code></pre><p><a href="https://blog.csdn.net/zxk364961978/article/details/51564832" target="_blank" rel="noopener">https://blog.csdn.net/zxk364961978/article/details/51564832</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一般的DBMS系统，默认都会使用读提交（Read-Comitted，RC）作为默认隔离级别，如Oracle、SQL Server等，而MySQL却使用可重复读（Read-Repeatable，RR）。要知道，越高的隔离级别，能解决的数据一致性问题越多，理论上性能损耗更大，可
      
    
    </summary>
    
      <category term="MySQL" scheme="http://nizouba.com/categories/MySQL/"/>
    
    
  </entry>
  
</feed>
