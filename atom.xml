<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>你走吧</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://nizouba.com/"/>
  <updated>2018-07-24T16:54:28.000Z</updated>
  <id>http://nizouba.com/</id>
  
  <author>
    <name>zwxbest</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Dockerfile指令</title>
    <link href="http://nizouba.com/2018/07/25/Dockerfile%E6%8C%87%E4%BB%A4/"/>
    <id>http://nizouba.com/2018/07/25/Dockerfile指令/</id>
    <published>2018-07-24T16:46:22.000Z</published>
    <updated>2018-07-24T16:54:28.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="cmd"><a href="#cmd" class="headerlink" title="cmd"></a>cmd</h1><p>容器启动时要运行的命令，和docker run nginx /bin/bash差不多，cmd[“/bin/bash”]，只能指定一条cmd指令，如果指定多条，只有最后一条会生效</p><h2 id="传参数"><a href="#传参数" class="headerlink" title="传参数"></a>传参数</h2><p>cmd [“/bin/bash”,”-l”]</p><h2 id="和run的区别"><a href="#和run的区别" class="headerlink" title="和run的区别"></a>和run的区别</h2><p>run是镜像构建时要运行的命令</p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>docker run后跟命令会覆盖cmd的命令</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;cmd&quot;&gt;&lt;a href=&quot;#cmd&quot; class=&quot;headerlink&quot; title=&quot;cmd&quot;&gt;&lt;/a&gt;cmd&lt;/h1&gt;&lt;p&gt;容器启动时要运行的命令，和docker run nginx /bin/bash差不多，cmd[“/bin/bash”]，只能指定一条
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Shiro活动图2</title>
    <link href="http://nizouba.com/2018/07/24/Shiro%E6%B4%BB%E5%8A%A8%E5%9B%BE2/"/>
    <id>http://nizouba.com/2018/07/24/Shiro活动图2/</id>
    <published>2018-07-24T12:28:31.000Z</published>
    <updated>2018-07-25T04:57:57.163Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>git常用命令整理</title>
    <link href="http://nizouba.com/2018/07/24/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86/"/>
    <id>http://nizouba.com/2018/07/24/git常用命令整理/</id>
    <published>2018-07-24T06:54:57.000Z</published>
    <updated>2018-07-25T10:13:38.848Z</updated>
    
    <content type="html"><![CDATA[<ul><li>切换分支 git checkout dev 切换到dev分支</li><li>新建分支并切换 git checkout -b dev 新建dev分支并切换</li><li>查看远程仓库名字 git remote </li><li>查看版本库信息 git remote show origin </li><li>查看远程分支 git branch -a</li><li>查看本地分支 git branch</li><li>从远程更新下来branch和tag等 git fetch </li><li>git commit -m 将暂存区的放到head中</li><li>git commit -a -m 相当于git add .和git commit -m</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;切换分支 git checkout dev 切换到dev分支&lt;/li&gt;
&lt;li&gt;新建分支并切换 git checkout -b dev 新建dev分支并切换&lt;/li&gt;
&lt;li&gt;查看远程仓库名字 git remote &lt;/li&gt;
&lt;li&gt;查看版本库信息 git r
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>jenkins实现测试环境的自动化部署</title>
    <link href="http://nizouba.com/2018/07/23/jenkins%E5%AE%9E%E7%8E%B0%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83%E7%9A%84%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/"/>
    <id>http://nizouba.com/2018/07/23/jenkins实现测试环境的自动化部署/</id>
    <published>2018-07-22T17:13:56.000Z</published>
    <updated>2018-07-22T17:13:56.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>mysql left join中where和on条件的区别</title>
    <link href="http://nizouba.com/2018/07/21/mysql-left-join%E4%B8%ADwhere%E5%92%8Con%E6%9D%A1%E4%BB%B6%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://nizouba.com/2018/07/21/mysql-left-join中where和on条件的区别/</id>
    <published>2018-07-21T14:24:48.000Z</published>
    <updated>2018-07-21T14:34:41.000Z</updated>
    
    <content type="html"><![CDATA[<p>left join中关于where和on条件的几个知识点：</p><ol><li>多表left join是会生成一张临时表，并返回给用户</li><li>where条件是针对最后生成的这张临时表进行过滤，过滤掉不符合where条件的记录，是真正的不符合就过滤掉。</li><li>on条件是对left join的右表进行条件过滤，但依然返回左表的所有行，右表中没有的补为NULL</li><li>on条件中如果有对左表的限制条件，无论条件真假，依然返回左表的所有行,但是会影响右表的匹配值。也就是说on中左表的限制条件只影响右表的匹配内容，不影响返回行数。<br>结论：</li><li>where条件中对左表限制，不能放到on后面</li><li>where条件中对右表限制，放到on后面，会有数据行数差异，比原来行数要多</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;left join中关于where和on条件的几个知识点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;多表left join是会生成一张临时表，并返回给用户&lt;/li&gt;
&lt;li&gt;where条件是针对最后生成的这张临时表进行过滤，过滤掉不符合where条件的记录，是真正的不符合就过滤掉。&lt;/l
      
    
    </summary>
    
      <category term="MySQL" scheme="http://nizouba.com/categories/MySQL/"/>
    
    
  </entry>
  
  <entry>
    <title>MySQL开发技巧</title>
    <link href="http://nizouba.com/2018/07/21/MySQL%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/"/>
    <id>http://nizouba.com/2018/07/21/MySQL开发技巧/</id>
    <published>2018-07-21T12:14:52.000Z</published>
    <updated>2018-07-22T05:30:54.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SQL语句分类"><a href="#SQL语句分类" class="headerlink" title="SQL语句分类"></a>SQL语句分类</h2><ol><li>DDL</li><li>TPL 事务处理语言</li><li>DCL 数据控制语言</li><li>DML select insert update delete</li></ol><h2 id="join语句优化"><a href="#join语句优化" class="headerlink" title="join语句优化"></a>join语句优化</h2><ol><li>inner</li><li>full  left和right的结合，whrer a.key is null or b.key is null,a is null是B的独占部分，b is null是a的独占部分，mysql不支持full join，使用union all左连接和右连接</li><li>left a left join b where b.key is null,只包含A的部分，不包含中间部分和B，中间部分是b.key is not null</li><li>right </li><li>cross 笛卡儿积查询，a表和b表的交叉连接，5X4=20</li></ol><h2 id="join更新表"><a href="#join更新表" class="headerlink" title="join更新表"></a>join更新表</h2><p>join更新的表不能出现在from从句中。比如update user set a=1 where a in (select * from user)</p><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p>使用join，update user join （select ）</p><h2 id="join优化子查询"><a href="#join优化子查询" class="headerlink" title="join优化子查询"></a>join优化子查询</h2><h2 id="join优化聚合查询"><a href="#join优化聚合查询" class="headerlink" title="join优化聚合查询"></a>join优化聚合查询</h2><p>select a.user_name,b.timestr,b.kills,c.kills<br>from user1 a<br>join user_kills b on a.id=b.user_id<br>join user_kills c on c.user_id=b.user_id<br>GROUP BY a.user_name,b.timestr,b.kills<br>having b.kills=max(c.kills)</p><h2 id="join分组选择"><a href="#join分组选择" class="headerlink" title="join分组选择"></a>join分组选择</h2><p>每一系列文章最多的前几条文章</p><pre><code>SELECTd.user_name,c.timestr,killsFROM    (        SELECT            user_id,            timestr,            kills,            (                SELECT                    count(*)                FROM                    user_kills b                WHERE                    b.user_id = a.user_id                AND a.kills &lt;= b.kills            ) AS cnt        FROM            user_kills a            ) cJOIN user1 d ON c.user_id = d.idWHERE    cnt &lt;= 2</code></pre><h1 id="行转列"><a href="#行转列" class="headerlink" title="行转列"></a>行转列</h1><h2 id="使用自连接-同一个表进行连接-的方法实现"><a href="#使用自连接-同一个表进行连接-的方法实现" class="headerlink" title="使用自连接(同一个表进行连接)的方法实现"></a>使用自连接(同一个表进行连接)的方法实现</h2><pre><code>select *from (select SUM(kills) as &#39;沙僧&#39;from user1 a join user_kills  b on a.id=b.user_idand a.user_name=&#39;沙僧&#39;) a cross JOIN(select SUM(kills) as &#39;猪八戒&#39;from user1 a join user_kills  b on a.id=b.user_idand a.user_name=&#39;猪八戒&#39;) b cross join (select SUM(kills) as &#39;孙悟空&#39;from user1 a join user_kills  b on a.id=b.user_idand a.user_name=&#39;孙悟空&#39;) c</code></pre><h2 id="使用case方法实现行列转换"><a href="#使用case方法实现行列转换" class="headerlink" title="使用case方法实现行列转换"></a>使用case方法实现行列转换</h2><pre><code>select sum(case when user_name=&#39;孙悟空&#39; then kills end)as &#39;孙悟空&#39;,sum(case when user_name=&#39;猪八戒&#39; then kills end)as &#39;猪八戒&#39;,sum(case when user_name=&#39;沙僧&#39; then kills end)as &#39;沙僧&#39;from user1 a join user_kills b on a.id=b.user_id;</code></pre><h2 id="属性拆分，ETL数据处理（和属性拆分一个意思）"><a href="#属性拆分，ETL数据处理（和属性拆分一个意思）" class="headerlink" title="属性拆分，ETL数据处理（和属性拆分一个意思）"></a>属性拆分，ETL数据处理（和属性拆分一个意思）</h2><h3 id="比如一个属性是用，组合成的"><a href="#比如一个属性是用，组合成的" class="headerlink" title="比如一个属性是用，组合成的"></a>比如一个属性是用，组合成的</h3><h1 id="唯一序列号"><a href="#唯一序列号" class="headerlink" title="唯一序列号"></a>唯一序列号</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;SQL语句分类&quot;&gt;&lt;a href=&quot;#SQL语句分类&quot; class=&quot;headerlink&quot; title=&quot;SQL语句分类&quot;&gt;&lt;/a&gt;SQL语句分类&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;DDL&lt;/li&gt;
&lt;li&gt;TPL 事务处理语言&lt;/li&gt;
&lt;li&gt;DCL 数据控制语言&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>MySQL性能优化</title>
    <link href="http://nizouba.com/2018/07/21/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <id>http://nizouba.com/2018/07/21/MySQL性能优化/</id>
    <published>2018-07-21T07:21:33.000Z</published>
    <updated>2018-07-21T12:11:53.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h1><ol><li>解决数据库连接造成的timeout的5XX错误</li><li>慢查询</li><li>阻塞</li></ol><h1 id="方面"><a href="#方面" class="headerlink" title="方面"></a>方面</h1><ol><li>SQL以及索引</li><li>数据库表结构</li><li>系统配置</li><li>硬件</li></ol><h1 id="SQL索引以及优化"><a href="#SQL索引以及优化" class="headerlink" title="SQL索引以及优化"></a>SQL索引以及优化</h1><h2 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h2><h3 id="开启慢查询日志"><a href="#开启慢查询日志" class="headerlink" title="开启慢查询日志"></a>开启慢查询日志</h3><p>show variables like ‘%quer%’</p><p>set gloabl log_queries_not_using_indexes=on;<br>记录未使用索引的查询</p><p>set global slow_query_log=on;<br>打开慢查询日志</p><p>set global long_query_time 1;<br>慢查询时间设置为1s</p><h3 id="慢查询日志分析"><a href="#慢查询日志分析" class="headerlink" title="慢查询日志分析"></a>慢查询日志分析</h3><h4 id="mysqldumpslow"><a href="#mysqldumpslow" class="headerlink" title="mysqldumpslow"></a>mysqldumpslow</h4><p>-s 排序慢查询日志<br>-t 查看前多少条</p><h4 id="pt-query——digest"><a href="#pt-query——digest" class="headerlink" title="pt-query——digest"></a>pt-query——digest</h4><p>-limit 分析多少条</p><ol><li>注意次数多且每次查询占用时间长的SQL</li><li>注意Rows examine项，扫描行数，IO</li><li>Rows examine远远大于Rows send，表示未命中索引的SQL多</li></ol><h2 id="explain"><a href="#explain" class="headerlink" title="explain"></a>explain</h2><ul><li>table 那张表</li><li>type 好到差 const 主键唯一索引，eq_reg,主键或者唯一索引的范围查找，ref 连接查询，一个表是基于某个索引的，range基于索引的范围查找，index索引扫描，all表扫描。</li><li>possible—_keys 用到的索引有哪些，为空表示没用到</li><li>keys 实际用到的索引</li><li>key——len 索引长度，越短越好</li><li>ref 哪一列索引被使用了</li><li>rows 检查用来返回的请求数据的行数</li><li>extra filesort，文件排序了，temporary 使用了临时表</li></ul><h3 id="对max和count优化"><a href="#对max和count优化" class="headerlink" title="对max和count优化"></a>对max和count优化</h3><pre><code>select  count(release_year=&#39;2006&#39; or null) as &#39;2006年的电影数量&#39;,count(release_year=&#39;2007&#39; or null) as &#39;2007年的电影数量&#39;,from film</code></pre><p>注意or null，因为count不计算null，如果不写or null，那即使count条件不成立，相当于1，也包含在内</p><h3 id="子查询优化"><a href="#子查询优化" class="headerlink" title="子查询优化"></a>子查询优化</h3><ol><li>in改成join，注意可能会出现重复</li></ol><h2 id="group-by"><a href="#group-by" class="headerlink" title="group by"></a>group by</h2><pre><code>select actor.first_name,actor.last_name,COUNT(*)from film_actorINNER JOIN actor using(actor_id)GROUP BY actor.actor_idselect actor.first_name,actor.last_name,COUNT(*)from actorINNER JOIN (select actor_id,count(*) as cnt from film_actor GROUP BY actor_id) as c using(actor_id)</code></pre><h1 id="lmit优化"><a href="#lmit优化" class="headerlink" title="lmit优化"></a>lmit优化</h1><p>select .. where id &gt; 50 and id &lt;60 limit 1,5<br>比select … limit 50,55的row要好<br>但是要保证id是连续的，不能中断，可以加一个index字段</p><h1 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h1><ol><li>在group by 从句，where，order by，on</li><li>索引字段越小越好</li><li>离散度越大（不同的数目越多），的放在联合索引前面</li><li>减小重复索引，primary key和unique（id）</li><li>多余索引，联合索引包含了主键的列。</li><li>有查找重复索引和冗余索引的sql</li><li>pt-duplicate-key-checker工具检查重复以及冗余索引</li><li>mysql中只能通过慢日志配合pt-index-usage根据进行使用情况的分析。</li></ol><h1 id="数据库结构优化"><a href="#数据库结构优化" class="headerlink" title="数据库结构优化"></a>数据库结构优化</h1><ol><li>最小的数据类型</li><li>简单的数据类型，时间上int比varchar简单</li><li>尽量使用not null</li><li>尽量少用text类型，非用不可考虑分表</li><li>int来存储时间</li><li>bigint来存储inet_aton() ip地址</li></ol><h1 id="范式优化"><a href="#范式优化" class="headerlink" title="范式优化"></a>范式优化</h1><p>目前遵循第三范式</p><p>数据表中不存在非关键字字段对任意候选关键字字段的传递函数依赖</p><h2 id="不符合第三范式的表的问题"><a href="#不符合第三范式的表的问题" class="headerlink" title="不符合第三范式的表的问题"></a>不符合第三范式的表的问题</h2><ol><li>冗余</li><li>更新，删除，插入异常</li></ol><h2 id="反范式化"><a href="#反范式化" class="headerlink" title="反范式化"></a>反范式化</h2><p>增加冗余</p><h2 id="表的垂直拆分"><a href="#表的垂直拆分" class="headerlink" title="表的垂直拆分"></a>表的垂直拆分</h2><p>很多列拆分成</p><ol><li>把不常用的放一个表中，常用的放在一起</li><li>大字段放在一个表中</li></ol><h2 id="水平拆分"><a href="#水平拆分" class="headerlink" title="水平拆分"></a>水平拆分</h2><ol><li>进行hash运算，取余拆分</li><li>针对不同的hashid放到不同表中</li></ol><h3 id="挑战"><a href="#挑战" class="headerlink" title="挑战"></a>挑战</h3><ol><li>跨分区表进行汇总统计</li></ol><h2 id="配置优化"><a href="#配置优化" class="headerlink" title="配置优化"></a>配置优化</h2><ol><li>net—.tcp_max 增加tcp支持的队列数</li><li>资源回收 tw_buckets  加快回收</li><li>打开文件数限制</li><li>关闭selinux，iptables，使用硬件防火墙</li><li>配置文件多个后面的会覆盖前面的</li><li>innbodb——buffer_pool_size innodb缓冲池大小</li><li>pool——instances 缓冲池的个数</li><li>log——buffer—size 日志缓冲区</li><li>flush——log——at——trx——commit 数据安全质较高设置为2</li><li>read——io——threads write 读写进程</li><li>file——per——table 共享表空间，默认为off，所有的</li><li>stats——on——meta 决定mysql在什么情况下刷新innodb表的统计信息。</li></ol><h1 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h1><ol><li>raid 多个磁盘组成一个磁盘</li><li>raid 要求至少两个磁盘</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;目的&quot;&gt;&lt;a href=&quot;#目的&quot; class=&quot;headerlink&quot; title=&quot;目的&quot;&gt;&lt;/a&gt;目的&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;解决数据库连接造成的timeout的5XX错误&lt;/li&gt;
&lt;li&gt;慢查询&lt;/li&gt;
&lt;li&gt;阻塞&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>《高性能MySQL》读书笔记</title>
    <link href="http://nizouba.com/2018/07/19/%E3%80%8A%E9%AB%98%E6%80%A7%E8%83%BDMySQL%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>http://nizouba.com/2018/07/19/《高性能MySQL》读书笔记/</id>
    <published>2018-07-19T04:42:29.000Z</published>
    <updated>2018-07-24T12:27:24.039Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="MySQL" scheme="http://nizouba.com/categories/MySQL/"/>
    
    
  </entry>
  
  <entry>
    <title>《MySQL技术内幕：InnoDB存储引擎》读书笔记</title>
    <link href="http://nizouba.com/2018/07/19/%E3%80%8AMySQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95%EF%BC%9AInnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>http://nizouba.com/2018/07/19/《MySQL技术内幕：InnoDB存储引擎》读书笔记/</id>
    <published>2018-07-19T04:34:53.000Z</published>
    <updated>2018-07-19T04:34:53.759Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>test</title>
    <link href="http://nizouba.com/2018/07/18/test/"/>
    <id>http://nizouba.com/2018/07/18/test/</id>
    <published>2018-07-18T11:04:47.000Z</published>
    <updated>2018-07-18T11:04:47.842Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>锁优化</title>
    <link href="http://nizouba.com/2018/07/17/%E9%94%81%E4%BC%98%E5%8C%96/"/>
    <id>http://nizouba.com/2018/07/17/锁优化/</id>
    <published>2018-07-17T04:09:14.000Z</published>
    <updated>2018-07-17T04:19:30.000Z</updated>
    
    <content type="html"><![CDATA[<ol><li>减小锁持有时间</li><li>减小锁粒度</li><li>读写分离锁替换独占锁</li><li>锁分离，比如LinkedBlockingQueue,插入在队尾，取出在队头。</li><li>锁粗化。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;减小锁持有时间&lt;/li&gt;
&lt;li&gt;减小锁粒度&lt;/li&gt;
&lt;li&gt;读写分离锁替换独占锁&lt;/li&gt;
&lt;li&gt;锁分离，比如LinkedBlockingQueue,插入在队尾，取出在队头。&lt;/li&gt;
&lt;li&gt;锁粗化。&lt;/li&gt;
&lt;/ol&gt;

      
    
    </summary>
    
    
      <category term="并发" scheme="http://nizouba.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>JDK的并发容器</title>
    <link href="http://nizouba.com/2018/07/17/JDK%E7%9A%84%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/"/>
    <id>http://nizouba.com/2018/07/17/JDK的并发容器/</id>
    <published>2018-07-17T01:39:45.000Z</published>
    <updated>2018-07-17T04:07:36.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h1><h1 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h1><p>读取不需要加锁，写入也不会阻塞读取操作，写入和写入需要同步等待</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>在写入操作时，进行一次自我复制，并不修改原有的内容，写完之后，再将副本替换原来的数据。</p><h1 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h1><p>高效的读写队列，使用cas无锁</p><h1 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h1><p>数据共享通道</p><h1 id="ConcurrentSkipListMap"><a href="#ConcurrentSkipListMap" class="headerlink" title="ConcurrentSkipListMap"></a>ConcurrentSkipListMap</h1><p>跳表，用来快速查找的</p><h1 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h1><h1 id="Collections工具类包装线程安全"><a href="#Collections工具类包装线程安全" class="headerlink" title="Collections工具类包装线程安全"></a>Collections工具类包装线程安全</h1><p>使用synchronize锁保证线程安全</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ConcurrentHashMap&quot;&gt;&lt;a href=&quot;#ConcurrentHashMap&quot; class=&quot;headerlink&quot; title=&quot;ConcurrentHashMap&quot;&gt;&lt;/a&gt;ConcurrentHashMap&lt;/h1&gt;&lt;h1 id=&quot;CopyO
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java并发之volatile</title>
    <link href="http://nizouba.com/2018/07/17/Java%E5%B9%B6%E5%8F%91%E4%B9%8Bvolatile/"/>
    <id>http://nizouba.com/2018/07/17/Java并发之volatile/</id>
    <published>2018-07-17T01:34:51.000Z</published>
    <updated>2018-07-17T01:37:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>volatile能保证可见性和有序性</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;volatile能保证可见性和有序性&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>synchronized与线程安全</title>
    <link href="http://nizouba.com/2018/07/17/synchronized%E4%B8%8E%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/"/>
    <id>http://nizouba.com/2018/07/17/synchronized与线程安全/</id>
    <published>2018-07-17T01:23:04.000Z</published>
    <updated>2018-07-17T01:30:54.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线程的3个特性"><a href="#线程的3个特性" class="headerlink" title="线程的3个特性"></a>线程的3个特性</h1><p>VOA</p><ol><li>原子性 atom，指一个操作是不可中断的 </li><li>可见性 当一个变量修改了某一个共享变量的值，其他线程是否能够立即得知这个修改。</li><li><p>有序性 程序在执行时，可能会进行指令重排。</p><h1 id="synchronized的3种用法"><a href="#synchronized的3种用法" class="headerlink" title="synchronized的3种用法"></a>synchronized的3种用法</h1></li><li><p>指定加锁对象</p></li><li>直接作用于实例方法</li><li>直接作用于静态方法</li></ol><h1 id="能保证的地方"><a href="#能保证的地方" class="headerlink" title="能保证的地方"></a>能保证的地方</h1><ol><li>可见性</li><li></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;线程的3个特性&quot;&gt;&lt;a href=&quot;#线程的3个特性&quot; class=&quot;headerlink&quot; title=&quot;线程的3个特性&quot;&gt;&lt;/a&gt;线程的3个特性&lt;/h1&gt;&lt;p&gt;VOA&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;原子性 atom，指一个操作是不可中断的 &lt;/li&gt;
&lt;li&gt;可见
      
    
    </summary>
    
    
      <category term="并发" scheme="http://nizouba.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Elasticsearch索引的创建、数据的增删该查操作</title>
    <link href="http://nizouba.com/2018/07/16/Elasticsearch%E7%B4%A2%E5%BC%95%E7%9A%84%E5%88%9B%E5%BB%BA%E3%80%81%E6%95%B0%E6%8D%AE%E7%9A%84%E5%A2%9E%E5%88%A0%E8%AF%A5%E6%9F%A5%E6%93%8D%E4%BD%9C/"/>
    <id>http://nizouba.com/2018/07/16/Elasticsearch索引的创建、数据的增删该查操作/</id>
    <published>2018-07-16T13:23:03.000Z</published>
    <updated>2018-07-17T00:59:28.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1、创建Maven工程"><a href="#1、创建Maven工程" class="headerlink" title="1、创建Maven工程"></a>1、创建Maven工程</h1><pre><code>&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;groupId&gt;com.sun.elasticsearch&lt;/groupId&gt;    &lt;artifactId&gt;Elasticsearch01&lt;/artifactId&gt;    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;    &lt;dependencies&gt;        &lt;!-- Elasticsearch核心依赖包 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.elasticsearch.client&lt;/groupId&gt;            &lt;artifactId&gt;transport&lt;/artifactId&gt;            &lt;version&gt;5.5.2&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;junit&lt;/groupId&gt;            &lt;artifactId&gt;junit&lt;/artifactId&gt;            &lt;version&gt;4.12&lt;/version&gt;            &lt;scope&gt;test&lt;/scope&gt;        &lt;/dependency&gt;        &lt;!-- 日志依赖 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;            &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;            &lt;version&gt;1.7.21&lt;/version&gt;            &lt;scope&gt;test&lt;/scope&gt;        &lt;/dependency&gt;        &lt;!-- https://mvnrepository.com/artifact/org.apache.logging.log4j/log4j-core --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;            &lt;artifactId&gt;log4j-core&lt;/artifactId&gt;            &lt;version&gt;2.8.2&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- https://mvnrepository.com/artifact/com.google.code.gson/gson --&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.google.code.gson&lt;/groupId&gt;            &lt;artifactId&gt;gson&lt;/artifactId&gt;            &lt;version&gt;2.8.0&lt;/version&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;&lt;/project&gt;</code></pre><h1 id="2、通过Java程序连接Elasticsearch"><a href="#2、通过Java程序连接Elasticsearch" class="headerlink" title="2、通过Java程序连接Elasticsearch"></a>2、通过Java程序连接Elasticsearch</h1><pre><code>package com.sun.elasticsearch;import java.net.InetAddress;import java.net.UnknownHostException;import org.elasticsearch.client.transport.TransportClient;import org.elasticsearch.common.settings.Settings;import org.elasticsearch.common.transport.InetSocketTransportAddress;import org.elasticsearch.transport.client.PreBuiltTransportClient;import org.junit.Test;import org.slf4j.Logger;import org.slf4j.LoggerFactory;/*** Elasticsearch的基本测试* @ClassName: ElasticsearchTest1  * @author sunt  * @date 2017年11月22日 * @version V1.0*/public class ElasticsearchTest1 {    private Logger logger = LoggerFactory.getLogger(ElasticsearchTest1.class);    public final static String HOST = &quot;192.168.1.140&quot;;    public final static int PORT = 9300;//http请求的端口是9200，客户端是9300    /**    * 测试Elasticsearch客户端连接    * @Title: test1     * @author sunt      * @date 2017年11月22日    * @return void    * @throws UnknownHostException     */    @SuppressWarnings(&quot;resource&quot;)    @Test    public void test1() throws UnknownHostException {        //创建客户端        TransportClient client = new PreBuiltTransportClient(Settings.EMPTY).addTransportAddresses(                                new InetSocketTransportAddress(InetAddress.getByName(HOST),PORT));        logger.debug(&quot;Elasticsearch connect info:&quot; + client.toString());        //关闭客户端        client.close();    }}</code></pre><h1 id="3、Elasticsearch索引库的创建"><a href="#3、Elasticsearch索引库的创建" class="headerlink" title="3、Elasticsearch索引库的创建"></a>3、Elasticsearch索引库的创建</h1><pre><code>private Logger logger = LoggerFactory.getLogger(ElasticsearchTest2.class);public final static String HOST = &quot;192.168.1.140&quot;;public final static int PORT = 9300; //http请求的端口是9200，客户端是9300private TransportClient client = null;/** * 获取客户端连接信息 * @Title: getConnect  * @author sunt   * @date 2017年11月23日 * @return void * @throws UnknownHostException  */@SuppressWarnings({ &quot;resource&quot;, &quot;unchecked&quot; })@Beforepublic void getConnect() throws UnknownHostException {    client = new PreBuiltTransportClient(Settings.EMPTY).addTransportAddresses(             new InetSocketTransportAddress(InetAddress.getByName(HOST),PORT));    logger.info(&quot;连接信息:&quot; + client.toString());}/** * 关闭连接 * @Title: closeConnect  * @author sunt   * @date 2017年11月23日 * @return void */@After</code></pre><p>4、向索引库中添加json字符串<br>    public void closeConnect() {<br>        if(null != client) {<br>            logger.info(“执行关闭连接操作…”);<br>            client.close();<br>        }<br>    }</p><pre><code>/** * 创建索引库 * @Title: addIndex1 * @author sunt   * @date 2017年11月23日 * @return void * 需求:创建一个索引库为：msg消息队列,类型为：tweet,id为1 * 索引库的名称必须为小写 * @throws IOException  */@Testpublic void addIndex1() throws IOException {    IndexResponse response = client.prepareIndex(&quot;msg&quot;, &quot;tweet&quot;, &quot;1&quot;).setSource(XContentFactory.jsonBuilder()            .startObject().field(&quot;userName&quot;, &quot;张三&quot;)            .field(&quot;sendDate&quot;, new Date())            .field(&quot;msg&quot;, &quot;你好李四&quot;)            .endObject()).get();    logger.info(&quot;索引名称:&quot; + response.getIndex() + &quot;\n类型:&quot; + response.getType()                + &quot;\n文档ID:&quot; + response.getId() + &quot;\n当前实例状态:&quot; + response.status());}PS: 索引库名称必须为小写，如果为大写会包如下错误信息</code></pre><h1 id="4、向索引库中添加json字符串"><a href="#4、向索引库中添加json字符串" class="headerlink" title="4、向索引库中添加json字符串"></a>4、向索引库中添加json字符串</h1><pre><code>/**    * 添加索引:传入json字符串    * @Title: addIndex2     * @author sunt      * @date 2017年11月23日    * @return void    */    @Test    public void addIndex2() {        String jsonStr = &quot;{&quot; +                &quot;\&quot;userName\&quot;:\&quot;张三\&quot;,&quot; +                &quot;\&quot;sendDate\&quot;:\&quot;2017-11-30\&quot;,&quot; +                &quot;\&quot;msg\&quot;:\&quot;你好李四\&quot;&quot; +            &quot;}&quot;;        IndexResponse response = client.prepareIndex(&quot;weixin&quot;, &quot;tweet&quot;).setSource(jsonStr,XContentType.JSON).get();        logger.info(&quot;json索引名称:&quot; + response.getIndex() + &quot;\njson类型:&quot; + response.getType()        + &quot;\njson文档ID:&quot; + response.getId() + &quot;\n当前实例json状态:&quot; + response.status());    }</code></pre><h1 id="5、向索引库添加一个Map集合"><a href="#5、向索引库添加一个Map集合" class="headerlink" title="5、向索引库添加一个Map集合"></a>5、向索引库添加一个Map集合</h1><p>/**</p><pre><code> * 创建索引-传入Map对象 * @Title: addIndex3  * @author sunt   * @date 2017年11月23日 * @return void */@Testpublic void addIndex3() {    Map&lt;String, Object&gt; map = new HashMap&lt;String,Object&gt;();    map.put(&quot;userName&quot;, &quot;张三&quot;);    map.put(&quot;sendDate&quot;, new Date());    map.put(&quot;msg&quot;, &quot;你好李四&quot;);    IndexResponse response = client.prepareIndex(&quot;momo&quot;, &quot;tweet&quot;).setSource(map).get();    logger.info(&quot;map索引名称:&quot; + response.getIndex() + &quot;\n map类型:&quot; + response.getType()    + &quot;\n map文档ID:&quot; + response.getId() + &quot;\n当前实例map状态:&quot; + response.status());}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1、创建Maven工程&quot;&gt;&lt;a href=&quot;#1、创建Maven工程&quot; class=&quot;headerlink&quot; title=&quot;1、创建Maven工程&quot;&gt;&lt;/a&gt;1、创建Maven工程&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;&amp;lt;project xmlns=&amp;quot;ht
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>HashSet、TreeSet和LinkedHashSet的区别</title>
    <link href="http://nizouba.com/2018/07/16/HashSet%E3%80%81TreeSet%E5%92%8CLinkedHashSet%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://nizouba.com/2018/07/16/HashSet、TreeSet和LinkedHashSet的区别/</id>
    <published>2018-07-16T11:24:04.000Z</published>
    <updated>2018-07-16T11:48:28.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Set接口"><a href="#Set接口" class="headerlink" title="Set接口"></a>Set接口</h1><p>Set不允许包含相同的元素，如果试图把两个相同元素加入同一个集合中，add方法返回false。</p><h2 id="HashSet类"><a href="#HashSet类" class="headerlink" title="HashSet类"></a>HashSet类</h2><p>HashSet有以下特点</p><ol><li>不能保证元素的排列顺序，顺序有可能发生变化</li><li>不是同步的</li><li>集合元素可以是null,但只能放入一个null<br>当向HashSet结合中存入一个元素时，HashSet会调用该对象的hashCode()方法来得到该对象的hashCode值，然后根据 hashCode值来决定该对象在HashSet中存储位置。<br>简单的说，HashSet集合判断两个元素相等的标准是两个对象通过equals方法比较相等，并且两个对象的hashCode()方法返回值相 等<br>注意，如果要把一个对象放入HashSet中，重写该对象对应类的equals方法，也应该重写其hashCode()方法。其规则是如果两个对 象通过equals方法比较返回true时，其hashCode也应该相同。另外，对象中用作equals比较标准的属性，都应该用来计算 hashCode的值。</li></ol><h2 id="LinkedHashSet类"><a href="#LinkedHashSet类" class="headerlink" title="LinkedHashSet类"></a>LinkedHashSet类</h2><p>LinkedHashSet集合同样是根据元素的hashCode值来决定元素的存储位置，但是它同时使用链表维护元素的次序。这样使得元素看起 来像是以插入顺序保存的，也就是说，当遍历该集合时候，LinkedHashSet将会以元素的添加顺序访问集合的元素。<br>LinkedHashSet在迭代访问Set中的全部元素时，性能比HashSet好，但是插入时性能稍微逊色于HashSet。</p><h2 id="TreeSet类"><a href="#TreeSet类" class="headerlink" title="TreeSet类"></a>TreeSet类</h2><p>TreeSet是SortedSet接口的唯一实现类，TreeSet可以确保集合元素处于排序状态。TreeSet支持两种排序方式，自然排序 和定制排序，其中自然排序为认的排序方式。向TreeSet中加入的应该是同一个类的对象。默<br>TreeSet判断两个对象不相等的方式是两个对象通过equals方法返回false，或者通过CompareTo方法比较没有返回0<br>自然排序<br>自然排序使用要排序元素的CompareTo（Object obj）方法来比较元素之间大小关系，然后将元素按照升序排列。<br>Java提供了一个Comparable接口，该接口里定义了一个compareTo(Object obj)方法，该方法返回一个整数值，实现了该接口的对象就可以比较大小。<br>obj1.compareTo(obj2)方法如果返回0，则说明被比较的两个对象相等，如果返回一个正数，则表明obj1大于obj2，如果是 负数，则表明obj1小于obj2。<br>如果我们将两个对象的equals方法总是返回true，则这两个对象的compareTo方法返回应该返回0<br>定制排序<br>自然排序是根据集合元素的大小，以升序排列，如果要定制排序，应该使用Comparator接口，实现 int compare(T o1,T o2)方法</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Set接口&quot;&gt;&lt;a href=&quot;#Set接口&quot; class=&quot;headerlink&quot; title=&quot;Set接口&quot;&gt;&lt;/a&gt;Set接口&lt;/h1&gt;&lt;p&gt;Set不允许包含相同的元素，如果试图把两个相同元素加入同一个集合中，add方法返回false。&lt;/p&gt;
&lt;h2 id
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java GC工作原理以及Minor GC、Major GC、Full GC简单总结</title>
    <link href="http://nizouba.com/2018/07/16/Java-GC%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8AMinor-GC%E3%80%81Major-GC%E3%80%81Full-GC%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93/"/>
    <id>http://nizouba.com/2018/07/16/Java-GC工作原理以及Minor-GC、Major-GC、Full-GC简单总结/</id>
    <published>2018-07-16T04:01:50.000Z</published>
    <updated>2018-07-16T04:08:52.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h1><p>GC：垃圾收集器</p><p>Minor GC：新生代GC，指发生在新生代的垃圾收集动作，所有的Minor GC都会触发全世界的暂停（stop-the-world），停止应用程序的线程，不过这个过程非常短暂。</p><p>Major GC/Full GC：老年代GC，指发生在老年代的GC。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>众所周知，所有通过new创建的对象的内存都在堆中分配，堆被划分为新生代和老年代，新生代又被进一步划分为Eden和Survivor区，而Survivor由FromSpace和ToSpace组成。</p><h3 id="新生代"><a href="#新生代" class="headerlink" title="新生代"></a>新生代</h3><p>新创建的对象都是用新生代分配内存，Eden空间不足时，触发Minor GC，这时会把存活的对象转移进Survivor区。</p><h3 id="老年代"><a href="#老年代" class="headerlink" title="老年代"></a>老年代</h3><p>老年代用于存放经过多次Minor GC之后依然存活的对象。</p><h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><p>每个线程执行每个方法的时候都会在栈中申请一个栈帧，每个栈帧包括局部变量区和操作数栈，用于存放此次方法调用过程中的临时变量、参数和中间结果。</p><p>#本地方法栈</p><p>用于支持native方法的执行，存储了每个native方法调用的状态。</p><h1 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h1><p>存放了要加载的类信息、静态变量、final类型的常量、属性和方法信息。JVM用持久代(PermanetGeneration)来存放方法区。</p><h1 id="JVM垃圾回收机制"><a href="#JVM垃圾回收机制" class="headerlink" title="JVM垃圾回收机制"></a>JVM垃圾回收机制</h1><p>JVM分别对新生代和老年代采用不同的垃圾回收机制。</p><p>GC触发条件：Eden区满了触发Minor GC，这时会把Eden区存活的对象复制到Survivor区，当对象在Survivor区熬过一定次数的Minor GC之后，就会晋升到老年代（当然并不是所有的对象都是这样晋升的到老年代的），当老年代满了，就会报OutofMemory异常。</p><h2 id="新生代的GC（Minor-GC）："><a href="#新生代的GC（Minor-GC）：" class="headerlink" title="新生代的GC（Minor GC）："></a>新生代的GC（Minor GC）：</h2><p>新生代通常存活时间较短基于Copying算法进行回收，所谓Copying算法就是扫描出存活的对象，并复制到一块新的完全未使用的空间中，对应于新生代，就是在Eden和FromSpace或ToSpace之间copy。新生代采用空闲指针的方式来控制GC触发，指针保持最后一个分配的对象在新生代区间的位置，当有新的对象要分配内存时，用于检查空间是否足够，不够就触发GC。当连续分配对象时，对象会逐渐从Eden到Survivor，最后到老年代。</p><p>在执行机制上JVM提供了串行GC(SerialGC)、并行回收GC(ParallelScavenge)和并行GC(ParNew)：</p><p>串行GC</p><p>在整个扫描和复制过程采用单线程的方式来进行，适用于单CPU、新生代空间较小及对暂停时间要求不是非常高的应用上，是client级别默认的GC方式，可以通过-XX:+UseSerialGC来强制指定。</p><p>并行回收GC</p><p>在整个扫描和复制过程采用多线程的方式来进行，适用于多CPU、对暂停时间要求较短的应用上，是server级别默认采用的GC方式，可用-XX:+UseParallelGC来强制指定，用-XX:ParallelGCThreads=4来指定线程数。</p><p>并行GC</p><p>与老年代的并发GC配合使用。</p><h2 id="老年代的GC（Major-GC-Full-GC）："><a href="#老年代的GC（Major-GC-Full-GC）：" class="headerlink" title="老年代的GC（Major GC/Full GC）："></a>老年代的GC（Major GC/Full GC）：</h2><p>老年代与新生代不同，老年代对象存活的时间比较长、比较稳定，因此采用标记(Mark)算法来进行回收，所谓标记就是扫描出存活的对象，然后再进行回收未被标记的对象，回收后对用空出的空间要么进行合并、要么标记出来便于下次进行分配，总之目的就是要减少内存碎片带来的效率损耗。</p><p>在执行机制上JVM提供了串行GC(Serial MSC)、并行GC(Parallel MSC)和并发GC(CMS)。</p><p>串行GC（Serial MSC）</p><p>client模式下的默认GC方式，可通过-XX:+UseSerialGC强制指定。每次进行全部回收，进行Compact，非常耗费时间。</p><p>并行GC（Parallel MSC）(吞吐量大，但是GC的时候响应很慢)</p><p>server模式下的默认GC方式，也可用-XX:+UseParallelGC=强制指定。可以在选项后加等号来制定并行的线程数。</p><p>并发GC（CMS）(响应比并行gc快很多，但是牺牲了一定的吞吐量)</p><p>使用CMS是为了减少GC执行时的停顿时间，垃圾回收线程和应用线程同时执行，可以使用-XX:+UseConcMarkSweepGC=指定使用，后边接等号指定并发线程数。CMS每次回收只停顿很短的时间，分别在开始的时候（Initial Marking），和中间（Final Marking）的时候，第二次时间略长。CMS一个比较大的问题是碎片和浮动垃圾问题（Floating Gabage）。碎片是由于CMS默认不对内存进行Compact所致，可以通过-XX:+UseCMSCompactAtFullCollection。</p><p>虚拟机给每个对象定义了一个对象年龄（Age）计数器。如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor区，并将对象年龄设为 1。对象在Survivor区中每熬过一次Minor GC，年龄就增加1，当它的年龄增加到一定程度（默认为15）时，就会被晋升到老年代中。对象晋升老年代的年龄阈值，可以通过参数 -XX:MaxTenuringThreshold 来设置。</p><p>GC判断对象是否”存活”或”死去”（GC回收的对象）：</p><p>1.引用计数器算法</p><p>给对象中添加一个引用计数器，每当有一个地方引用它时，计数器的值加1；当引用失效时，计数器的值减；当该对象的计数器的值为0时，标志该对象失效。</p><p>2.跟搜索算法</p><p>基本思路：通过一系列的名为“GCRoots”的对象作为起始点，从这些节点开始向下搜索，搜索过的路径称为引用链，当一个对象到GCRoots没有任何引用链相连（用图论的话来说就是从GC Roots到这个对象不可达）时，则证明对象是不可用的。</p><p>附JVM GC组合方式：</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;术语&quot;&gt;&lt;a href=&quot;#术语&quot; class=&quot;headerlink&quot; title=&quot;术语&quot;&gt;&lt;/a&gt;术语&lt;/h1&gt;&lt;p&gt;GC：垃圾收集器&lt;/p&gt;
&lt;p&gt;Minor GC：新生代GC，指发生在新生代的垃圾收集动作，所有的Minor GC都会触发全世界的暂停（st
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>MySQL的热备份和冷备份</title>
    <link href="http://nizouba.com/2018/07/16/MySQL%E7%9A%84%E7%83%AD%E5%A4%87%E4%BB%BD%E5%92%8C%E5%86%B7%E5%A4%87%E4%BB%BD/"/>
    <id>http://nizouba.com/2018/07/16/MySQL的热备份和冷备份/</id>
    <published>2018-07-16T03:48:25.000Z</published>
    <updated>2018-07-16T03:51:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="冷备份"><a href="#冷备份" class="headerlink" title="冷备份"></a>冷备份</h1><p>冷备份（OFF， 慢， 时间点上恢复）<br>冷备份发生在数据库已经正常关闭的情况下，当正常关闭时会提供给我们一个完整的数据库。冷备份是将关键性文件拷贝到另外位置的一种说法。对于备份数据库信息而言，冷备份是最快和最安全的方法。</p><p>冷备份的优点：<br>1．是非常快速的备份方法（只需拷贝文件）<br>2．容易归档（简单拷贝即可）<br>3．容易恢复到某个时间点上（只需将文件再拷贝回去）<br>4．能与归档方法相结合，作数据库“最新状态”的恢复。<br>5．低度维护，高度安全。</p><p>冷备份的缺点：<br>1．单独使用时，只能提供到“某一时间点上”的恢复。<br>2．在实施备份的全过程中，数据库必须要作备份而不能作其它工作。也就是说，在冷备份过程中，数据库必须是关闭状态。<br>3．若磁盘空间有限，只能拷贝到磁带等其它外部存储设备上，速度会很慢。<br>4．不能按表或按用户恢复。<br>值得注意的是冷备份必须在数据库关闭的情况下进行，当数据库处于打开状态时，执行数据库文件系统备份是无效的 。而且在恢复后一定要把数据库文件的属组和属主改为mysql。</p><h1 id="热备份"><a href="#热备份" class="headerlink" title="热备份"></a>热备份</h1><p>热备份 （ON，快）<br>热备份是在数据库运行的情况下，备份数据库操作的sql语句，当数据库发生问题时，可以重新执行一遍备份的sql语句。</p><p>热备份的优点：<br>1．可在表空间或数据文件级备份，备份时间短。<br>2．备份时数据库仍可使用。<br>3．可达到秒级恢复（恢复到某一时间点上）。<br>4．可对几乎所有数据库实体作恢复。<br>5．恢复是快速的，在大多数情况下在数据库仍工作时恢复。</p><p>热备份的缺点：<br>1．不能出错，否则后果严重。<br>2．若热备份不成功，所得结果不可用于时间点的恢复。<br>3．因难于维护，所以要特别仔细小心，不允许“以失败而告终”。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;冷备份&quot;&gt;&lt;a href=&quot;#冷备份&quot; class=&quot;headerlink&quot; title=&quot;冷备份&quot;&gt;&lt;/a&gt;冷备份&lt;/h1&gt;&lt;p&gt;冷备份（OFF， 慢， 时间点上恢复）&lt;br&gt;冷备份发生在数据库已经正常关闭的情况下，当正常关闭时会提供给我们一个完整的数据库。冷备
      
    
    </summary>
    
      <category term="MySQL" scheme="http://nizouba.com/categories/MySQL/"/>
    
    
  </entry>
  
  <entry>
    <title>支付宝——开放平台第三方应用安全开发指南</title>
    <link href="http://nizouba.com/2018/07/16/%E6%94%AF%E4%BB%98%E5%AE%9D%E2%80%94%E2%80%94%E5%BC%80%E6%94%BE%E5%B9%B3%E5%8F%B0%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/"/>
    <id>http://nizouba.com/2018/07/16/支付宝——开放平台第三方应用安全开发指南/</id>
    <published>2018-07-16T02:59:28.000Z</published>
    <updated>2018-07-16T03:05:03.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="常见开发场景安全开发指南"><a href="#常见开发场景安全开发指南" class="headerlink" title="常见开发场景安全开发指南"></a>常见开发场景安全开发指南</h1><h2 id="敏感信息使用场景"><a href="#敏感信息使用场景" class="headerlink" title="敏感信息使用场景"></a>敏感信息使用场景</h2><p>敏感信息指用户的 身份证号、银行卡号、手机号 等身份信息。重要敏感信息的脱敏规范如下。</p><p>敏感信息类型    展示规范<br>身份证    显示前 1 位 + <em>(实际位数) + 后 1 位，如： 3<strong><strong><strong><em>**</em></strong></strong></strong>3<br>银行卡    显示前 6 位 + </em>(实际位数) + 后 4 位，如：622575<strong>**</strong>1496<br>手机号    显示前 3 位 + <strong><strong> + 后 2 位，如：137**</strong></strong>50</p><h2 id="敏感信息用于展示的场景"><a href="#敏感信息用于展示的场景" class="headerlink" title="敏感信息用于展示的场景"></a>敏感信息用于展示的场景</h2><p>原则：敏感信息的展示请严格按照脱敏规范进行脱敏</p><ul><li>说明：脱敏的逻辑必须在服务端完成，不能使用 Javascript 在客户端进行脱敏，包括代码注释、隐藏域、url 参数、cookies 等处的数据也必须脱敏。</li><li>说明：不能使用可逆的编码/加密方式，如 base64 编码等代替脱敏规范。</li><li>说明：若敏感信息明文展示在应用中，没有按照脱敏规范完成脱敏。支付宝开放平台将有权暂停敏感数据相关接口的开放。</li></ul><h2 id="敏感信息用于身份校验的场景"><a href="#敏感信息用于身份校验的场景" class="headerlink" title="敏感信息用于身份校验的场景"></a>敏感信息用于身份校验的场景</h2><p>原则：不要直接将敏感信息的明文信息在客户端与服务端之间传递</p><ul><li>说明：可以将敏感信息在服务端关联到用户标识 ID，在客户端保存用户标识 ID 并提交到服务端，服务端根据 ID 取出对应信息后进行校验。</li></ul><p><a href="https://blog.csdn.net/yangyang_01/article/details/79195191" target="_blank" rel="noopener">https://blog.csdn.net/yangyang_01/article/details/79195191</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;常见开发场景安全开发指南&quot;&gt;&lt;a href=&quot;#常见开发场景安全开发指南&quot; class=&quot;headerlink&quot; title=&quot;常见开发场景安全开发指南&quot;&gt;&lt;/a&gt;常见开发场景安全开发指南&lt;/h1&gt;&lt;h2 id=&quot;敏感信息使用场景&quot;&gt;&lt;a href=&quot;#敏感信息使
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>NIO之缓冲区Buffer</title>
    <link href="http://nizouba.com/2018/07/16/NIO%E4%B9%8B%E7%BC%93%E5%86%B2%E5%8C%BABuffer/"/>
    <id>http://nizouba.com/2018/07/16/NIO之缓冲区Buffer/</id>
    <published>2018-07-15T16:24:59.000Z</published>
    <updated>2018-07-15T16:36:22.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h1><h2 id="容量-Capacity"><a href="#容量-Capacity" class="headerlink" title="容量 Capacity"></a>容量 Capacity</h2><p>默认为分配大小 ，固定的</p><h2 id="上限-limit"><a href="#上限-limit" class="headerlink" title="上限 limit"></a>上限 limit</h2><p>默认为分配大小，可改变</p><h2 id="位置-Postion"><a href="#位置-Postion" class="headerlink" title="位置 Postion"></a>位置 Postion</h2><p>默认为0，可改变</p><h2 id="标记-Mark"><a href="#标记-Mark" class="headerlink" title="标记 Mark"></a>标记 Mark</h2><p>最初未定义</p><h2 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h2><p>0&lt;=mark&lt;=postion&lt;=limit&lt;=capacity</p><h1 id="API"><a href="#API" class="headerlink" title="API"></a>API</h1><h1 id="存取"><a href="#存取" class="headerlink" title="存取"></a>存取</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;属性&quot;&gt;&lt;a href=&quot;#属性&quot; class=&quot;headerlink&quot; title=&quot;属性&quot;&gt;&lt;/a&gt;属性&lt;/h1&gt;&lt;h2 id=&quot;容量-Capacity&quot;&gt;&lt;a href=&quot;#容量-Capacity&quot; class=&quot;headerlink&quot; title=&quot;容量 
      
    
    </summary>
    
    
  </entry>
  
</feed>
