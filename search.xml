<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>使用vim保存没有编辑权限的文件</title>
      <link href="/2018/08/22/%E4%BD%BF%E7%94%A8vim%E4%BF%9D%E5%AD%98%E6%B2%A1%E6%9C%89%E7%BC%96%E8%BE%91%E6%9D%83%E9%99%90%E7%9A%84%E6%96%87%E4%BB%B6/"/>
      <url>/2018/08/22/%E4%BD%BF%E7%94%A8vim%E4%BF%9D%E5%AD%98%E6%B2%A1%E6%9C%89%E7%BC%96%E8%BE%91%E6%9D%83%E9%99%90%E7%9A%84%E6%96%87%E4%BB%B6/</url>
      <content type="html"><![CDATA[<p>使用vim编辑文件非常方便，vim也是修改系统配置最常用的工具。但有时我们会顾着方便而忘了自己有没有权限编辑文件。 往往会在写完文件内容保存时才发现自己没有权限。怎么办？     将文件使用:w <newname>的方式另存为新文件，再用新文件替换就文件的虽然可行（还需要注意修改文件操作权限）,但还是麻烦了点。下面将使用一条命令保存没有权限的文件。</newname></p><p>先上命令：</p><p>:w !sudo tee % &gt; /dev/null</p><p>这里“：”表示在vim的命令行模式下。注意 w 和！之间隔着一个空格。</p><p>下面首先介绍:w  !<cmd>命令</cmd></p><p>:w !<cmd> 用于将当前缓冲区内容作为标准输入送给cmd命令。  比如 :w !sh  就是将缓冲区的每一行视为shell命令然后执行。为了便于理解，这里再介绍一个r命令。: r !<cmd>用于将<cmd>命令的执行结果读入到当前缓冲区。如:.r!date就是将当前时间写入到当前行(.)。 </cmd></cmd></cmd></p><p>接下来是tee命令</p><p>博主初学unix时，感觉ls、cp等命令很容易发现就是对应单词的缩写。但tee命令很难理解，也很少用得到。 tee是这样工作的，将前一个命名的标准输出（即输出到屏幕）作为标准输入，然后再输出到标准输出，同时保存为对应文件。将这个流程画出来，刚好就是字母T，这应该就是RMS等人将该命令命名为tee的原因。</p><p>举个例子：</p><p>ls |tee out.txt </p><p>ls 将输出当前目录列表，这个输出被管道送入tee命令，tee将该输入内容直接输出的同时，备份到out.txt文件。</p><p>最后一个是sudo，这个用过*nix的都应该知道，就是以superviser执行命令。</p><p>预备知识就这么多，接下来我们看看本文开头的那条命名是如何工作的。</p><p>首先w !sudo tee 这一部分将缓冲区内容送给tee命令。sudo 确保tee命令是以supervisor来执行的，这样就能保证有写入权限。</p><p>现在tee 已经获得了我们的文件内容，接下来就要将内容另存为其他文件了。这里我们将文件保存为它自己。 输入%以代表文件路径名（%是vim中保存当前文件路径名的专用寄存器，在命令行下会自动替换为完整路径）。 到了这里我们实际就能借助tee命令保存文件内容了，但tee命令还有标准输出，为了避免重复显示，我们将其丢到黑洞，即/dev/null。 </p><p>看完命令，我们实际执行以看效果。</p><p>执行vi /etc/hostname 。编辑之后执行:w!会弹出错误警告。这里我们使用开头的命令重新保存。 执行完命令后，vim会弹出内容已经改变的确认提示。注意这时，tee已经帮我们把文件内容写入原文件件了。 我们按O确认。然后像往常一样退出。这次我们在编辑文件时忘记了sudo，但确实成功修改了文件。 最后提醒一下，如果你不是真的想修改hostname，作完这个练习就把文件改回去吧。 </p>]]></content>
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title> Phabricator命令行工具Arcanist的基本用法</title>
      <link href="/2018/08/21/Phabricator%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7Arcanist%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/"/>
      <url>/2018/08/21/Phabricator%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7Arcanist%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>Pharicator是FB的代码审查工具，现在我所在的团队也使用它来进行代码质量的控制。其提供了一个differential(code review)命令行工具Arcanist(arc)。</p><p>1安装：<br>1.1，安装PHP5<br>Pharicator需要php5.6，然而，Ubuntu16自带的是php7，解决方法如下：</p><p><a href="https://stackoverflow.com/questions/36788873/package-php5-have-no-installation-candidate-ubuntu-16-04" target="_blank" rel="noopener">https://stackoverflow.com/questions/36788873/package-php5-have-no-installation-candidate-ubuntu-16-04</a></p><p>1.2，安装php-cli</p><p>sudo apt-get install php5-cli php5-curl php-pear</p><p>如果出现：</p><pre><code>   E: 软件包 php5-cli 没有可安装候选    E: 无法定位软件包 php5-curl</code></pre><p>如果出现上面提示 建议：</p><pre><code>    sudo add-apt-repository ppa:ondrej/php    sudo apt-get update    sudo apt-get install php5.6-curl</code></pre><p>1.3，创建phabricator软件存放目录<br>mkdir ~/phabricator</p><p>cd ~/phabricator</p><p>1.4，将Arcanist的源码拷贝到本地~/phabricator 下</p><p>~/phabricator $ git clone git://github.com/facebook/libphutil.git<br>~/phabricator $ git clone git://github.com/facebook/arcanist.git<br>1.5，将arc的路径加入到系统路径中<br>$ export PATH=$PATH:~/phabricator/arcanist/bin/<br>2 arc配置<br>2.1，arc的全局配置<br>配置arc的默认编辑器，我使用</p><p>vim $ arc set-config editor “vim” </p><p>配置默认的phabricator的uri，uri为团队的phabricator主页的url </p><p>$ arc set-config default <a href="http://phabricator.example.com" target="_blank" rel="noopener">http://phabricator.example.com</a> </p><p>2.2，在项目的根目录下建.arcconfig配置文件，文件中至少要填入以下内容<br>     {<br>        “project_id” : “your project name”,<br>         “conduit_uri” : “your phabricator url”<br>    }<br> 举个例子：</p><p><span style="font-size:12px;"> </span><span style="font-size:12px;">    </span><span style="font-size:14px;">{<br><span>        </span>“project_id” : “HelloWorld”,<br><span>        </span>“conduit_uri” : “<a href="http://phabricator.example.com&quot;" target="_blank" rel="noopener">http://phabricator.example.com&quot;</a><br><span>    </span>}</span><br>该配置文件还可以配置静态代码检测引擎(lint)和单元测试引擎。 </p><p>2.3，为项目安装证书，用于phabricator的认证。 </p><p><span style="font-size:12px;">    </span><span style="font-size:14px;">yourproject/ $ arc install-certificate</span><br>接着按照命令行提示操作就OK了。 </p><p>弄完这一步，才能真正在项目中使用arc。</p><p>3,在项目中使用arc<br>arc help [–full | [COMMAND]] 查看帮助文档，接参数–full查看所有命令的详细用法，接具体的命令[COMMAND]如arc help diff可以查看该命令的详细用法。<br>想phabricator提交review request(Differential).修改完代码后，使用arc diff <path></path>命令提交review request，该命令会产生一个包含如下内容的文件要求填写：</p><p>&lt;<enter revision="" title="">&gt;         </enter></p><p>Summary:</p><p>Test Plan:</p><p>Reviewers:</p><p>CC:</p><p>Maniphest Tasks:</p><h1 id="NEW-DIFFERENTIAL-REVISION"><a href="#NEW-DIFFERENTIAL-REVISION" class="headerlink" title="NEW DIFFERENTIAL REVISION"></a>NEW DIFFERENTIAL REVISION</h1><h1 id="Describe-the-changes-in-this-new-revision"><a href="#Describe-the-changes-in-this-new-revision" class="headerlink" title="Describe the changes in this new revision."></a>Describe the changes in this new revision.</h1><p>#</p><h1 id="arc-could-not-identify-any-existing-revision-in-your-working-copy"><a href="#arc-could-not-identify-any-existing-revision-in-your-working-copy" class="headerlink" title="arc could not identify any existing revision in your working copy."></a>arc could not identify any existing revision in your working copy.</h1><h1 id="If-you-intended-to-update-an-existing-revision-use"><a href="#If-you-intended-to-update-an-existing-revision-use" class="headerlink" title="If you intended to update an existing revision, use:"></a>If you intended to update an existing revision, use:</h1><p>#</p><h1 id="arc-diff-–update"><a href="#arc-diff-–update" class="headerlink" title="$ arc diff –update "></a>$ arc diff –update <revision></revision></h1><p>　　按照提示填写后，保存退出，arc就会自动提交request。Reviewers用逗号隔开，Maniphest Tasks填相关联的phabricator上的task_id，如T100。Test plan暂时没用过，官方文档：<a href="http://www.phabricator.com/docs/phabricator/article/Differential_User_Guide_Test_Plans.html" target="_blank" rel="noopener">http://www.phabricator.com/docs/phabricator/article/Differential_User_Guide_Test_Plans.html</a></p><p>　　提交完成后，会产生一个形如<a href="http://phabricator.example.com/D24的url，url中的D24是revision_id。" target="_blank" rel="noopener">http://phabricator.example.com/D24的url，url中的D24是revision_id。</a><br>arc diff –update &lt;revision_id&gt;更新对应的review request。该命令产生一个如下的文件，按提示填写保存退出，arc会提交更新。</p><h1 id="Updating-D27-hahahah"><a href="#Updating-D27-hahahah" class="headerlink" title="Updating D27: hahahah"></a>Updating D27: hahahah</h1><p>#</p><h1 id="Enter-a-brief-description-of-the-changes-included-in-this-update"><a href="#Enter-a-brief-description-of-the-changes-included-in-this-update" class="headerlink" title="Enter a brief description of the changes included in this update."></a>Enter a brief description of the changes included in this update.</h1><h1 id="The-first-line-is-used-as-subject-next-lines-as-comment"><a href="#The-first-line-is-used-as-subject-next-lines-as-comment" class="headerlink" title="The first line is used as subject, next lines as comment."></a>The first line is used as subject, next lines as comment.</h1><p>#</p><h1 id="If-you-intended-to-create-a-new-revision-use"><a href="#If-you-intended-to-create-a-new-revision-use" class="headerlink" title="If you intended to create a new revision, use:"></a>If you intended to create a new revision, use:</h1><h1 id="arc-diff-–create"><a href="#arc-diff-–create" class="headerlink" title="$ arc diff –create"></a>$ arc diff –create</h1><p>复制代码</p><p>arc commit –revision &lt;revision_id&gt;提交对应提交代码更改，这个命令把svn commit的工作也做掉了，直接提交到代码库。<br>arc todo <description> [option]可以快速给自己在phabricator上创建task，[option]用于把task CC给其他人.<br>arc tasks [options] 查看Maniphest的tasks。<br>arc amend –show 查看当前项目的differentials，arc amend –revision &lt;revision_id&gt; –show 查看指定revision_id的differential。</description></p><p>参考：<a href="http://udn.yyuap.com/thread-39791-1-1.html" target="_blank" rel="noopener">http://udn.yyuap.com/thread-39791-1-1.html</a></p>]]></content>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>spring cloud的客户端负载均衡</title>
      <link href="/2018/08/14/spring-cloud%E7%9A%84%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
      <url>/2018/08/14/spring-cloud%E7%9A%84%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</url>
      <content type="html"><![CDATA[]]></content>
      
      
    </entry>
    
    <entry>
      <title>ListenableFuture in Guava</title>
      <link href="/2018/08/13/%C2%83%C2%96ListenableFuture-in-Guava/"/>
      <url>/2018/08/13/%C2%83%C2%96ListenableFuture-in-Guava/</url>
      <content type="html"><![CDATA[]]></content>
      
      
        <tags>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>GoLang的Struct结构体的Tag</title>
      <link href="/2018/08/13/GoLang%E7%9A%84Struct%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84Tag/"/>
      <url>/2018/08/13/GoLang%E7%9A%84Struct%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84Tag/</url>
      <content type="html"><![CDATA[]]></content>
      
      
    </entry>
    
    <entry>
      <title>Linux Source命令</title>
      <link href="/2018/08/13/Linux-Source%E5%91%BD%E4%BB%A4/"/>
      <url>/2018/08/13/Linux-Source%E5%91%BD%E4%BB%A4/</url>
      <content type="html"><![CDATA[<p>当我修改了/etc/profile文件，我想让它立刻生效，而不用重新登录；这时就想到用source命令，如:source /etc/profile<br>对source进行了学习，并且用它与sh 执行脚本进行了对比，现在总结一下。</p><p>source命令：<br>source命令也称为“点命令”，也就是一个点符号（.）,是bash的内部命令。<br>功能：使Shell读入指定的Shell程序文件并依次执行文件中的所有语句<br>source命令通常用于重新执行刚修改的初始化文件，使之立即生效，而不必注销并重新登录。<br>用法：<br>source filename 或 . filename<br>source命令(从 C Shell 而来)是bash shell的内置命令;点命令(.)，就是个点符号(从Bourne Shell而来)是source的另一名称。</p><p>source filename 与 sh filename 及./filename执行脚本的区别在那里呢？<br>1.当shell脚本具有可执行权限时，用sh filename与./filename执行脚本是没有区别得。./filename是因为当前目录没有在PATH中，所有”.”是用来表示当前目录的。<br>2.sh filename 重新建立一个子shell，在子shell中执行脚本里面的语句，该子shell继承父shell的环境变量，但子shell新建的、改变的变量不会被带回父shell，除非使用export。<br>3.source filename：这个命令其实只是简单地读取脚本里面的语句依次在当前shell里面执行，没有建立新的子shell。那么脚本里面所有新建、改变变量的语句都会保存在当前shell里面。</p><p>举例说明：<br>1.新建一个test.sh脚本，内容为:A=1<br>2.然后使其可执行chmod +x test.sh<br>3.运行sh test.sh后，echo $A，显示为空，因为A=1并未传回给当前shell<br>4.运行./test.sh后，也是一样的效果<br>5.运行source test.sh 或者 . test.sh，然后echo $A，则会显示1，说明A=1的变量在当前shell中</p><p>原文博客：<a href="http://blog.csdn.net/wangyangkobe/article/details/6595143" target="_blank" rel="noopener">http://blog.csdn.net/wangyangkobe/article/details/6595143</a></p>]]></content>
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Linux环境设置</title>
      <link href="/2018/08/13/Linux%E7%8E%AF%E5%A2%83%E8%AE%BE%E7%BD%AE/"/>
      <url>/2018/08/13/Linux%E7%8E%AF%E5%A2%83%E8%AE%BE%E7%BD%AE/</url>
      <content type="html"><![CDATA[<p>关于取得 bash 的环境变量等数据，其实可以有系统规划与各人喜好， 一般来说，建议使用者直接修改个<br>人设定值即可，不需要更动到系统啦～ 底下我们分别来谈一谈几个有趣的设定档喔！要注意的是，在指令<br>列输入的变量也好、命令别名也罢， 都是针对该次登入的设定而已，所以只要您一注销，那么上次的设定<br>值就会不见去！ 因此，我们需要有几个档案来帮助我们，每次登入的时候，就已经帮我们搞定了环境的设<br>定啰！ </p><h1 id="系统设定值"><a href="#系统设定值" class="headerlink" title="系统设定值"></a>系统设定值</h1><p>所谓的系统设定值，也就是说每个使用者进入到 bash shell 之后，会先读取的设定档案！ 预设的设定档<br>案有下列几个： </p><p>这个档案设定了几个重要的变量，例如：『PATH、USER、MAIL、 HOSTNAME、HISTSIZE、umask』等等，也<br>同时规划出 /etc/inputrc 这个针对键盘热建设定的档案的数据内容。你可以在这里设定总体的 PATH 等<br>等的信息！ 同时，这个档案也规划出 /etc/profile.d 及 /etc/inputrc 这两个目录与档案！ </p><p>总之，你可以了解到刚刚我们学会的变量设定方式，在这个档案中也可以设定呢！ 但是设定上需要特别小<br>心，因为所有的使用者皆会使用到这个档案的信息。通常我都喜欢将 /usr/local/bin 这个路径加成最前<br>面，这是因为通常自己安装的套件自己最喜欢， 所以当然是最先搜寻啰！ ^_^！此外，请注意一下，可以<br>将 HISTSIZE 的大小改变一下，改成 50 就可以啦！比较安全！( 注：这个档案不论在那个 Linux<br>distributions 当中均存在 /etc/profile 当中，所以，请特别留意此一档案即可！ )。 </p><h1 id="个人设定值"><a href="#个人设定值" class="headerlink" title="个人设定值"></a>个人设定值</h1><h2 id="bash-profile-bash-login-profile"><a href="#bash-profile-bash-login-profile" class="headerlink" title="~/.bash_profile, ~/.bash_login, ~/.profile"></a>~/.bash_profile, ~/.bash_login, ~/.profile</h2><p>这三个档案通常只要一个就够了，一般预设是以 ~/.bash_profile 的檔名存在。 会有这么多的档案，其<br>实是因应其它 shell 转换过来的使用者的习惯而已。 这个档案可以定义个人化的路径 (PATH) 与环境变<br>量等等。不过，还是有顺位上的差异， bash 启动时，会先去读取 ~/.bash_profile，找不到时，就去读<br>取 ~/.bash_login ，然后才是 ~/.profile。 </p><h2 id="bashrc"><a href="#bashrc" class="headerlink" title="~/.bashrc"></a>~/.bashrc</h2><p>这个档案在您每次执行 shell script 的时候都会被重新使用一遍，所以是最完整的。 而<br>上头的 ~/.bash_profile 则只有在登入的时候会被读取一次。 </p><h2 id="bash-history"><a href="#bash-history" class="headerlink" title="~/.bash_history"></a>~/.bash_history</h2><p>还记得我们在历史命令提到过这个档案吧？！呵呵！没错～预设的情况下， 我们的历史命令就记录在这里<br>啊！而这个档案能够记录几笔数据，则与 HISTSIZE 这个变数有关啊。每次登入 bash 后，bash 会先读取<br>这个档案，将所有的历史指令读入内存， 因此，当我们登入 bash 后就可以查知上次使用过哪些指令啰。<br>至于更多的历史指令， 请自行回去参考喔！ </p><h2 id="bash-logout"><a href="#bash-logout" class="headerlink" title="~/.bash_logout"></a>~/.bash_logout</h2><p>这个档案则记录了『当我注销 bash 后，系统再帮我做完什么动作后才离开』的意思。 你可以去读取一下<br>这个档案的内容，预设的情况下，注销时， bash 只是帮我们清掉屏幕的讯息而已。 不过，你也可以将一<br>些备份或者是其它你认为重要的工作写在这个档案中（例如清空暂存盘）， 那么当你离开 Linux 的时候，<br>就可以解决一些烦人的事情啰！ </p><h1 id="读取顺序"><a href="#读取顺序" class="headerlink" title="读取顺序"></a>读取顺序</h1><ol><li>先读取 /etc/profile ，再根据 /etc/profile 的内容去读取其它额外的设定档， 例如<br>/etc/profile.d 与 /etc/inputrc 等等设定档；  </li><li>根据不同的使用者，到使用者家目录去读取 ~/.bash_profile 或 ~/.bash_login 或 ~/.profile<br>等设定档；  </li><li>根据不同使用者，到他家目录去读取 ~/.bashrc 。 </li></ol><h1 id="source"><a href="#source" class="headerlink" title="source"></a>source</h1><p>利用 source 或小数点 (.) 都可以将设定档的内容读进来目前的 shell 环境中！ 举例来说，我修改了<br>~/.bashrc ，那么不需要注销，立即以 source ~/.bashrc 就可以将刚刚最新设定的内容读进来目前的环<br>境中！很不错吧！此外，什么时候会使用到不同的设定档呢？ 最常发生在一个人的工作环境分为多重的时<br>候了！举个例子来说，在我的大型主机中， 我常常需要负责两到三个不同的案子，每个案子所需要处理的<br>环境变量订定并不相同， 那么我就将这两三个案子分别编写属于该案子的环境变量设定档案，当我需要该<br>环境时，就直接『 source 变量文件 』，如此一来，环境变量的设定就变的更简便而灵活了！ </p>]]></content>
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Linux /etc/profile文件详解</title>
      <link href="/2018/08/13/%C2%96Linux-etc-profile%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"/>
      <url>/2018/08/13/%C2%96Linux-etc-profile%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>linux /etc/profile文件的改变会涉及到系统的环境，也就是有关Linux环境变量的东西，学习Linux要了解Linux profile文件的相关原理，这里对则以文件进行具体分析。这里修改会对所有用户起作用。</p><p>Linux是一个多用户的操作系统。每个用户登录系统后，都会有一个专用的运行环境。通常每个用户默认的环境都是相同的，这个默认环境实际上就是一组环境变量的定义。用户可以对自己的运行环境进行定制，其方法就是修改相应的系统环境变量。</p><p>在/etc/profile文件中修改环境变量，在这里修改的内容是对所有用户起作用的。以下主要操作将在该文件中进行。</p><h2 id="如何添加环境变量。"><a href="#如何添加环境变量。" class="headerlink" title="如何添加环境变量。"></a>如何添加环境变量。</h2><p>例如添加”NAME=liheng“ 。在profile文件的最后添加如下内容export NAME=liheng，变量值liheng可以加引号也可以不加，效果一样。</p><p>在profile文件添加或修改的内容需要注销系统才能生效。</p><h2 id="重复定义变量怎样理解。"><a href="#重复定义变量怎样理解。" class="headerlink" title="重复定义变量怎样理解。"></a>重复定义变量怎样理解。</h2><p>经常出现的是对PATH变量的定义。</p><p>例如：在peofile文件默认对PATH变量都有设置PATH=￥￥￥￥￥￥￥（记不住了），在以后可能在对PATH设置，一般都加在profile 文件的最后PATH=······（打个比方）。而系统之中认定的PATH=·······￥￥￥￥￥￥￥￥￥，也就是说相同名字的环境变量，后写入的先起作用（通俗地讲）。大家一定要注意。</p><h2 id="特殊字符介绍。"><a href="#特殊字符介绍。" class="headerlink" title="特殊字符介绍。"></a>特殊字符介绍。</h2><p>例如在profile中有如下内容，通过以下内容说明特殊符号的用法。</p><p>export A=/q/jing:aaa/cc/ld</p><p>export B=.:/liheng/wang export A=/cd/cdr:$A</p><p>　　<br>: 表示并列含义，例如A变量值有多个，用：符号进行分离。</p><p>. 表示你操作的当前目录。</p><p>$ 表示该变量本次定义之前的值，</p>]]></content>
      
      <categories>
          
          <category> Linx </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Go语言学习-import</title>
      <link href="/2018/08/13/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0-import/"/>
      <url>/2018/08/13/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0-import/</url>
      <content type="html"><![CDATA[<ol><li>相对路径<br>import “./model” //当前文件同一目录的model目录，但是不建议这种方式来import</li><li>绝对路径<br>import “shorturl/model” //加载gopath/src/shorturl/model模块</li><li>点操作<br>我们有时候会看到如下的方式导入包<br>import(<br>. “fmt”<br>)<br>这个点操作的含义就是这个包导入之后在你调用这个包的函数时，你可以省略前缀的包名，也就是前面你调<br>用的fmt.Println(“hello world”)可以省略的写成Println(“hello world”)</li><li>别名操作<br>别名操作顾名思义我们可以把包命名成另一个我们用起来容易记忆的名字<br>import(<br>f “fmt”<br>)<br>别名操作的话调用包函数时前缀变成了我们的前缀，即f.Println(“hello world”)</li><li>_操作<br>这个操作经常是让很多人费解的一个操作符，请看下面这个import<br>import (<br>“database/sql”<br>_ “github.com/ziutek/mymysql/godrv”<br>)<br>_操作其实是引入该包，而不直接使用包里面的函数，而是调用了该包里面的init函数。</li></ol>]]></content>
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Ubuntu的ppa源是什么</title>
      <link href="/2018/08/13/Ubuntu%E7%9A%84ppa%E6%BA%90%E6%98%AF%E4%BB%80%E4%B9%88/"/>
      <url>/2018/08/13/Ubuntu%E7%9A%84ppa%E6%BA%90%E6%98%AF%E4%BB%80%E4%B9%88/</url>
      <content type="html"><![CDATA[]]></content>
      
      
    </entry>
    
    <entry>
      <title>Spring事务传播行为实战详解</title>
      <link href="/2018/08/12/Spring%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E8%A1%8C%E4%B8%BA%E8%AF%A6%E8%A7%A3/"/>
      <url>/2018/08/12/Spring%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E8%A1%8C%E4%B8%BA%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<h1 id="什么是事务传播行为？"><a href="#什么是事务传播行为？" class="headerlink" title="什么是事务传播行为？"></a>什么是事务传播行为？</h1><p>事务传播行为用来描述由某一个事务传播行为修饰的方法被嵌套进另一个方法的时事务如何传播。</p><pre><code>public void methodA(){    methodB();    //doSomething}@Transaction(Propagation=XXX)public void methodB(){    //doSomething}代码中methodA()方法嵌套调用了methodB()方法，methodB()的事务传播行为由@Transaction(Propagation=XXX)设置决定。这里需要注意的是methodA()并没有开启事务，外层方法的事务不是必须的。</code></pre><h1 id="Spring中七种事务传播行为"><a href="#Spring中七种事务传播行为" class="headerlink" title="Spring中七种事务传播行为"></a>Spring中七种事务传播行为</h1><h2 id="1-PROPAGATION-REQUIRED"><a href="#1-PROPAGATION-REQUIRED" class="headerlink" title="1.PROPAGATION_REQUIRED"></a>1.PROPAGATION_REQUIRED</h2><p>如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。这是最常见的选择。</p><h3 id="User1Service方法："><a href="#User1Service方法：" class="headerlink" title="User1Service方法："></a>User1Service方法：</h3><pre><code>@Servicepublic class User1ServiceImpl implements User1Service {    //省略其他...    @Override    @Transactional(propagation = Propagation.REQUIRED)    public void addRequired(User1 user){        user1Mapper.insert(user);    }}</code></pre><h3 id="User2Service方法："><a href="#User2Service方法：" class="headerlink" title="User2Service方法："></a>User2Service方法：</h3><pre><code>@Servicepublic class User2ServiceImpl implements User2Service {    //省略其他...    @Override    @Transactional(propagation = Propagation.REQUIRED)    public void addRequired(User2 user){        user2Mapper.insert(user);    }    @Override    @Transactional(propagation = Propagation.REQUIRED)    public void addRequiredException(User2 user){        user2Mapper.insert(user);        throw new RuntimeException();    }}</code></pre><h3 id="1-1-场景一"><a href="#1-1-场景一" class="headerlink" title="1.1 场景一"></a>1.1 场景一</h3><h4 id="验证方法1"><a href="#验证方法1" class="headerlink" title="验证方法1"></a>验证方法1</h4><pre><code>@Override    public void notransaction_exception_required_required(){        User1 user1=new User1();        user1.setName(&quot;张三&quot;);        user1Service.addRequired(user1);        User2 user2=new User2();        user2.setName(&quot;李四&quot;);        user2Service.addRequired(user2);        throw new RuntimeException();    }</code></pre><h4 id="验证方法2："><a href="#验证方法2：" class="headerlink" title="验证方法2："></a>验证方法2：</h4><pre><code>@Overridepublic void notransaction_required_required_exception(){    User1 user1=new User1();    user1.setName(&quot;张三&quot;);    user1Service.addRequired(user1);    User2 user2=new User2();    user2.setName(&quot;李四&quot;);    user2Service.addRequiredException(user2);}</code></pre><h4 id="分别执行验证方法，结果："><a href="#分别执行验证方法，结果：" class="headerlink" title="分别执行验证方法，结果："></a>分别执行验证方法，结果：</h4><p>1    “张三”、“李四”均插入。    外围方法未开启事务，插入“张三”、“李四”方法在自己的事务中独立运行，外围方法异常不影响内部插入“张三”、“李四”方法独立的事务。</p><p>2    “张三”插入，“李四”未插入。    外围方法没有事务，插入“张三”、“李四”方法都在自己的事务中独立运行,所以插入“李四”方法抛出异常只会回滚插入“李四”方法，插入“张三”方法不受影响。</p><h2 id="2-PROPAGATION-REQUIRES-NEW"><a href="#2-PROPAGATION-REQUIRES-NEW" class="headerlink" title="2.PROPAGATION_REQUIRES_NEW"></a>2.PROPAGATION_REQUIRES_NEW</h2><p>支持当前事务，如果当前没有事务，就以非事务方式执行。</p><p>我们为User1Service和User2Service相应方法加上Propagation.REQUIRES_NEW属性。</p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>阿里云，腾讯云，百度云，华为云，AWS，用户侧网络</title>
      <link href="/2018/08/11/%E9%98%BF%E9%87%8C%E4%BA%91%EF%BC%8C%E8%85%BE%E8%AE%AF%E4%BA%91%EF%BC%8C%E7%99%BE%E5%BA%A6%E4%BA%91%EF%BC%8C%E5%8D%8E%E4%B8%BA%E4%BA%91%EF%BC%8CAWS%EF%BC%8C%E7%94%A8%E6%88%B7%E4%BE%A7%E7%BD%91%E7%BB%9C/"/>
      <url>/2018/08/11/%E9%98%BF%E9%87%8C%E4%BA%91%EF%BC%8C%E8%85%BE%E8%AE%AF%E4%BA%91%EF%BC%8C%E7%99%BE%E5%BA%A6%E4%BA%91%EF%BC%8C%E5%8D%8E%E4%B8%BA%E4%BA%91%EF%BC%8CAWS%EF%BC%8C%E7%94%A8%E6%88%B7%E4%BE%A7%E7%BD%91%E7%BB%9C/</url>
      <content type="html"><![CDATA[]]></content>
      
      
    </entry>
    
    <entry>
      <title>go常用命令</title>
      <link href="/2018/08/10/go%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2018/08/10/go%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      <content type="html"><![CDATA[<ol><li>go get github.com/hyper-carrot/go_lib/logging</li></ol><p>可以根据要求和实际情况从互联网上下载或更新指定的代码包及其依赖包，并对它们进行编译和安装。在上面这个示例中，我们从著名的代码托管站点Github上下载了一个项目（或称代码包），并安装到了环境变量GOPATH中包含的第一个工作区中。</p><ol start="2"><li>gopm get -g -v </li></ol><p>gopm解决国内需要FQ的问题。-g是下载到gopath，-v是verbose，输出详细信息，-u是更新包。</p><ol start="3"><li><p>go install 安装在bin目录下</p></li><li><p>go build 在当前目录下生成一个exe</p></li><li>go run 直接运行</li></ol><h1 id="go结构"><a href="#go结构" class="headerlink" title="go结构"></a>go结构</h1><p>直接安装目录下带有main的文件，执行为exe</p>]]></content>
      
      <categories>
          
          <category> go </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Git HEAD detached from XXX</title>
      <link href="/2018/08/10/Git-HEAD-detached-from-XXX/"/>
      <url>/2018/08/10/Git-HEAD-detached-from-XXX/</url>
      <content type="html"><![CDATA[<h1 id="什么是-HEAD"><a href="#什么是-HEAD" class="headerlink" title="什么是 HEAD"></a>什么是 HEAD</h1><p>Git 中的 HEAD 可以理解为一个指针，我们可以在命令行中输入 cat .git/HEAD 查看当前 HEAD 指向哪儿，一般它指向当前工作目录所在分支的最新提交。</p><p>当使用 git checkout &lt; branch_name&gt; 切换分支时，HEAD 会移动到指定分支。</p><h1 id="游离状态"><a href="#游离状态" class="headerlink" title="游离状态"></a>游离状态</h1><p>但是如果使用的是 git checkout &lt; commit id&gt;，即切换到指定的某一次提交，HEAD 就会处于 detached 状态（游离状态）。</p><h1 id="HEAD-游离状态的利与弊"><a href="#HEAD-游离状态的利与弊" class="headerlink" title="HEAD 游离状态的利与弊"></a>HEAD 游离状态的利与弊</h1><h2 id="利"><a href="#利" class="headerlink" title="利"></a>利</h2><p>HEAD 处于游离状态时，我们可以很方便地在历史版本之间互相切换，比如需要回到某次提交，直接 checkout 对应的 commit id 或者 tag 名即可。</p><h1 id="弊"><a href="#弊" class="headerlink" title="弊"></a>弊</h1><p>它的弊端就是：在这个基础上的提交会新开一个匿名分支！<br>也就是说我们的提交是无法可见保存的，一旦切到别的分支，游离状态以后的提交就不可追溯了。</p><p>解决办法就是新建一个分支保存游离状态后的提交：</p><p>git checkout -b new-branch-name [start-branch|commit-id]</p><p>这个commit-id就是游离Head的指向</p>]]></content>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>cron表达式</title>
      <link href="/2018/08/08/cron%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2018/08/08/cron%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p>Cron表达式是一个字符串，字符串以5或6个空格隔开，分为6或7个域，每一个域代表一个含义，Cron有如下两种语法格式：</p><ol><li><p>Seconds Minutes Hours DayofMonth Month DayofWeek Year</p></li><li><p>Seconds Minutes Hours DayofMonth Month DayofWeek　　</p><h1 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h1></li></ol><p>corn从左到右（用空格隔开）：秒 分 小时 月份中的日期 月份 星期中的日期 年份</p><h1 id="各字段的含义"><a href="#各字段的含义" class="headerlink" title="各字段的含义"></a>各字段的含义</h1><p>字段    允许值    允许的特殊字符</p><ul><li>秒（Seconds）    0~59的整数    , - * /    四个字符</li><li>分（Minutes）    0~59的整数    , - * /    四个字符</li><li>小时（Hours）    0~23的整数    , - * /    四个字符</li><li>日期（DayofMonth）    1~31的整数（但是你需要考虑你月的天数）    ,- * ? / L W C     八个字符</li><li>月份（Month）    1~12的整数或者 JAN-DEC    , - * /    四个字符</li><li>星期（DayofWeek）    1~7的整数或者 SUN-SAT （1=SUN）    , - * ? / L C #     八个字符</li><li>年(可选，留空)（Year）    1970~2099    , - * /    四个字符</li></ul><h1 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h1><p>每一个域都使用数字，但还可以出现如下特殊字符，它们的含义是：</p><ol><li><p><em>：表示匹配该域的任意值。假如在Minutes域使用</em>, 即表示每分钟都会触发事件。</p></li><li><p>?：只能用在DayofMonth和DayofWeek两个域。它也匹配域的任意值，但实际不会。因为DayofMonth和DayofWeek会相互影响。例如想在每月的20日触发调度，不管20日到底是星期几，则只能使用如下写法： 13 13 15 20 <em> ?, 其中最后一位只能用？，而不能使用</em>，如果使用*表示不管星期几都会触发，实际上并不是这样。</p></li><li><p>-：表示范围。例如在Minutes域使用5-20，表示从5分到20分钟每分钟触发一次 </p></li><li><p>/：表示起始时间开始触发，然后每隔固定时间触发一次。例如在Minutes域使用5/20,则意味着5分钟触发一次，而25，45等分别触发一次. </p></li><li><p>,：表示列出枚举值。例如：在Minutes域使用5,20，则意味着在5和20分每分钟触发一次。 </p></li><li><p>L：表示最后，只能出现在DayofWeek和DayofMonth域。如果在DayofWeek域使用5L,意味着在最后的一个星期四触发。 </p></li><li><p>W:表示有效工作日(周一到周五),只能出现在DayofMonth域，系统将在离指定日期的最近的有效工作日触发事件。例如：在 DayofMonth使用5W，如果5日是星期六，则将在最近的工作日：星期五，即4日触发。如果5日是星期天，则在6日(周一)触发；如果5日在星期一到星期五中的一天，则就在5日触发。另外一点，W的最近寻找不会跨过月份 。</p></li><li><p>LW:这两个字符可以连用，表示在某个月最后一个工作日，即最后一个星期五。 （todo：保留意见，最后一个工作日不一定是星期五）</p></li><li><p>#:用于确定每个月第几个星期几，只能出现在DayofMonth域。例如在4#2，表示某月的第二个星期三。</p></li></ol><h1 id="常用表达式例子"><a href="#常用表达式例子" class="headerlink" title="常用表达式例子"></a>常用表达式例子</h1><ul><li><p>0 0 2 1 <em> ? </em>   表示在每月的1日的凌晨2点执行任务</p></li><li><p>0 15 10 ? * MON-FRI   表示周一到周五每天上午10:15执行作业</p></li><li><p>0 15 10 ? 6L 2002-2006   表示2002-2006年的每个月的最后一个星期五上午10:15执行作</p></li><li><p>0 0 10,14,16 <em> </em> ?   每天上午10点，下午2点，4点 </p></li><li></li><li>0 0/30 9-17 <em> </em> ?   朝九晚五工作时间内每半小时 </li><li></li><li>0 0 12 ? * WED    表示每个星期三中午12点 </li><li></li><li>0 0 12 <em> </em> ?   每天中午12点触发 </li><li></li><li>0 15 10 ? <em> </em>    每天上午10:15触发 </li><li></li><li><p>0 15 10 <em> </em> ?     每天上午10:15触发 </p></li><li><p>0 15 10 <em> </em> ? *    每天上午10:15触发 </p></li><li></li><li>0 15 10 <em> </em> ? 2005    2005年的每天上午10:15触发 </li><li></li><li>0 <em> 14 </em> * ?     在每天下午2点到下午2:59期间的每1分钟触发 </li><li></li><li>0 0/5 14 <em> </em> ?    在每天下午2点到下午2:55期间的每5分钟触发 </li><li></li><li>0 0/5 14,18 <em> </em> ?     在每天下午2点到2:55期间和下午6点到6:55期间的每5分钟触发 </li><li></li><li>0 0-5 14 <em> </em> ?    在每天下午2点到下午2:05期间的每1分钟触发 </li><li></li><li>0 10,44 14 ? 3 WED    每年三月的星期三的下午2:10和2:44触发 </li><li></li><li>0 15 10 ? * MON-FRI    周一至周五的上午10:15触发 </li><li></li><li>0 15 10 15 * ?    每月15日上午10:15触发 </li><li></li><li>0 15 10 L * ?    每月最后一日的上午10:15触发 </li><li></li><li>0 15 10 ? * 6L    每月的最后一个星期五上午10:15触发 </li><li></li><li>0 15 10 ? * 6L 2002-2005   2002年至2005年的每月的最后一个星期五上午10:15触发 </li><li></li><li>0 15 10 ? * 6#3   每月的第三个星期五上午10:15触发　　</li></ul><p>#注意</p><p>   有些子表达式能包含一些范围或列表</p><p>　　例如：子表达式（天（星期））可以为 “MON-FRI”，“MON，WED，FRI”，“MON-WED,SAT”</p><p>“*”字符代表所有可能的值</p><p>　　因此，“<em>”在子表达式（月）里表示每个月的含义，“</em>”在子表达式（天（星期））表示星期的每一天</p><p>　　“/”字符用来指定数值的增量<br>　　例如：在子表达式（分钟）里的“0/15”表示从第0分钟开始，每15分钟<br>在子表达式（分钟）里的“3/20”表示从第3分钟开始，每20分钟（它和“3，23，43”）的含义一样</p><p>　　“？”字符仅被用于天（月）和天（星期）两个子表达式，表示不指定值<br>　　当2个子表达式其中之一被指定了值以后，为了避免冲突，需要将另一个子表达式的值设为“？”</p><p>　　“L” 字符仅被用于天（月）和天（星期）两个子表达式，它是单词“last”的缩写<br>　　但是它在两个子表达式里的含义是不同的。<br>　　在天（月）子表达式中，“L”表示一个月的最后一天<br>　　在天（星期）自表达式中，“L”表示一个星期的最后一天，也就是SAT</p><p>　　如果在“L”前有具体的内容，它就具有其他的含义了</p><p>　　例如：“6L”表示这个月的倒数第６天，“FRIL”表示这个月的最一个星期五<br>　　注意：在使用“L”参数时，不要指定列表或范围，因为这会导致问题</p>]]></content>
      
      
        <tags>
            
            <tag> 定时任务 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>MySQL中的函数</title>
      <link href="/2018/08/05/MySQL%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0/"/>
      <url>/2018/08/05/MySQL%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0/</url>
      <content type="html"><![CDATA[<p>谨慎使用，仅作学习之用</p><h1 id="group-concat"><a href="#group-concat" class="headerlink" title="group_concat"></a>group_concat</h1><p>GROUP_CONCAT函数返回一个字符串结果，该结果由分组中的字段连接组合而成。常和groupby连用</p><h1 id="concat"><a href="#concat" class="headerlink" title="concat"></a>concat</h1><p>CONCAT（）函数用于将多个字段连接成一个字段。</p>]]></content>
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>MySQL中的数据类型</title>
      <link href="/2018/08/05/MySQL%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/2018/08/05/MySQL%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      <content type="html"><![CDATA[]]></content>
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>堆相关</title>
      <link href="/2018/08/05/%E5%A0%86%E7%9B%B8%E5%85%B3/"/>
      <url>/2018/08/05/%E5%A0%86%E7%9B%B8%E5%85%B3/</url>
      <content type="html"><![CDATA[<h1 id="二叉堆"><a href="#二叉堆" class="headerlink" title="二叉堆"></a>二叉堆</h1><p>子节点比父节点小，左右大小不考虑</p><p>是一颗完全二叉树    </p><p>叫做最大堆</p><p>因为是完全二叉树，用数组存储最好</p>]]></content>
      
      
        <tags>
            
            <tag> 堆 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>upload</title>
      <link href="/2018/08/05/upload/"/>
      <url>/2018/08/05/upload/</url>
      <content type="html"><![CDATA[]]></content>
      
      
    </entry>
    
    <entry>
      <title>docker创建自己的javaweb镜像</title>
      <link href="/2018/08/05/docker%E5%88%9B%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84javaweb%E9%95%9C%E5%83%8F/"/>
      <url>/2018/08/05/docker%E5%88%9B%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84javaweb%E9%95%9C%E5%83%8F/</url>
      <content type="html"><![CDATA[<p>tomcat的webapp目录，也可以docker inspect查看</p><p>from tomcat<br>maintainer zwx<br>copy shop.war tomcat的webapp目录</p>]]></content>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>docker-compose</title>
      <link href="/2018/08/05/docker-compose/"/>
      <url>/2018/08/05/docker-compose/</url>
      <content type="html"><![CDATA[<h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><h2 id="version"><a href="#version" class="headerlink" title="version"></a>version</h2><h2 id="networks"><a href="#networks" class="headerlink" title="networks"></a>networks</h2><p>声明一个网络，比如ghost</p><h1 id="services"><a href="#services" class="headerlink" title="services"></a>services</h1><h2 id="服务名"><a href="#服务名" class="headerlink" title="服务名"></a>服务名</h2><h3 id="build-去那个目录去构建，那个目录下要有Dockerfile文件"><a href="#build-去那个目录去构建，那个目录下要有Dockerfile文件" class="headerlink" title="build 去那个目录去构建，那个目录下要有Dockerfile文件"></a>build 去那个目录去构建，那个目录下要有Dockerfile文件</h3><h3 id="networks-放到哪个网络-，比如ghost网络"><a href="#networks-放到哪个网络-，比如ghost网络" class="headerlink" title="networks 放到哪个网络 ，比如ghost网络"></a>networks 放到哪个网络 ，比如ghost网络</h3><h3 id="depneds-on-依赖其他的服务"><a href="#depneds-on-依赖其他的服务" class="headerlink" title="depneds_on 依赖其他的服务"></a>depneds_on 依赖其他的服务</h3><h3 id="ports-暴露端口，映射，比如-6379-6379"><a href="#ports-暴露端口，映射，比如-6379-6379" class="headerlink" title="ports 暴露端口，映射，比如 6379:6379"></a>ports 暴露端口，映射，比如 6379:6379</h3><h2 id="服务2"><a href="#服务2" class="headerlink" title="服务2"></a>服务2</h2><h1 id="db-因为前面depends-on-依赖这个名称了"><a href="#db-因为前面depends-on-依赖这个名称了" class="headerlink" title="db 因为前面depends_on 依赖这个名称了"></a>db 因为前面depends_on 依赖这个名称了</h1><h2 id="image-–-docker-pull下来"><a href="#image-–-docker-pull下来" class="headerlink" title="image – docker pull下来"></a>image – docker pull下来</h2><h2 id="network-网络还是ghost"><a href="#network-网络还是ghost" class="headerlink" title="network 网络还是ghost"></a>network 网络还是ghost</h2><h2 id="enviroments-环境变量定义"><a href="#enviroments-环境变量定义" class="headerlink" title="enviroments 环境变量定义"></a>enviroments 环境变量定义</h2><h2 id="volumes-创建的数据库路径挂载上去。不会随着容器的消息而消息。-PWD表示当前执行的本地目录"><a href="#volumes-创建的数据库路径挂载上去。不会随着容器的消息而消息。-PWD表示当前执行的本地目录" class="headerlink" title="volumes 创建的数据库路径挂载上去。不会随着容器的消息而消息。$PWD表示当前执行的本地目录"></a>volumes 创建的数据库路径挂载上去。不会随着容器的消息而消息。$PWD表示当前执行的本地目录</h2><h1 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h1><ul><li>docker-compose up -d d表示以dameon方式启动</li><li>docker-compose stop 停掉</li><li>docker-compose rm 把停掉的容器都给删除掉</li><li>docker-compse build 重新构建用build</li><li>ps</li><li>logs</li></ul>]]></content>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>arc使用方法</title>
      <link href="/2018/08/01/arc%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"/>
      <url>/2018/08/01/arc%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<ol><li>arc diff origin/dev-2.7</li><li>arc land –onto dev-2.7 –keep-branch -revision D31</li></ol>]]></content>
      
      
    </entry>
    
    <entry>
      <title>nio之socket通道</title>
      <link href="/2018/07/28/nio%E4%B9%8Bsocket%E9%80%9A%E9%81%93/"/>
      <url>/2018/07/28/nio%E4%B9%8Bsocket%E9%80%9A%E9%81%93/</url>
      <content type="html"><![CDATA[<p>新的 socket 通道类可以运行非阻塞模式并且是可选择的。这两个性能可以激活程序（如网络<br>服务器和中间件组件）巨大的可伸缩性和灵活性。本节中我们会看到，再也没有为每个 socket 连接使用一个线程的必要了，也避免了管理大量线程所需的上下文交换总开销。借助新的 NIO 类，一个或几个线程就可以管理成百上千的活动 socket 连接了并且只有很少甚至可能没有性能损失。</p><p>DatagramChannel、SocketChannel 和ServerSocketChannel）都是继承 java.nio.channels.spi 包中的 AbstractSelectableChannel</p><p>请注意 DatagramChannel 和 SocketChannel 实现定义读和写功能的接口而 ServerSocketChannel<br>不实现。ServerSocketChannel 负责监听传入的连接和创建新的 SocketChannel 对象，它本身从不传<br>输数据。 </p><p>全部 socket 通道类（DatagramChannel、SocketChannel 和 ServerSocketChannel）在被实例化时<br>都会创建一个对等 socket 对象。这些是我们所熟悉的来自 java.net 的类（Socket、ServerSocket<br>和 DatagramSocket），它们已经被更新以识别通道。对等 socket 可以通过调用 socket( )方法从一个<br>通道上获取。此外，这三个 java.net 类现在都有 getChannel( )方法。</p><p>如果您用传统方式（直接实例化）创建了一个<br>Socket 对象，它就不会有关联的 SocketChannel 并且它的 getChannel( )方法将总是返回 null。 </p><h1 id="非阻塞模式"><a href="#非阻塞模式" class="headerlink" title="非阻塞模式"></a>非阻塞模式</h1><p>要把一个 socket 通道置于非阻塞模式，我们要依靠所有 socket 通道类的公有超级类：<br>SelectableChannel。</p><h1 id="ServerSocketChannel"><a href="#ServerSocketChannel" class="headerlink" title="ServerSocketChannel"></a>ServerSocketChannel</h1>]]></content>
      
      
        <tags>
            
            <tag> NIO </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>nio之选择器</title>
      <link href="/2018/07/28/nio%E4%B9%8B%E9%80%89%E6%8B%A9%E5%99%A8/"/>
      <url>/2018/07/28/nio%E4%B9%8B%E9%80%89%E6%8B%A9%E5%99%A8/</url>
      <content type="html"><![CDATA[<p>您需要将之前创建的一个或多个可选择的通道注册到<br>选择器对象(Selector)中。一个表示通道和选择器的键将会被返回。选择键(SelectionKey)会记住您关心的通道。它们也会追<br>踪对应的通道是否已经就绪。当您调用一个选择器对象的 select( )方法时，相关的键建会被更新，<br>用来检查所有被注册到该选择器的通道(SelectableChannel)。您可以获取一个键的集合，从而找到当时已经就绪的通<br>道。通过遍历这些键，您可以选择出每个从上次您调用 select( )开始直到现在，已经就绪的通道。</p><h1 id="选择器基础"><a href="#选择器基础" class="headerlink" title="选择器基础"></a>选择器基础</h1><h2 id="选择器-Selector"><a href="#选择器-Selector" class="headerlink" title="选择器(Selector)"></a>选择器(Selector)</h2><p>选择器类管理着一个被注册的通道集合的信息和它们的就绪状态。通道是和选择器一起被注册<br>的，并且使用选择器来更新通道的就绪状态。当这么做的时候，可以选择将被激发的线程挂起，直<br>到有就绪的的通道。 </p><h2 id="可选择通道-SelectableChannel"><a href="#可选择通道-SelectableChannel" class="headerlink" title="可选择通道(SelectableChannel)"></a>可选择通道(SelectableChannel)</h2><p>这个抽象类提供了实现通道的可选择性所需要的公共方法。它是所有支持就绪检查的通道类的<br>父类。FileChannel 对象不是可选择的，因为它们没有继承 SelectableChannel(见图  4-2)。<br>所有 socket 通道都是可选择的，包括从管道(Pipe)对 象的中获得的通道。SelectableChannel 可以被注册到 Selector 对象上，同时可以指定对<br>那个选择器而言，那种操作是感兴趣的。一个通道可以被注册到多个选择器上，但对每个选择器而<br>言只能被注册一次。 </p><h2 id="选择键-SelectionKey"><a href="#选择键-SelectionKey" class="headerlink" title="选择键(SelectionKey)"></a>选择键(SelectionKey)</h2><p>选 择 键 封 装 了 特 定 的 通 道 与 特 定 的 选 择 器 的 注 册 关 系 。 选 择 键 对 象 被<br>SelectableChannel.register( ) 返回并提供一个表示这种注册关系的标记。选择键包含了<br>两个比特集（以整数的形式进行编码），指示了该注册关系所关心的通道操作，以及通道已经准备<br>好的操作。 </p><h2 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h2><p>一个通道可以注册到多个选择器，一个选择器可以关联多个通道。</p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>idea使用技巧</title>
      <link href="/2018/07/28/idea%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
      <url>/2018/07/28/idea%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</url>
      <content type="html"><![CDATA[<ol><li>导入别人的项目，现在一个项目下看全部，package不对，批量replace掉全部package，再analyse-insepct code-probable bugs-wrong package statment-修复全部，自动按照目录进行修复</li></ol>]]></content>
      
      
    </entry>
    
    <entry>
      <title>Linux命令之sed</title>
      <link href="/2018/07/26/Linux%E5%91%BD%E4%BB%A4%E4%B9%8Bsed/"/>
      <url>/2018/07/26/Linux%E5%91%BD%E4%BB%A4%E4%B9%8Bsed/</url>
      <content type="html"><![CDATA[<h1 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h1><ul><li>-n 经过sed处理那一行才会被列出来</li><li>-</li></ul><h1 id="范例"><a href="#范例" class="headerlink" title="范例"></a>范例</h1><ul><li></li></ul>]]></content>
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>git的ignore</title>
      <link href="/2018/07/26/git%E7%9A%84ignore/"/>
      <url>/2018/07/26/git%E7%9A%84ignore/</url>
      <content type="html"><![CDATA[<ul><li>所有空行或者以注释符号 ＃ 开头的行都会被 Git 忽略。</li><li>可以使用标准的 glob 模式匹配。</li><li>匹配模式最后跟反斜杠（/）说明要忽略的是目录。（如果不加/是忽略目录和文件，windows不能创建同名文件夹和文件）<br>• 要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（!）取反。<br>所谓的 glob 模式是指 shell 所使用的简化了的正则表达式。星号（*）匹配零个或多个任意字符；[abc] 匹配<br>任何一个列在方括号中的字符（这个例子要么匹配一个 a，要么匹配一个 b，要么匹配一个 c）；问号（?）<br>只匹配一个任意字符；如果在方括号中使用短划线分隔两个字符，表示所有在这两个字符范围内的都可以匹配<br>（比如 [0-9] 表示匹配所有 0 到 9 的数字）。<br>我们再看一个 .gitignore 文件的例子：<h1 id="此为注释-–-将被-Git-忽略"><a href="#此为注释-–-将被-Git-忽略" class="headerlink" title="此为注释 – 将被 Git 忽略"></a>此为注释 – 将被 Git 忽略</h1>  <em>.a # 忽略所有 .a 结尾的文件<br>  !lib.a # 但 lib.a 除外<br>  /TODO # 仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODO<br>  build/ # 忽略 build/ 目录下的所有文件<br>  doc/</em>.txt # 会忽略 doc/notes.txt 但不包括 doc/server/arch.txt</li></ul><h1 id="本地忽略"><a href="#本地忽略" class="headerlink" title="本地忽略"></a>本地忽略</h1><p>编辑.git/info/exclude，规则和.gitignore一样<br>比如你本地加个拦截器打印mybatis的sql带参数语句，不希望上传上去，也不希望污染.gitignore,就可以这样做。</p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>Git 分支 - 分支的新建与合并</title>
      <link href="/2018/07/26/Git-%E5%88%86%E6%94%AF-%E5%88%86%E6%94%AF%E7%9A%84%E6%96%B0%E5%BB%BA%E4%B8%8E%E5%90%88%E5%B9%B6/"/>
      <url>/2018/07/26/Git-%E5%88%86%E6%94%AF-%E5%88%86%E6%94%AF%E7%9A%84%E6%96%B0%E5%BB%BA%E4%B8%8E%E5%90%88%E5%B9%B6/</url>
      <content type="html"><![CDATA[<p>现在让我们来看一个简单的分支与合并的例子，实际工作中大体也会用到这样的工作流程：</p><ol><li>开发某个网站。</li><li>为实现某个新的需求，创建一个分支。</li><li>在这个分支上开展工作。</li></ol><p>假设此时，你突然接到一个电话说有个很严重的问题需要紧急修补，那么可以按照下面的方式处理：</p><ol><li>返回到原先已经发布到生产服务器上的分支。</li><li>为这次紧急修补建立一个新分支，并在其中修复问题。</li><li>通过测试后，回到生产服务器所在的分支，将修补分支合并进来，然后再推送到生产服务器上。</li><li>切换到之前实现新需求的分支，继续工作。</li></ol><p>分支的新建与切换<br>首先，我们假设你正在项目中愉快地工作，并且已经提交了几次更新（见图 3-10）。</p><p>图 3-10. 一个简短的提交历史<br>现在，你决定要修补问题追踪系统上的 #53 问题。顺带说明下，Git 并不同任何特定的问题追踪系统打交道。这里为了说明要解决的问题，才把新建的分支取名为 iss53。要新建并切换到该分支，运行 git checkout 并加上 -b 参数：</p><p>$ git checkout -b iss53<br>Switched to a new branch ‘iss53’<br>这相当于执行下面这两条命令：</p><p>$ git branch iss53<br>$ git checkout iss53<br>图 3-11 示意该命令的执行结果。</p><p>图 3-11. 创建了一个新分支的指针<br>接着你开始尝试修复问题，在提交了若干次更新后，iss53 分支的指针也会随着向前推进，因为它就是当前分支（换句话说，当前的 HEAD 指针正指向 iss53，见图 3-12）：</p><p>$ vim index.html<br>$ git commit -a -m ‘added a new footer [issue 53]’</p><p>图 3-12. iss53 分支随工作进展向前推进<br>现在你就接到了那个网站问题的紧急电话，需要马上修补。有了 Git ，我们就不需要同时发布这个补丁和 iss53 里作出的修改，也不需要在创建和发布该补丁到服务器之前花费大力气来复原这些修改。唯一需要的仅仅是切换回 master 分支。</p><p>不过在此之前，留心你的暂存区或者工作目录里，那些还没有提交的修改，它会和你即将检出的分支产生冲突从而阻止 Git 为你切换分支。切换分支的时候最好保持一个清洁的工作区域。稍后会介绍几个绕过这种问题的办法（分别叫做 stashing 和 commit amending）。目前已经提交了所有的修改，所以接下来可以正常转换到 master 分支：</p><p>$ git checkout master<br>Switched to branch ‘master’<br>此时工作目录中的内容和你在解决问题 #53 之前一模一样，你可以集中精力进行紧急修补。这一点值得牢记：Git 会把工作目录的内容恢复为检出某分支时它所指向的那个提交对象的快照。它会自动添加、删除和修改文件以确保目录的内容和你当时提交时完全一样。</p><p>接下来，你得进行紧急修补。我们创建一个紧急修补分支 hotfix 来开展工作，直到搞定（见图 3-13）：</p><p>$ git checkout -b hotfix<br>Switched to a new branch ‘hotfix’<br>$ vim index.html<br>$ git commit -a -m ‘fixed the broken email address’<br>[hotfix 3a0874c] fixed the broken email address<br> 1 files changed, 1 deletion(-)</p><p>图 3-13. hotfix 分支是从 master 分支所在点分化出来的<br>有必要作些测试，确保修补是成功的，然后回到 master 分支并把它合并进来，然后发布到生产服务器。用 git merge 命令来进行合并：</p><p>$ git checkout master<br>$ git merge hotfix<br>Updating f42c576..3a0874c<br>Fast-forward<br> README | 1 -<br> 1 file changed, 1 deletion(-)<br>请注意，合并时出现了“Fast forward”的提示。由于当前 master 分支所在的提交对象是要并入的 hotfix 分支的直接上游，Git 只需把 master 分支指针直接右移。换句话说，如果顺着一个分支走下去可以到达另一个分支的话，那么 Git 在合并两者时，只会简单地把指针右移，因为这种单线的历史分支不存在任何需要解决的分歧，所以这种合并过程可以称为快进（Fast forward）。</p><p>现在最新的修改已经在当前 master 分支所指向的提交对象中了，可以部署到生产服务器上去了（见图 3-14）。</p><p>图 3-14. 合并之后，master 分支和 hotfix 分支指向同一位置。<br>在那个超级重要的修补发布以后，你想要回到被打扰之前的工作。由于当前 hotfix 分支和 master 都指向相同的提交对象，所以 hotfix 已经完成了历史使命，可以删掉了。使用 git branch 的 -d 选项执行删除操作：</p><p>$ git branch -d hotfix<br>Deleted branch hotfix (was 3a0874c).<br>现在回到之前未完成的 #53 问题修复分支上继续工作（图 3-15）：</p><p>$ git checkout iss53<br>Switched to branch ‘iss53’<br>$ vim index.html<br>$ git commit -a -m ‘finished the new footer [issue 53]’<br>[iss53 ad82d7a] finished the new footer [issue 53]<br> 1 file changed, 1 insertion(+)</p><p>图 3-15. iss53 分支可以不受影响继续推进。<br>值得注意的是之前 hotfix 分支的修改内容尚未包含到 iss53 中来。如果需要纳入此次修补，可以用 git merge master 把 master 分支合并到 iss53；或者等 iss53 完成之后，再将 iss53 分支中的更新并入 master。</p><p>分支的合并<br>在问题 #53 相关的工作完成之后，可以合并回 master 分支。实际操作同前面合并 hotfix 分支差不多，只需回到 master 分支，运行 git merge 命令指定要合并进来的分支：</p><p>$ git checkout master<br>$ git merge iss53<br>Auto-merging README<br>Merge made by the ‘recursive’ strategy.<br> README | 1 +<br> 1 file changed, 1 insertion(+)<br>请注意，这次合并操作的底层实现，并不同于之前 hotfix 的并入方式。因为这次你的开发历史是从更早的地方开始分叉的。由于当前 master 分支所指向的提交对象（C4）并不是 iss53 分支的直接祖先，Git 不得不进行一些额外处理。就此例而言，Git 会用两个分支的末端（C4 和 C5）以及它们的共同祖先（C2）进行一次简单的三方合并计算。图 3-16 用红框标出了 Git 用于合并的三个提交对象：</p><p>图 3-16. Git 为分支合并自动识别出最佳的同源合并点。<br>这次，Git 没有简单地把分支指针右移，而是对三方合并后的结果重新做一个新的快照，并自动创建一个指向它的提交对象（C6）（见图 3-17）。这个提交对象比较特殊，它有两个祖先（C4 和 C5）。</p><p>值得一提的是 Git 可以自己裁决哪个共同祖先才是最佳合并基础；这和 CVS 或 Subversion（1.5 以后的版本）不同，它们需要开发者手工指定合并基础。所以此特性让 Git 的合并操作比其他系统都要简单不少。</p><p>图 3-17. Git 自动创建了一个包含了合并结果的提交对象。<br>既然之前的工作成果已经合并到 master 了，那么 iss53 也就没用了。你可以就此删除它，并在问题追踪系统里关闭该问题。</p><p>$ git branch -d iss53<br>遇到冲突时的分支合并<br>有时候合并操作并不会如此顺利。如果在不同的分支中都修改了同一个文件的同一部分，Git 就无法干净地把两者合到一起（译注：逻辑上说，这种问题只能由人来裁决。）。如果你在解决问题 #53 的过程中修改了 hotfix 中修改的部分，将得到类似下面的结果：</p><p>$ git merge iss53<br>Auto-merging index.html<br>CONFLICT (content): Merge conflict in index.html<br>Automatic merge failed; fix conflicts and then commit the result.<br>Git 作了合并，但没有提交，它会停下来等你解决冲突。要看看哪些文件在合并时发生冲突，可以用 git status 查阅：</p><p>$ git status<br>On branch master<br>You have unmerged paths.<br>  (fix conflicts and run “git commit”)</p><p>Unmerged paths:<br>  (use “git add <file>…” to mark resolution)</file></p><pre><code>    both modified:      index.html</code></pre><p>no changes added to commit (use “git add” and/or “git commit -a”)<br>任何包含未解决冲突的文件都会以未合并（unmerged）的状态列出。Git 会在有冲突的文件里加入标准的冲突解决标记，可以通过它们来手工定位并解决这些冲突。可以看到此文件包含类似下面这样的部分：</p><p>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</p><h1 id="contact-email-support-github-com"><a href="#contact-email-support-github-com" class="headerlink" title="contact : email.support@github.com"></a><div id="footer">contact : <a href="mailto:email.support@github.com" target="_blank" rel="noopener">email.support@github.com</a></div></h1><p><div id="footer"><br>  please contact us at <a href="mailto:support@github.com" target="_blank" rel="noopener">support@github.com</a><br></div></p><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><p>iss53<br>可以看到 ======= 隔开的上半部分，是 HEAD（即 master 分支，在运行 merge 命令时所切换到的分支）中的内容，下半部分是在 iss53 分支中的内容。解决冲突的办法无非是二者选其一或者由你亲自整合到一起。比如你可以通过把这段内容替换为下面这样来解决：</p></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><p><div id="footer"><br>please contact us at <a href="mailto:email.support@github.com" target="_blank" rel="noopener">email.support@github.com</a><br></div><br>这个解决方案各采纳了两个分支中的一部分内容，而且我还删除了 &lt;&lt;&lt;&lt;&lt;&lt;&lt;，======= 和 &gt;&gt;&gt;&gt;&gt;&gt;&gt; 这些行。在解决了所有文件里的所有冲突后，运行 git add 将把它们标记为已解决状态（译注：实际上就是来一次快照保存到暂存区域。）。因为一旦暂存，就表示冲突已经解决。如果你想用一个有图形界面的工具来解决这些问题，不妨运行 git mergetool，它会调用一个可视化的合并工具并引导你解决所有冲突：</p><p>$ git mergetool</p><p>This message is displayed because ‘merge.tool’ is not configured.<br>See ‘git mergetool –tool-help’ or ‘git help config’ for more details.<br>‘git mergetool’ will now attempt to use one of the following tools:<br>opendiff kdiff3 tkdiff xxdiff meld tortoisemerge gvimdiff diffuse diffmerge ecmerge p4merge araxis bc3 codecompare vimdiff emerge<br>Merging:<br>index.html</p><p>Normal merge conflict for ‘index.html’:<br>  {local}: modified file<br>  {remote}: modified file<br>Hit return to start merge resolution tool (opendiff):<br>如果不想用默认的合并工具（Git 为我默认选择了 opendiff，因为我在 Mac 上运行了该命令），你可以在上方”merge tool candidates”里找到可用的合并工具列表，输入你想用的工具名。我们将在第七章讨论怎样改变环境中的默认值。</p><p>退出合并工具以后，Git 会询问你合并是否成功。如果回答是，它会为你把相关文件暂存起来，以表明状态为已解决。</p><p>再运行一次 git status 来确认所有冲突都已解决：</p><p>$ git status<br>On branch master<br>Changes to be committed:<br>  (use “git reset HEAD <file>…” to unstage)</file></p><pre><code>    modified:   index.html</code></pre><p>如果觉得满意了，并且确认所有冲突都已解决，也就是进入了暂存区，就可以用 git commit 来完成这次合并提交。提交的记录差不多是这样：</p><p>Merge branch ‘iss53’</p><p>Conflicts:<br>  index.html<br>#</p><h1 id="It-looks-like-you-may-be-committing-a-merge"><a href="#It-looks-like-you-may-be-committing-a-merge" class="headerlink" title="It looks like you may be committing a merge."></a>It looks like you may be committing a merge.</h1><h1 id="If-this-is-not-correct-please-remove-the-file"><a href="#If-this-is-not-correct-please-remove-the-file" class="headerlink" title="If this is not correct, please remove the file"></a>If this is not correct, please remove the file</h1><h1 id="git-MERGE-HEAD"><a href="#git-MERGE-HEAD" class="headerlink" title=".git/MERGE_HEAD"></a>.git/MERGE_HEAD</h1><h1 id="and-try-again"><a href="#and-try-again" class="headerlink" title="and try again."></a>and try again.</h1><p>#<br>如果想给将来看这次合并的人一些方便，可以修改该信息，提供更多合并细节。比如你都作了哪些改动，以及这么做的原因。有时候裁决冲突的理由并不直接或明显，有必要略加注解。</p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>git push和pull的默认行为</title>
      <link href="/2018/07/25/git-push%E5%92%8Cpull%E7%9A%84%E9%BB%98%E8%AE%A4%E8%A1%8C%E4%B8%BA/"/>
      <url>/2018/07/25/git-push%E5%92%8Cpull%E7%9A%84%E9%BB%98%E8%AE%A4%E8%A1%8C%E4%B8%BA/</url>
      <content type="html"><![CDATA[<h1 id="git-push"><a href="#git-push" class="headerlink" title="git push"></a>git push</h1><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p>git branch -b dev 新建并切换到dev分支</p><p>提交当前修改</p><p>然后git push</p><p>提示：<br>fatal: The current branch dev has no upstream branch.<br>To push the current branch and set the remote as upstream, use git push –set-upstream origin dev</p><p>继续输入 git push origin dev,会在提交并在github上新建dev分支。</p><h1 id="git-config-–global-push-default-‘option’改变push-default的默认行为"><a href="#git-config-–global-push-default-‘option’改变push-default的默认行为" class="headerlink" title="git config –global push.default ‘option’改变push.default的默认行为"></a>git config –global push.default ‘option’改变push.default的默认行为</h1><p>push.default 有以下几个可选值：</p><ol><li>nothing push操作无效，除非显式指定远程分支，例如git push origin develop</li><li>current push当前分支到远程同名分支，如果远程同名分支不存在则自动创建同名分支。</li><li>upstream  push当前分支到它的upstream分支上（这一项其实用于经常从本地分支push/pull到同一远程仓库的情景，这种模式叫做central workflow）。</li><li>simple simple和upstream是相似的，只有一点不同，simple必须保证本地分支和它的远程upstream分支同名，否则会拒绝push操作。</li><li>matching   push所有本地和远程两端都存在的同名分支。</li></ol><h1 id="upstream-amp-downstream"><a href="#upstream-amp-downstream" class="headerlink" title="upstream &amp; downstream"></a>upstream &amp; downstream</h1><p>git中存在upstream和downstream，简言之，当我们把仓库A中某分支x的代码push到仓库B分支y，此时仓库B的这个分支y就叫做A中x分支的upstream，而x则被称作y的downstream，这是一个相对关系，每一个本地分支都相对地可以有一个远程的upstream分支（注意这个upstream分支可以不同名，但通常我们都会使用同名分支作为upstream）。</p><p>初次提交本地分支，例如git push origin develop操作，并不会定义当前本地分支的upstream分支，我们可以通过git push –set-upstream origin develop，关联本地develop分支的upstream分支，另一个更为简洁的方式是初次push时，加入-u参数，例如git push -u origin develop，这个操作在push的同时会指定当前分支的upstream。</p><p>注意push.default = current可以在远程同名分支不存在的情况下自动创建同名分支，有些时候这也是个极其方便的模式，比如初次push你可以直接输入 git push 而不必显示指定远程分支。</p><h1 id="git-pull"><a href="#git-pull" class="headerlink" title="git pull"></a>git pull</h1><p>git pull的默认行为和git push完全不同。当我们执行git pull的时候，实际上是做了git fetch + git merge操作，fetch操作将会更新本地仓库的remote tracking，也就是refs/remotes中的代码，并不会对refs/heads中本地当前的代码造成影响。</p><p>当我们进行pull的第二个行为merge时，对git来说，如果我们没有设定当前分支的upstream，它并不知道我们要合并哪个分支到当前分支，所以我们需要通过下面的代码指定当前分支的upstream：</p><p>s<br><a href="https://segmentfault.com/a/1190000002783245" target="_blank" rel="noopener">https://segmentfault.com/a/1190000002783245</a></p>]]></content>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Dockerfile指令</title>
      <link href="/2018/07/25/Dockerfile%E6%8C%87%E4%BB%A4/"/>
      <url>/2018/07/25/Dockerfile%E6%8C%87%E4%BB%A4/</url>
      <content type="html"><![CDATA[<h1 id="cmd"><a href="#cmd" class="headerlink" title="cmd"></a>cmd</h1><h2 id="传参数"><a href="#传参数" class="headerlink" title="传参数"></a>传参数</h2><p>cmd [“/bin/bash”,”-l”]<br>容器启动时要运行的命令</p><h2 id="和run的区别"><a href="#和run的区别" class="headerlink" title="和run的区别"></a>和run的区别</h2><p>run是镜像构建时要运行的命令</p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>docker run后跟命令会覆盖cmd的命令</p><h1 id="entrypoint"><a href="#entrypoint" class="headerlink" title="entrypoint"></a>entrypoint</h1><p>entrypoint [“/usr/bin/nginx”] ，如果docker run -g “daemon off”，会执行nginx -g “daemon off”</p><p>如果不指定，会用cmd中的参数，所以cmd可以为entrtypoint指定默认选项</p><h1 id="workdir"><a href="#workdir" class="headerlink" title="workdir"></a>workdir</h1><p>cmd run entrypoint的默认工作目录，docker run -w 可以覆盖，todo 是全部覆盖还是</p><h1 id="env"><a href="#env" class="headerlink" title="env"></a>env</h1><p>docker run -e 创建环境变量，保存在容器中，只会在运行时有效</p><p>dockerfile的持久化在镜像中，环境变量</p><h1 id="user"><a href="#user" class="headerlink" title="user"></a>user</h1><p>docker run -u 覆盖<br>执行执行的身份</p><p>可以用uid或者user：gid或者group来标识</p><p>不通过docker run，默认为root</p><h1 id="volume"><a href="#volume" class="headerlink" title="volume"></a>volume</h1><p>提供独立于容器之外的持久化存储。</p><p>volume可以做容器与容器之间的数据共享</p><p>可以在docker inspect的Mounts中查看挂载信息</p><h1 id="add"><a href="#add" class="headerlink" title="add"></a>add</h1><p>复制到容器中 ，会解压zip等归档文件，同时支持url格式代表文件路径</p><h1 id="copy"><a href="#copy" class="headerlink" title="copy"></a>copy</h1><p>不支持url源路径，不解压归档文件</p><h1 id="onbuild"><a href="#onbuild" class="headerlink" title="onbuild"></a>onbuild</h1><p>你的镜像被用作别人镜像的基础镜像时，执行</p><h1 id="maintainer"><a href="#maintainer" class="headerlink" title="maintainer"></a>maintainer</h1><p>维护者</p><h1 id="镜像分层"><a href="#镜像分层" class="headerlink" title="镜像分层"></a>镜像分层</h1><p>dockerfile 每一行都产生新层。<br>dockerfile文件写的顺序在前，层的顺序越底。<br>比如from在前，则from在最底部。</p><p>在image中的层都是只读的。</p><p>一旦被运行成为一个容易，会产生新层，叫做容器层。</p><p>分层的好处，好多image，images之间可以共享层。</p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>Shiro活动图2</title>
      <link href="/2018/07/24/Shiro%E6%B4%BB%E5%8A%A8%E5%9B%BE2/"/>
      <url>/2018/07/24/Shiro%E6%B4%BB%E5%8A%A8%E5%9B%BE2/</url>
      <content type="html"><![CDATA[]]></content>
      
      
    </entry>
    
    <entry>
      <title>git常用命令整理</title>
      <link href="/2018/07/24/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86/"/>
      <url>/2018/07/24/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86/</url>
      <content type="html"><![CDATA[<ul><li>切换分支 git<br>checkout dev 切换到dev分支</li><li>新建分支并切换 git checkout -b dev 新建dev分支并切换</li><li>查看远程仓库名字 git remote </li><li>查看版本库信息 git remote show origin </li><li>查看远程分支 git branch -a</li><li>查看本地分支 git branch</li><li><p>从远程更新下来branch和tag等 git fetch </p></li><li><h1 id="Git-push"><a href="#Git-push" class="headerlink" title="Git push"></a>Git push</h1></li></ul><p>git push &lt;远程主机名&gt; &lt;本地分支名&gt;  &lt;远程分支名&gt;</p><p>git push origin master：refs/for/master ，即是将本地的master分支推送到远程主机origin上的对应master分支， origin 是远程主机名，</p><h2 id="git-push-origin-master"><a href="#git-push-origin-master" class="headerlink" title="git push origin master"></a>git push origin master</h2><p>如果远程分支被省略，如上则表示将本地分支推送到与之存在追踪关系的远程分支（通常两者同名），如果该远程分支不存在，则会被新建</p><h2 id="git-push-origin-：refs-for-master"><a href="#git-push-origin-：refs-for-master" class="headerlink" title="git push origin ：refs/for/master"></a>git push origin ：refs/for/master</h2><p>如果省略本地分支名，则表示删除指定的远程分支，因为这等同于推送一个空的本地分支到远程分支，等同于 git push origin –delete master</p><h2 id="git-push-origin"><a href="#git-push-origin" class="headerlink" title="git push origin"></a>git push origin</h2><p>如果当前分支与远程分支存在追踪关系，则本地分支和远程分支都可以省略，将当前分支推送到origin主机的对应分支 </p><h2 id="git-push"><a href="#git-push" class="headerlink" title="git push"></a>git push</h2><p>如果当前分支只有一个远程分支，那么主机名都可以省略，形如 git push，可以使用git branch -r ，查看远程的分支名</p><h2 id="git-push-的其他命令"><a href="#git-push-的其他命令" class="headerlink" title="git push 的其他命令"></a>git push 的其他命令</h2><p>这几个常见的用法已足以满足我们日常开发的使用了，还有几个扩展的用法，如下：</p><h3 id="git-push-u-origin-master"><a href="#git-push-u-origin-master" class="headerlink" title="git push -u origin master"></a>git push -u origin master</h3><p> 如果当前分支与多个主机存在追踪关系，则可以使用 -u 参数指定一个默认主机，这样后面就可以不加任何参数使用git push，</p><p>不带任何参数的git push，默认只推送当前分支，这叫做simple方式，还有一种matching方式，会推送所有有对应的远程分支的本地分支， Git 2.0之前默认使用matching，现在改为simple方式</p><p>如果想更改设置，可以使用git config命令。git config –global push.default matching OR git config –global push.default simple；可以使用git config -l 查看配置</p><h3 id="git-push-–all-origin"><a href="#git-push-–all-origin" class="headerlink" title="git push –all origin"></a>git push –all origin</h3><p> 当遇到这种情况就是不管是否存在对应的远程分支，将本地的所有分支都推送到远程主机，这时需要 -all 选项</p><h3 id="git-push-–force-origin"><a href="#git-push-–force-origin" class="headerlink" title="git push –force origin"></a>git push –force origin</h3><p>git push的时候需要本地先git pull更新到跟服务器版本一致，如果本地版本库比远程服务器上的低，那么一般会提示你git pull更新，如果一定要提交，那么可以使用这个命令。</p><h3 id="git-push-origin-–tags"><a href="#git-push-origin-–tags" class="headerlink" title="git push origin –tags"></a>git push origin –tags</h3><p>git push 的时候不会推送分支，如果一定要推送标签的话那么可以使用这个命令</p><h1 id="git-pull"><a href="#git-pull" class="headerlink" title="git pull"></a>git pull</h1><p>会把远程拉下来并合并冲突。</p><p>git pull=git fetch +git merge</p><h1 id="git-log"><a href="#git-log" class="headerlink" title="git log"></a>git log</h1><p>查看有哪些提交。</p><h1 id="git-version-git版本"><a href="#git-version-git版本" class="headerlink" title="git version git版本"></a>git version git版本</h1><h1 id="git-reset-hard-commit-id"><a href="#git-reset-hard-commit-id" class="headerlink" title="git reset -hard commit-id"></a>git reset -hard commit-id</h1><p>本地仓库回退到仓库，head也指向这个id，找回丢失的东西</p><h1 id="git-reflog"><a href="#git-reflog" class="headerlink" title="git reflog"></a>git reflog</h1><p>获得未来的commit-id，用git reset -hard 跳回到未来，</p><h1 id="git-diff"><a href="#git-diff" class="headerlink" title="git diff"></a>git diff</h1><h2 id="不带参数"><a href="#不带参数" class="headerlink" title="不带参数"></a>不带参数</h2><p>不带任何参数的git diff,是暂存区与工作区相比较,旧的是暂存区，也就是修改过还没有git add的内容</p><h2 id="git-diff-–cached-或者–staged"><a href="#git-diff-–cached-或者–staged" class="headerlink" title="git diff –cached 或者–staged"></a>git diff –cached 或者–staged</h2><p>head和暂存区相比,旧的是head</p><h2 id="git-diff-head"><a href="#git-diff-head" class="headerlink" title="git diff head"></a>git diff head</h2><p>将head和工作区相比,旧的是最新版本库</p><h1 id="git-status"><a href="#git-status" class="headerlink" title="git status"></a>git status</h1><h2 id="git-status-s"><a href="#git-status-s" class="headerlink" title="git status -s"></a>git status -s</h2><p>两个M,第一个M是版本库和暂存区对比,第二个M是暂存区和工作区对比.只要commit完了,版本库和暂存区内容一样,除非再次add</p><h1 id="git-commit"><a href="#git-commit" class="headerlink" title="git commit"></a>git commit</h1><h2 id="a"><a href="#a" class="headerlink" title="-a"></a>-a</h2><p>将所有已经跟踪的放到版本库中，不包括未跟踪的</p><h2 id="–amend"><a href="#–amend" class="headerlink" title="–amend"></a>–amend</h2><p>上一次重新提交，如果备注写错了，可以重新提交。<br>如果忘记提交了，可以git add再amend重新提交</p><h2 id="m"><a href="#m" class="headerlink" title="-m"></a>-m</h2><p> 将暂存区的放到head中</p><h2 id="a-m"><a href="#a-m" class="headerlink" title="-a -m"></a>-a -m</h2><p>相当于git add .和git commit -m</p><h1 id="git-rm"><a href="#git-rm" class="headerlink" title="git rm"></a>git rm</h1><p>相当于手动删除+git add</p><h1 id="git-rm-f"><a href="#git-rm-f" class="headerlink" title="git rm -f"></a>git rm -f</h1><p>如果要删除的文件修改过但是并未commit，在工作目录或者暂存区是modify状态，则不能直接删除</p><h1 id="git-rm-–cached"><a href="#git-rm-–cached" class="headerlink" title="git rm –cached"></a>git rm –cached</h1><p>移除版本库的跟踪，但是不删除本低的</p><p>可以使用glob模式，例如 git rm log/*.log,删除log目录下的所有.log结尾的日志文件，如果不加\不会递归匹配，也就是说不会匹配三层外的log文件。<br>已经实测过，就是这个样子</p><h1 id="git-rm-移动"><a href="#git-rm-移动" class="headerlink" title="git rm 移动"></a>git rm 移动</h1><p>相当于 rm+git rm+git add</p><h1 id="git-log-1"><a href="#git-log-1" class="headerlink" title="git log"></a>git log</h1><p>查看提交历史</p><h2 id="p-显示每次的差异-2-展开最近的两次更新"><a href="#p-显示每次的差异-2-展开最近的两次更新" class="headerlink" title="-p 显示每次的差异 -2 展开最近的两次更新"></a>-p 显示每次的差异 -2 展开最近的两次更新</h2><h2 id="–stat-显示增改行数统计"><a href="#–stat-显示增改行数统计" class="headerlink" title="–stat 显示增改行数统计"></a>–stat 显示增改行数统计</h2><h2 id="–pretty-格式化显示"><a href="#–pretty-格式化显示" class="headerlink" title="–pretty 格式化显示"></a>–pretty 格式化显示</h2><ul><li>online –graph 显示分支合并历史 </li><li>short</li><li>full</li><li>fuller</li><li>fommat –graph 显示分支</li></ul><h1 id="git-reset"><a href="#git-reset" class="headerlink" title="git reset"></a>git reset</h1><h2 id="git-reset-head-取消暂存，回到已修改未暂存的状态"><a href="#git-reset-head-取消暂存，回到已修改未暂存的状态" class="headerlink" title="git reset head  取消暂存，回到已修改未暂存的状态"></a>git reset head <file> 取消暂存，回到已修改未暂存的状态</file></h2><h1 id="git-checkout"><a href="#git-checkout" class="headerlink" title="git checkout"></a>git checkout</h1><h2 id="git-checkout-–-取消对文件的修改、"><a href="#git-checkout-–-取消对文件的修改、" class="headerlink" title="git checkout –  取消对文件的修改、"></a>git checkout – <file> 取消对文件的修改、</file></h2><h1 id="git-remote"><a href="#git-remote" class="headerlink" title="git remote"></a>git remote</h1><p>获取远程库的名i在</p><h2 id="git-remote-v-包含地址"><a href="#git-remote-v-包含地址" class="headerlink" title="git remote -v 包含地址"></a>git remote -v 包含地址</h2><h2 id="rename-pb-paul-重命名"><a href="#rename-pb-paul-重命名" class="headerlink" title="rename pb paul 重命名"></a>rename pb paul 重命名</h2><h1 id="git-checkout-1"><a href="#git-checkout-1" class="headerlink" title="git checkout"></a>git checkout</h1><h1 id="git-bracnh"><a href="#git-bracnh" class="headerlink" title="git bracnh"></a>git bracnh</h1><h2 id="lt-分支名-gt-创建分支"><a href="#lt-分支名-gt-创建分支" class="headerlink" title="&lt;分支名&gt; 创建分支"></a>&lt;分支名&gt; 创建分支</h2><h2 id="列出所有分支"><a href="#列出所有分支" class="headerlink" title="列出所有分支"></a>列出所有分支</h2><h2 id="d-删除分支"><a href="#d-删除分支" class="headerlink" title="-d 删除分支"></a>-d 删除分支</h2><h2 id="v-查看每个分支的最后提交"><a href="#v-查看每个分支的最后提交" class="headerlink" title="-v 查看每个分支的最后提交"></a>-v 查看每个分支的最后提交</h2><h1 id="git-checkout-2"><a href="#git-checkout-2" class="headerlink" title="git checkout"></a>git checkout</h1><ol><li>git checkout &lt;分支名&gt; 切换分支</li><li>git checkout – <filename> filename可以写前缀，只能能唯一确定就好</filename></li></ol>]]></content>
      
      
    </entry>
    
    <entry>
      <title>jenkins实现测试环境的自动化部署</title>
      <link href="/2018/07/23/jenkins%E5%AE%9E%E7%8E%B0%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83%E7%9A%84%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/"/>
      <url>/2018/07/23/jenkins%E5%AE%9E%E7%8E%B0%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83%E7%9A%84%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/</url>
      <content type="html"><![CDATA[]]></content>
      
      
    </entry>
    
    <entry>
      <title>mysql left join中where和on条件的区别</title>
      <link href="/2018/07/21/mysql-left-join%E4%B8%ADwhere%E5%92%8Con%E6%9D%A1%E4%BB%B6%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2018/07/21/mysql-left-join%E4%B8%ADwhere%E5%92%8Con%E6%9D%A1%E4%BB%B6%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      <content type="html"><![CDATA[<p>left join中关于where和on条件的几个知识点：</p><ol><li>多表left join是会生成一张临时表，并返回给用户</li><li>where条件是针对最后生成的这张临时表进行过滤，过滤掉不符合where条件的记录，是真正的不符合就过滤掉。</li><li>on条件是对left join的右表进行条件过滤，但依然返回左表的所有行，右表中没有的补为NULL</li><li>on条件中如果有对左表的限制条件，无论条件真假，依然返回左表的所有行,但是会影响右表的匹配值。也就是说on中左表的限制条件只影响右表的匹配内容，不影响返回行数。<br>结论：</li><li>where条件中对左表限制，不能放到on后面</li><li>where条件中对右表限制，放到on后面，会有数据行数差异，比原来行数要多</li></ol>]]></content>
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>MySQL开发技巧</title>
      <link href="/2018/07/21/MySQL%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/"/>
      <url>/2018/07/21/MySQL%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/</url>
      <content type="html"><![CDATA[<h2 id="SQL语句分类"><a href="#SQL语句分类" class="headerlink" title="SQL语句分类"></a>SQL语句分类</h2><ol><li>DDL</li><li>TPL 事务处理语言</li><li>DCL 数据控制语言</li><li>DML select insert update delete</li></ol><h2 id="join语句优化"><a href="#join语句优化" class="headerlink" title="join语句优化"></a>join语句优化</h2><ol><li>inner</li><li>full  left和right的结合，whrer a.key is null or b.key is null,a is null是B的独占部分，b is null是a的独占部分，mysql不支持full join，使用union all左连接和右连接</li><li>left a left join b where b.key is null,只包含A的部分，不包含中间部分和B，中间部分是b.key is not null</li><li>right </li><li>cross 笛卡儿积查询，a表和b表的交叉连接，5X4=20</li></ol><h2 id="join更新表"><a href="#join更新表" class="headerlink" title="join更新表"></a>join更新表</h2><p>join更新的表不能出现在from从句中。比如update user set a=1 where a in (select * from user)</p><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p>使用join，update user join （select ）</p><h2 id="join优化子查询"><a href="#join优化子查询" class="headerlink" title="join优化子查询"></a>join优化子查询</h2><h2 id="join优化聚合查询"><a href="#join优化聚合查询" class="headerlink" title="join优化聚合查询"></a>join优化聚合查询</h2><p>select a.user_name,b.timestr,b.kills,c.kills<br>from user1 a<br>join user_kills b on a.id=b.user_id<br>join user_kills c on c.user_id=b.user_id<br>GROUP BY a.user_name,b.timestr,b.kills<br>having b.kills=max(c.kills)</p><h2 id="join分组选择"><a href="#join分组选择" class="headerlink" title="join分组选择"></a>join分组选择</h2><p>每一系列文章最多的前几条文章</p><pre><code>SELECTd.user_name,c.timestr,killsFROM    (        SELECT            user_id,            timestr,            kills,            (                SELECT                    count(*)                FROM                    user_kills b                WHERE                    b.user_id = a.user_id                AND a.kills &lt;= b.kills            ) AS cnt        FROM            user_kills a            ) cJOIN user1 d ON c.user_id = d.idWHERE    cnt &lt;= 2</code></pre><h1 id="行转列"><a href="#行转列" class="headerlink" title="行转列"></a>行转列</h1><h2 id="使用自连接-同一个表进行连接-的方法实现"><a href="#使用自连接-同一个表进行连接-的方法实现" class="headerlink" title="使用自连接(同一个表进行连接)的方法实现"></a>使用自连接(同一个表进行连接)的方法实现</h2><pre><code>select *from (select SUM(kills) as &#39;沙僧&#39;from user1 a join user_kills  b on a.id=b.user_idand a.user_name=&#39;沙僧&#39;) a cross JOIN(select SUM(kills) as &#39;猪八戒&#39;from user1 a join user_kills  b on a.id=b.user_idand a.user_name=&#39;猪八戒&#39;) b cross join (select SUM(kills) as &#39;孙悟空&#39;from user1 a join user_kills  b on a.id=b.user_idand a.user_name=&#39;孙悟空&#39;) c</code></pre><h2 id="使用case方法实现行列转换"><a href="#使用case方法实现行列转换" class="headerlink" title="使用case方法实现行列转换"></a>使用case方法实现行列转换</h2><pre><code>select sum(case when user_name=&#39;孙悟空&#39; then kills end)as &#39;孙悟空&#39;,sum(case when user_name=&#39;猪八戒&#39; then kills end)as &#39;猪八戒&#39;,sum(case when user_name=&#39;沙僧&#39; then kills end)as &#39;沙僧&#39;from user1 a join user_kills b on a.id=b.user_id;</code></pre><h2 id="属性拆分，ETL数据处理（和属性拆分一个意思）"><a href="#属性拆分，ETL数据处理（和属性拆分一个意思）" class="headerlink" title="属性拆分，ETL数据处理（和属性拆分一个意思）"></a>属性拆分，ETL数据处理（和属性拆分一个意思）</h2><h3 id="比如一个属性是用，组合成的"><a href="#比如一个属性是用，组合成的" class="headerlink" title="比如一个属性是用，组合成的"></a>比如一个属性是用，组合成的</h3><h1 id="唯一序列号"><a href="#唯一序列号" class="headerlink" title="唯一序列号"></a>唯一序列号</h1><h1 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h1><h2 id="参与打怪的师徒"><a href="#参与打怪的师徒" class="headerlink" title="参与打怪的师徒"></a>参与打怪的师徒</h2><pre><code>SELECT    user_nameFROM    user1WHERE    id IN (        SELECT            user_id        FROM            user_kills    )</code></pre><h1 id="为什么默认的ddl是’’"><a href="#为什么默认的ddl是’’" class="headerlink" title="为什么默认的ddl是’’"></a>为什么默认的ddl是’’</h1><p>如果用了mysql关键字作列名，字段名，那select ‘from’会被当做列名</p>]]></content>
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>MySQL性能优化</title>
      <link href="/2018/07/21/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
      <url>/2018/07/21/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
      <content type="html"><![CDATA[<h1 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h1><ol><li>解决数据库连接造成的timeout的5XX错误</li><li>慢查询</li><li>阻塞</li></ol><h1 id="方面"><a href="#方面" class="headerlink" title="方面"></a>方面</h1><ol><li>SQL以及索引</li><li>数据库表结构</li><li>系统配置</li><li>硬件</li></ol><h1 id="SQL索引以及优化"><a href="#SQL索引以及优化" class="headerlink" title="SQL索引以及优化"></a>SQL索引以及优化</h1><h2 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h2><h3 id="开启慢查询日志"><a href="#开启慢查询日志" class="headerlink" title="开启慢查询日志"></a>开启慢查询日志</h3><p>show variables like ‘%quer%’</p><p>set gloabl log_queries_not_using_indexes=on;<br>记录未使用索引的查询</p><p>set global slow_query_log=on;<br>打开慢查询日志</p><p>set global long_query_time 1;<br>慢查询时间设置为1s</p><h3 id="慢查询日志分析"><a href="#慢查询日志分析" class="headerlink" title="慢查询日志分析"></a>慢查询日志分析</h3><h4 id="mysqldumpslow"><a href="#mysqldumpslow" class="headerlink" title="mysqldumpslow"></a>mysqldumpslow</h4><p>-s 排序慢查询日志<br>-t 查看前多少条</p><h4 id="pt-query——digest"><a href="#pt-query——digest" class="headerlink" title="pt-query——digest"></a>pt-query——digest</h4><p>-limit 分析多少条</p><ol><li>注意次数多且每次查询占用时间长的SQL</li><li>注意Rows examine项，扫描行数，IO</li><li>Rows examine远远大于Rows send，表示未命中索引的SQL多</li></ol><h2 id="explain"><a href="#explain" class="headerlink" title="explain"></a>explain</h2><ul><li>table 那张表</li><li>type 好到差 const 主键唯一索引，eq_reg,主键或者唯一索引的范围查找，ref 连接查询，一个表是基于某个索引的，range基于索引的范围查找，index索引扫描，all表扫描。</li><li>possible—_keys 用到的索引有哪些，为空表示没用到</li><li>keys 实际用到的索引</li><li>key——len 索引长度，越短越好</li><li>ref 哪一列索引被使用了</li><li>rows 检查用来返回的请求数据的行数</li><li>extra filesort，文件排序了，temporary 使用了临时表</li></ul><h3 id="对max和count优化"><a href="#对max和count优化" class="headerlink" title="对max和count优化"></a>对max和count优化</h3><pre><code>select  count(release_year=&#39;2006&#39; or null) as &#39;2006年的电影数量&#39;,count(release_year=&#39;2007&#39; or null) as &#39;2007年的电影数量&#39;,from film</code></pre><p>注意or null，因为count不计算null，如果不写or null，那即使count条件不成立，相当于1，也包含在内</p><h3 id="子查询优化"><a href="#子查询优化" class="headerlink" title="子查询优化"></a>子查询优化</h3><ol><li>in改成join，注意可能会出现重复</li></ol><h2 id="group-by"><a href="#group-by" class="headerlink" title="group by"></a>group by</h2><pre><code>select actor.first_name,actor.last_name,COUNT(*)from film_actorINNER JOIN actor using(actor_id)GROUP BY actor.actor_idselect actor.first_name,actor.last_name,COUNT(*)from actorINNER JOIN (select actor_id,count(*) as cnt from film_actor GROUP BY actor_id) as c using(actor_id)</code></pre><h1 id="lmit优化"><a href="#lmit优化" class="headerlink" title="lmit优化"></a>lmit优化</h1><p>select .. where id &gt; 50 and id &lt;60 limit 1,5<br>比select … limit 50,55的row要好<br>但是要保证id是连续的，不能中断，可以加一个index字段</p><h1 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h1><ol><li>在group by 从句，where，order by，on</li><li>索引字段越小越好</li><li>离散度越大（不同的数目越多），的放在联合索引前面</li><li>减小重复索引，primary key和unique（id）</li><li>多余索引，联合索引包含了主键的列。</li><li>有查找重复索引和冗余索引的sql</li><li>pt-duplicate-key-checker工具检查重复以及冗余索引</li><li>mysql中只能通过慢日志配合pt-index-usage根据进行使用情况的分析。</li></ol><h1 id="数据库结构优化"><a href="#数据库结构优化" class="headerlink" title="数据库结构优化"></a>数据库结构优化</h1><ol><li>最小的数据类型</li><li>简单的数据类型，时间上int比varchar简单</li><li>尽量使用not null</li><li>尽量少用text类型，非用不可考虑分表</li><li>int来存储时间</li><li>bigint来存储inet_aton() ip地址</li></ol><h1 id="范式优化"><a href="#范式优化" class="headerlink" title="范式优化"></a>范式优化</h1><p>目前遵循第三范式</p><p>数据表中不存在非关键字字段对任意候选关键字字段的传递函数依赖</p><h2 id="不符合第三范式的表的问题"><a href="#不符合第三范式的表的问题" class="headerlink" title="不符合第三范式的表的问题"></a>不符合第三范式的表的问题</h2><ol><li>冗余</li><li>更新，删除，插入异常</li></ol><h2 id="反范式化"><a href="#反范式化" class="headerlink" title="反范式化"></a>反范式化</h2><p>增加冗余</p><h2 id="表的垂直拆分"><a href="#表的垂直拆分" class="headerlink" title="表的垂直拆分"></a>表的垂直拆分</h2><p>很多列拆分成</p><ol><li>把不常用的放一个表中，常用的放在一起</li><li>大字段放在一个表中</li></ol><h2 id="水平拆分"><a href="#水平拆分" class="headerlink" title="水平拆分"></a>水平拆分</h2><ol><li>进行hash运算，取余拆分</li><li>针对不同的hashid放到不同表中</li></ol><h3 id="挑战"><a href="#挑战" class="headerlink" title="挑战"></a>挑战</h3><ol><li>跨分区表进行汇总统计</li></ol><h2 id="配置优化"><a href="#配置优化" class="headerlink" title="配置优化"></a>配置优化</h2><ol><li>net—.tcp_max 增加tcp支持的队列数</li><li>资源回收 tw_buckets  加快回收</li><li>打开文件数限制</li><li>关闭selinux，iptables，使用硬件防火墙</li><li>配置文件多个后面的会覆盖前面的</li><li>innbodb——buffer_pool_size innodb缓冲池大小</li><li>pool——instances 缓冲池的个数</li><li>log——buffer—size 日志缓冲区</li><li>flush——log——at——trx——commit 数据安全质较高设置为2</li><li>read——io——threads write 读写进程</li><li>file——per——table 共享表空间，默认为off，所有的</li><li>stats——on——meta 决定mysql在什么情况下刷新innodb表的统计信息。</li></ol><h1 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h1><ol><li>raid 多个磁盘组成一个磁盘</li><li>raid 要求至少两个磁盘</li></ol>]]></content>
      
      
    </entry>
    
    <entry>
      <title>《高性能MySQL》读书笔记</title>
      <link href="/2018/07/19/%E3%80%8A%E9%AB%98%E6%80%A7%E8%83%BDMySQL%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
      <url>/2018/07/19/%E3%80%8A%E9%AB%98%E6%80%A7%E8%83%BDMySQL%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[]]></content>
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>《MySQL技术内幕：InnoDB存储引擎》读书笔记</title>
      <link href="/2018/07/19/%E3%80%8AMySQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95%EF%BC%9AInnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
      <url>/2018/07/19/%E3%80%8AMySQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95%EF%BC%9AInnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[]]></content>
      
      
    </entry>
    
    <entry>
      <title>test</title>
      <link href="/2018/07/18/test/"/>
      <url>/2018/07/18/test/</url>
      <content type="html"><![CDATA[]]></content>
      
      
    </entry>
    
    <entry>
      <title>锁优化</title>
      <link href="/2018/07/17/%E9%94%81%E4%BC%98%E5%8C%96/"/>
      <url>/2018/07/17/%E9%94%81%E4%BC%98%E5%8C%96/</url>
      <content type="html"><![CDATA[<ol><li>减小锁持有时间</li><li>减小锁粒度</li><li>读写分离锁替换独占锁</li><li>锁分离，比如LinkedBlockingQueue,插入在队尾，取出在队头。</li><li>锁粗化。</li></ol>]]></content>
      
      
        <tags>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JDK的并发容器</title>
      <link href="/2018/07/17/JDK%E7%9A%84%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/"/>
      <url>/2018/07/17/JDK%E7%9A%84%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/</url>
      <content type="html"><![CDATA[<h1 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h1><h1 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h1><p>读取不需要加锁，写入也不会阻塞读取操作，写入和写入需要同步等待</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>在写入操作时，进行一次自我复制，并不修改原有的内容，写完之后，再将副本替换原来的数据。</p><h1 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h1><p>高效的读写队列，使用cas无锁</p><h1 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h1><p>数据共享通道</p><h1 id="ConcurrentSkipListMap"><a href="#ConcurrentSkipListMap" class="headerlink" title="ConcurrentSkipListMap"></a>ConcurrentSkipListMap</h1><p>跳表，用来快速查找的</p><h1 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h1><h1 id="Collections工具类包装线程安全"><a href="#Collections工具类包装线程安全" class="headerlink" title="Collections工具类包装线程安全"></a>Collections工具类包装线程安全</h1><p>使用synchronize锁保证线程安全</p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>Java并发之volatile</title>
      <link href="/2018/07/17/Java%E5%B9%B6%E5%8F%91%E4%B9%8Bvolatile/"/>
      <url>/2018/07/17/Java%E5%B9%B6%E5%8F%91%E4%B9%8Bvolatile/</url>
      <content type="html"><![CDATA[<p>volatile能保证可见性和有序性</p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>synchronized与线程安全</title>
      <link href="/2018/07/17/synchronized%E4%B8%8E%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/"/>
      <url>/2018/07/17/synchronized%E4%B8%8E%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/</url>
      <content type="html"><![CDATA[<h1 id="线程的3个特性"><a href="#线程的3个特性" class="headerlink" title="线程的3个特性"></a>线程的3个特性</h1><p>VOA</p><ol><li>原子性 atom，指一个操作是不可中断的 </li><li>可见性 当一个变量修改了某一个共享变量的值，其他线程是否能够立即得知这个修改。</li><li><p>有序性 程序在执行时，可能会进行指令重排。</p><h1 id="synchronized的3种用法"><a href="#synchronized的3种用法" class="headerlink" title="synchronized的3种用法"></a>synchronized的3种用法</h1></li><li><p>指定加锁对象</p></li><li>直接作用于实例方法</li><li>直接作用于静态方法</li></ol><h1 id="能保证的地方"><a href="#能保证的地方" class="headerlink" title="能保证的地方"></a>能保证的地方</h1><ol><li>可见性</li><li></li></ol>]]></content>
      
      
        <tags>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Elasticsearch索引的创建、数据的增删该查操作</title>
      <link href="/2018/07/16/Elasticsearch%E7%B4%A2%E5%BC%95%E7%9A%84%E5%88%9B%E5%BB%BA%E3%80%81%E6%95%B0%E6%8D%AE%E7%9A%84%E5%A2%9E%E5%88%A0%E8%AF%A5%E6%9F%A5%E6%93%8D%E4%BD%9C/"/>
      <url>/2018/07/16/Elasticsearch%E7%B4%A2%E5%BC%95%E7%9A%84%E5%88%9B%E5%BB%BA%E3%80%81%E6%95%B0%E6%8D%AE%E7%9A%84%E5%A2%9E%E5%88%A0%E8%AF%A5%E6%9F%A5%E6%93%8D%E4%BD%9C/</url>
      <content type="html"><![CDATA[<h1 id="1、创建Maven工程"><a href="#1、创建Maven工程" class="headerlink" title="1、创建Maven工程"></a>1、创建Maven工程</h1><pre><code>&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;groupId&gt;com.sun.elasticsearch&lt;/groupId&gt;    &lt;artifactId&gt;Elasticsearch01&lt;/artifactId&gt;    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;    &lt;dependencies&gt;        &lt;!-- Elasticsearch核心依赖包 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.elasticsearch.client&lt;/groupId&gt;            &lt;artifactId&gt;transport&lt;/artifactId&gt;            &lt;version&gt;5.5.2&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;junit&lt;/groupId&gt;            &lt;artifactId&gt;junit&lt;/artifactId&gt;            &lt;version&gt;4.12&lt;/version&gt;            &lt;scope&gt;test&lt;/scope&gt;        &lt;/dependency&gt;        &lt;!-- 日志依赖 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;            &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;            &lt;version&gt;1.7.21&lt;/version&gt;            &lt;scope&gt;test&lt;/scope&gt;        &lt;/dependency&gt;        &lt;!-- https://mvnrepository.com/artifact/org.apache.logging.log4j/log4j-core --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;            &lt;artifactId&gt;log4j-core&lt;/artifactId&gt;            &lt;version&gt;2.8.2&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- https://mvnrepository.com/artifact/com.google.code.gson/gson --&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.google.code.gson&lt;/groupId&gt;            &lt;artifactId&gt;gson&lt;/artifactId&gt;            &lt;version&gt;2.8.0&lt;/version&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;&lt;/project&gt;</code></pre><h1 id="2、通过Java程序连接Elasticsearch"><a href="#2、通过Java程序连接Elasticsearch" class="headerlink" title="2、通过Java程序连接Elasticsearch"></a>2、通过Java程序连接Elasticsearch</h1><pre><code>package com.sun.elasticsearch;import java.net.InetAddress;import java.net.UnknownHostException;import org.elasticsearch.client.transport.TransportClient;import org.elasticsearch.common.settings.Settings;import org.elasticsearch.common.transport.InetSocketTransportAddress;import org.elasticsearch.transport.client.PreBuiltTransportClient;import org.junit.Test;import org.slf4j.Logger;import org.slf4j.LoggerFactory;/*** Elasticsearch的基本测试* @ClassName: ElasticsearchTest1  * @author sunt  * @date 2017年11月22日 * @version V1.0*/public class ElasticsearchTest1 {    private Logger logger = LoggerFactory.getLogger(ElasticsearchTest1.class);    public final static String HOST = &quot;192.168.1.140&quot;;    public final static int PORT = 9300;//http请求的端口是9200，客户端是9300    /**    * 测试Elasticsearch客户端连接    * @Title: test1     * @author sunt      * @date 2017年11月22日    * @return void    * @throws UnknownHostException     */    @SuppressWarnings(&quot;resource&quot;)    @Test    public void test1() throws UnknownHostException {        //创建客户端        TransportClient client = new PreBuiltTransportClient(Settings.EMPTY).addTransportAddresses(                                new InetSocketTransportAddress(InetAddress.getByName(HOST),PORT));        logger.debug(&quot;Elasticsearch connect info:&quot; + client.toString());        //关闭客户端        client.close();    }}</code></pre><h1 id="3、Elasticsearch索引库的创建"><a href="#3、Elasticsearch索引库的创建" class="headerlink" title="3、Elasticsearch索引库的创建"></a>3、Elasticsearch索引库的创建</h1><pre><code>private Logger logger = LoggerFactory.getLogger(ElasticsearchTest2.class);public final static String HOST = &quot;192.168.1.140&quot;;public final static int PORT = 9300; //http请求的端口是9200，客户端是9300private TransportClient client = null;/** * 获取客户端连接信息 * @Title: getConnect  * @author sunt   * @date 2017年11月23日 * @return void * @throws UnknownHostException  */@SuppressWarnings({ &quot;resource&quot;, &quot;unchecked&quot; })@Beforepublic void getConnect() throws UnknownHostException {    client = new PreBuiltTransportClient(Settings.EMPTY).addTransportAddresses(             new InetSocketTransportAddress(InetAddress.getByName(HOST),PORT));    logger.info(&quot;连接信息:&quot; + client.toString());}/** * 关闭连接 * @Title: closeConnect  * @author sunt   * @date 2017年11月23日 * @return void */@After</code></pre><p>4、向索引库中添加json字符串<br>    public void closeConnect() {<br>        if(null != client) {<br>            logger.info(“执行关闭连接操作…”);<br>            client.close();<br>        }<br>    }</p><pre><code>/** * 创建索引库 * @Title: addIndex1 * @author sunt   * @date 2017年11月23日 * @return void * 需求:创建一个索引库为：msg消息队列,类型为：tweet,id为1 * 索引库的名称必须为小写 * @throws IOException  */@Testpublic void addIndex1() throws IOException {    IndexResponse response = client.prepareIndex(&quot;msg&quot;, &quot;tweet&quot;, &quot;1&quot;).setSource(XContentFactory.jsonBuilder()            .startObject().field(&quot;userName&quot;, &quot;张三&quot;)            .field(&quot;sendDate&quot;, new Date())            .field(&quot;msg&quot;, &quot;你好李四&quot;)            .endObject()).get();    logger.info(&quot;索引名称:&quot; + response.getIndex() + &quot;\n类型:&quot; + response.getType()                + &quot;\n文档ID:&quot; + response.getId() + &quot;\n当前实例状态:&quot; + response.status());}PS: 索引库名称必须为小写，如果为大写会包如下错误信息</code></pre><h1 id="4、向索引库中添加json字符串"><a href="#4、向索引库中添加json字符串" class="headerlink" title="4、向索引库中添加json字符串"></a>4、向索引库中添加json字符串</h1><pre><code>/**    * 添加索引:传入json字符串    * @Title: addIndex2     * @author sunt      * @date 2017年11月23日    * @return void    */    @Test    public void addIndex2() {        String jsonStr = &quot;{&quot; +                &quot;\&quot;userName\&quot;:\&quot;张三\&quot;,&quot; +                &quot;\&quot;sendDate\&quot;:\&quot;2017-11-30\&quot;,&quot; +                &quot;\&quot;msg\&quot;:\&quot;你好李四\&quot;&quot; +            &quot;}&quot;;        IndexResponse response = client.prepareIndex(&quot;weixin&quot;, &quot;tweet&quot;).setSource(jsonStr,XContentType.JSON).get();        logger.info(&quot;json索引名称:&quot; + response.getIndex() + &quot;\njson类型:&quot; + response.getType()        + &quot;\njson文档ID:&quot; + response.getId() + &quot;\n当前实例json状态:&quot; + response.status());    }</code></pre><h1 id="5、向索引库添加一个Map集合"><a href="#5、向索引库添加一个Map集合" class="headerlink" title="5、向索引库添加一个Map集合"></a>5、向索引库添加一个Map集合</h1><p>/**</p><pre><code> * 创建索引-传入Map对象 * @Title: addIndex3  * @author sunt   * @date 2017年11月23日 * @return void */@Testpublic void addIndex3() {    Map&lt;String, Object&gt; map = new HashMap&lt;String,Object&gt;();    map.put(&quot;userName&quot;, &quot;张三&quot;);    map.put(&quot;sendDate&quot;, new Date());    map.put(&quot;msg&quot;, &quot;你好李四&quot;);    IndexResponse response = client.prepareIndex(&quot;momo&quot;, &quot;tweet&quot;).setSource(map).get();    logger.info(&quot;map索引名称:&quot; + response.getIndex() + &quot;\n map类型:&quot; + response.getType()    + &quot;\n map文档ID:&quot; + response.getId() + &quot;\n当前实例map状态:&quot; + response.status());}</code></pre>]]></content>
      
      
    </entry>
    
    <entry>
      <title>HashSet、TreeSet和LinkedHashSet的区别</title>
      <link href="/2018/07/16/HashSet%E3%80%81TreeSet%E5%92%8CLinkedHashSet%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2018/07/16/HashSet%E3%80%81TreeSet%E5%92%8CLinkedHashSet%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      <content type="html"><![CDATA[<h1 id="Set接口"><a href="#Set接口" class="headerlink" title="Set接口"></a>Set接口</h1><p>Set不允许包含相同的元素，如果试图把两个相同元素加入同一个集合中，add方法返回false。</p><h2 id="HashSet类"><a href="#HashSet类" class="headerlink" title="HashSet类"></a>HashSet类</h2><p>HashSet有以下特点</p><ol><li>不能保证元素的排列顺序，顺序有可能发生变化</li><li>不是同步的</li><li>集合元素可以是null,但只能放入一个null<br>当向HashSet结合中存入一个元素时，HashSet会调用该对象的hashCode()方法来得到该对象的hashCode值，然后根据 hashCode值来决定该对象在HashSet中存储位置。<br>简单的说，HashSet集合判断两个元素相等的标准是两个对象通过equals方法比较相等，并且两个对象的hashCode()方法返回值相 等<br>注意，如果要把一个对象放入HashSet中，重写该对象对应类的equals方法，也应该重写其hashCode()方法。其规则是如果两个对 象通过equals方法比较返回true时，其hashCode也应该相同。另外，对象中用作equals比较标准的属性，都应该用来计算 hashCode的值。</li></ol><h2 id="LinkedHashSet类"><a href="#LinkedHashSet类" class="headerlink" title="LinkedHashSet类"></a>LinkedHashSet类</h2><p>LinkedHashSet集合同样是根据元素的hashCode值来决定元素的存储位置，但是它同时使用链表维护元素的次序。这样使得元素看起 来像是以插入顺序保存的，也就是说，当遍历该集合时候，LinkedHashSet将会以元素的添加顺序访问集合的元素。<br>LinkedHashSet在迭代访问Set中的全部元素时，性能比HashSet好，但是插入时性能稍微逊色于HashSet。</p><h2 id="TreeSet类"><a href="#TreeSet类" class="headerlink" title="TreeSet类"></a>TreeSet类</h2><p>TreeSet是SortedSet接口的唯一实现类，TreeSet可以确保集合元素处于排序状态。TreeSet支持两种排序方式，自然排序 和定制排序，其中自然排序为认的排序方式。向TreeSet中加入的应该是同一个类的对象。默<br>TreeSet判断两个对象不相等的方式是两个对象通过equals方法返回false，或者通过CompareTo方法比较没有返回0<br>自然排序<br>自然排序使用要排序元素的CompareTo（Object obj）方法来比较元素之间大小关系，然后将元素按照升序排列。<br>Java提供了一个Comparable接口，该接口里定义了一个compareTo(Object obj)方法，该方法返回一个整数值，实现了该接口的对象就可以比较大小。<br>obj1.compareTo(obj2)方法如果返回0，则说明被比较的两个对象相等，如果返回一个正数，则表明obj1大于obj2，如果是 负数，则表明obj1小于obj2。<br>如果我们将两个对象的equals方法总是返回true，则这两个对象的compareTo方法返回应该返回0<br>定制排序<br>自然排序是根据集合元素的大小，以升序排列，如果要定制排序，应该使用Comparator接口，实现 int compare(T o1,T o2)方法</p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>Java GC工作原理以及Minor GC、Major GC、Full GC简单总结</title>
      <link href="/2018/07/16/Java-GC%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8AMinor-GC%E3%80%81Major-GC%E3%80%81Full-GC%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93/"/>
      <url>/2018/07/16/Java-GC%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8AMinor-GC%E3%80%81Major-GC%E3%80%81Full-GC%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<h1 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h1><p>GC：垃圾收集器</p><p>Minor GC：新生代GC，指发生在新生代的垃圾收集动作，所有的Minor GC都会触发全世界的暂停（stop-the-world），停止应用程序的线程，不过这个过程非常短暂。</p><p>Major GC/Full GC：老年代GC，指发生在老年代的GC。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>众所周知，所有通过new创建的对象的内存都在堆中分配，堆被划分为新生代和老年代，新生代又被进一步划分为Eden和Survivor区，而Survivor由FromSpace和ToSpace组成。</p><h3 id="新生代"><a href="#新生代" class="headerlink" title="新生代"></a>新生代</h3><p>新创建的对象都是用新生代分配内存，Eden空间不足时，触发Minor GC，这时会把存活的对象转移进Survivor区。</p><h3 id="老年代"><a href="#老年代" class="headerlink" title="老年代"></a>老年代</h3><p>老年代用于存放经过多次Minor GC之后依然存活的对象。</p><h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><p>每个线程执行每个方法的时候都会在栈中申请一个栈帧，每个栈帧包括局部变量区和操作数栈，用于存放此次方法调用过程中的临时变量、参数和中间结果。</p><p>#本地方法栈</p><p>用于支持native方法的执行，存储了每个native方法调用的状态。</p><h1 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h1><p>存放了要加载的类信息、静态变量、final类型的常量、属性和方法信息。JVM用持久代(PermanetGeneration)来存放方法区。</p><h1 id="JVM垃圾回收机制"><a href="#JVM垃圾回收机制" class="headerlink" title="JVM垃圾回收机制"></a>JVM垃圾回收机制</h1><p>JVM分别对新生代和老年代采用不同的垃圾回收机制。</p><p>GC触发条件：Eden区满了触发Minor GC，这时会把Eden区存活的对象复制到Survivor区，当对象在Survivor区熬过一定次数的Minor GC之后，就会晋升到老年代（当然并不是所有的对象都是这样晋升的到老年代的），当老年代满了，就会报OutofMemory异常。</p><h2 id="新生代的GC（Minor-GC）："><a href="#新生代的GC（Minor-GC）：" class="headerlink" title="新生代的GC（Minor GC）："></a>新生代的GC（Minor GC）：</h2><p>新生代通常存活时间较短基于Copying算法进行回收，所谓Copying算法就是扫描出存活的对象，并复制到一块新的完全未使用的空间中，对应于新生代，就是在Eden和FromSpace或ToSpace之间copy。新生代采用空闲指针的方式来控制GC触发，指针保持最后一个分配的对象在新生代区间的位置，当有新的对象要分配内存时，用于检查空间是否足够，不够就触发GC。当连续分配对象时，对象会逐渐从Eden到Survivor，最后到老年代。</p><p>在执行机制上JVM提供了串行GC(SerialGC)、并行回收GC(ParallelScavenge)和并行GC(ParNew)：</p><p>串行GC</p><p>在整个扫描和复制过程采用单线程的方式来进行，适用于单CPU、新生代空间较小及对暂停时间要求不是非常高的应用上，是client级别默认的GC方式，可以通过-XX:+UseSerialGC来强制指定。</p><p>并行回收GC</p><p>在整个扫描和复制过程采用多线程的方式来进行，适用于多CPU、对暂停时间要求较短的应用上，是server级别默认采用的GC方式，可用-XX:+UseParallelGC来强制指定，用-XX:ParallelGCThreads=4来指定线程数。</p><p>并行GC</p><p>与老年代的并发GC配合使用。</p><h2 id="老年代的GC（Major-GC-Full-GC）："><a href="#老年代的GC（Major-GC-Full-GC）：" class="headerlink" title="老年代的GC（Major GC/Full GC）："></a>老年代的GC（Major GC/Full GC）：</h2><p>老年代与新生代不同，老年代对象存活的时间比较长、比较稳定，因此采用标记(Mark)算法来进行回收，所谓标记就是扫描出存活的对象，然后再进行回收未被标记的对象，回收后对用空出的空间要么进行合并、要么标记出来便于下次进行分配，总之目的就是要减少内存碎片带来的效率损耗。</p><p>在执行机制上JVM提供了串行GC(Serial MSC)、并行GC(Parallel MSC)和并发GC(CMS)。</p><p>串行GC（Serial MSC）</p><p>client模式下的默认GC方式，可通过-XX:+UseSerialGC强制指定。每次进行全部回收，进行Compact，非常耗费时间。</p><p>并行GC（Parallel MSC）(吞吐量大，但是GC的时候响应很慢)</p><p>server模式下的默认GC方式，也可用-XX:+UseParallelGC=强制指定。可以在选项后加等号来制定并行的线程数。</p><p>并发GC（CMS）(响应比并行gc快很多，但是牺牲了一定的吞吐量)</p><p>使用CMS是为了减少GC执行时的停顿时间，垃圾回收线程和应用线程同时执行，可以使用-XX:+UseConcMarkSweepGC=指定使用，后边接等号指定并发线程数。CMS每次回收只停顿很短的时间，分别在开始的时候（Initial Marking），和中间（Final Marking）的时候，第二次时间略长。CMS一个比较大的问题是碎片和浮动垃圾问题（Floating Gabage）。碎片是由于CMS默认不对内存进行Compact所致，可以通过-XX:+UseCMSCompactAtFullCollection。</p><p>虚拟机给每个对象定义了一个对象年龄（Age）计数器。如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor区，并将对象年龄设为 1。对象在Survivor区中每熬过一次Minor GC，年龄就增加1，当它的年龄增加到一定程度（默认为15）时，就会被晋升到老年代中。对象晋升老年代的年龄阈值，可以通过参数 -XX:MaxTenuringThreshold 来设置。</p><p>GC判断对象是否”存活”或”死去”（GC回收的对象）：</p><p>1.引用计数器算法</p><p>给对象中添加一个引用计数器，每当有一个地方引用它时，计数器的值加1；当引用失效时，计数器的值减；当该对象的计数器的值为0时，标志该对象失效。</p><p>2.跟搜索算法</p><p>基本思路：通过一系列的名为“GCRoots”的对象作为起始点，从这些节点开始向下搜索，搜索过的路径称为引用链，当一个对象到GCRoots没有任何引用链相连（用图论的话来说就是从GC Roots到这个对象不可达）时，则证明对象是不可用的。</p><p>附JVM GC组合方式：</p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>MySQL的热备份和冷备份</title>
      <link href="/2018/07/16/MySQL%E7%9A%84%E7%83%AD%E5%A4%87%E4%BB%BD%E5%92%8C%E5%86%B7%E5%A4%87%E4%BB%BD/"/>
      <url>/2018/07/16/MySQL%E7%9A%84%E7%83%AD%E5%A4%87%E4%BB%BD%E5%92%8C%E5%86%B7%E5%A4%87%E4%BB%BD/</url>
      <content type="html"><![CDATA[<h1 id="冷备份"><a href="#冷备份" class="headerlink" title="冷备份"></a>冷备份</h1><p>冷备份（OFF， 慢， 时间点上恢复）<br>冷备份发生在数据库已经正常关闭的情况下，当正常关闭时会提供给我们一个完整的数据库。冷备份是将关键性文件拷贝到另外位置的一种说法。对于备份数据库信息而言，冷备份是最快和最安全的方法。</p><p>冷备份的优点：<br>1．是非常快速的备份方法（只需拷贝文件）<br>2．容易归档（简单拷贝即可）<br>3．容易恢复到某个时间点上（只需将文件再拷贝回去）<br>4．能与归档方法相结合，作数据库“最新状态”的恢复。<br>5．低度维护，高度安全。</p><p>冷备份的缺点：<br>1．单独使用时，只能提供到“某一时间点上”的恢复。<br>2．在实施备份的全过程中，数据库必须要作备份而不能作其它工作。也就是说，在冷备份过程中，数据库必须是关闭状态。<br>3．若磁盘空间有限，只能拷贝到磁带等其它外部存储设备上，速度会很慢。<br>4．不能按表或按用户恢复。<br>值得注意的是冷备份必须在数据库关闭的情况下进行，当数据库处于打开状态时，执行数据库文件系统备份是无效的 。而且在恢复后一定要把数据库文件的属组和属主改为mysql。</p><h1 id="热备份"><a href="#热备份" class="headerlink" title="热备份"></a>热备份</h1><p>热备份 （ON，快）<br>热备份是在数据库运行的情况下，备份数据库操作的sql语句，当数据库发生问题时，可以重新执行一遍备份的sql语句。</p><p>热备份的优点：<br>1．可在表空间或数据文件级备份，备份时间短。<br>2．备份时数据库仍可使用。<br>3．可达到秒级恢复（恢复到某一时间点上）。<br>4．可对几乎所有数据库实体作恢复。<br>5．恢复是快速的，在大多数情况下在数据库仍工作时恢复。</p><p>热备份的缺点：<br>1．不能出错，否则后果严重。<br>2．若热备份不成功，所得结果不可用于时间点的恢复。<br>3．因难于维护，所以要特别仔细小心，不允许“以失败而告终”。</p>]]></content>
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>支付宝——开放平台第三方应用安全开发指南</title>
      <link href="/2018/07/16/%E6%94%AF%E4%BB%98%E5%AE%9D%E2%80%94%E2%80%94%E5%BC%80%E6%94%BE%E5%B9%B3%E5%8F%B0%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/"/>
      <url>/2018/07/16/%E6%94%AF%E4%BB%98%E5%AE%9D%E2%80%94%E2%80%94%E5%BC%80%E6%94%BE%E5%B9%B3%E5%8F%B0%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/</url>
      <content type="html"><![CDATA[<h1 id="常见开发场景安全开发指南"><a href="#常见开发场景安全开发指南" class="headerlink" title="常见开发场景安全开发指南"></a>常见开发场景安全开发指南</h1><h2 id="敏感信息使用场景"><a href="#敏感信息使用场景" class="headerlink" title="敏感信息使用场景"></a>敏感信息使用场景</h2><p>敏感信息指用户的 身份证号、银行卡号、手机号 等身份信息。重要敏感信息的脱敏规范如下。</p><p>敏感信息类型    展示规范<br>身份证    显示前 1 位 + <em>(实际位数) + 后 1 位，如： 3<strong><strong><strong><em>**</em></strong></strong></strong>3<br>银行卡    显示前 6 位 + </em>(实际位数) + 后 4 位，如：622575<strong>**</strong>1496<br>手机号    显示前 3 位 + <strong><strong> + 后 2 位，如：137**</strong></strong>50</p><h2 id="敏感信息用于展示的场景"><a href="#敏感信息用于展示的场景" class="headerlink" title="敏感信息用于展示的场景"></a>敏感信息用于展示的场景</h2><p>原则：敏感信息的展示请严格按照脱敏规范进行脱敏</p><ul><li>说明：脱敏的逻辑必须在服务端完成，不能使用 Javascript 在客户端进行脱敏，包括代码注释、隐藏域、url 参数、cookies 等处的数据也必须脱敏。</li><li>说明：不能使用可逆的编码/加密方式，如 base64 编码等代替脱敏规范。</li><li>说明：若敏感信息明文展示在应用中，没有按照脱敏规范完成脱敏。支付宝开放平台将有权暂停敏感数据相关接口的开放。</li></ul><h2 id="敏感信息用于身份校验的场景"><a href="#敏感信息用于身份校验的场景" class="headerlink" title="敏感信息用于身份校验的场景"></a>敏感信息用于身份校验的场景</h2><p>原则：不要直接将敏感信息的明文信息在客户端与服务端之间传递</p><ul><li>说明：可以将敏感信息在服务端关联到用户标识 ID，在客户端保存用户标识 ID 并提交到服务端，服务端根据 ID 取出对应信息后进行校验。</li></ul><p><a href="https://blog.csdn.net/yangyang_01/article/details/79195191" target="_blank" rel="noopener">https://blog.csdn.net/yangyang_01/article/details/79195191</a></p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>NIO之缓冲区Buffer</title>
      <link href="/2018/07/16/NIO%E4%B9%8B%E7%BC%93%E5%86%B2%E5%8C%BABuffer/"/>
      <url>/2018/07/16/NIO%E4%B9%8B%E7%BC%93%E5%86%B2%E5%8C%BABuffer/</url>
      <content type="html"><![CDATA[<h1 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h1><h2 id="容量-Capacity"><a href="#容量-Capacity" class="headerlink" title="容量 Capacity"></a>容量 Capacity</h2><p>默认为分配大小 ，固定的</p><h2 id="上限-limit"><a href="#上限-limit" class="headerlink" title="上限 limit"></a>上限 limit</h2><p>默认为分配大小，可改变</p><h2 id="位置-Postion"><a href="#位置-Postion" class="headerlink" title="位置 Postion"></a>位置 Postion</h2><p>默认为0，可改变</p><h2 id="标记-Mark"><a href="#标记-Mark" class="headerlink" title="标记 Mark"></a>标记 Mark</h2><p>最初未定义</p><h2 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h2><p>0&lt;=mark&lt;=postion&lt;=limit&lt;=capacity</p><h1 id="API"><a href="#API" class="headerlink" title="API"></a>API</h1><h1 id="存取"><a href="#存取" class="headerlink" title="存取"></a>存取</h1>]]></content>
      
      
    </entry>
    
    <entry>
      <title>java堆</title>
      <link href="/2018/07/15/jvm%E4%B9%8B%E8%80%81%E5%B9%B4%E4%BB%A3/"/>
      <url>/2018/07/15/jvm%E4%B9%8B%E8%80%81%E5%B9%B4%E4%BB%A3/</url>
      <content type="html"><![CDATA[<h1 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h1><h2 id="新生代"><a href="#新生代" class="headerlink" title="新生代"></a>新生代</h2><p>eden区，s0或者from区，s1或者to区，s0和s1是两块大小相等，可以互换的空间。</p><h2 id="老年代"><a href="#老年代" class="headerlink" title="老年代"></a>老年代</h2><p>tenured</p><h3 id="新生代到老年代"><a href="#新生代到老年代" class="headerlink" title="新生代到老年代"></a>新生代到老年代</h3><p>首先分配在eden区，一次新生代回收后，如果还存活，就会进入s0或者s1，每经过1次回收如果活着年龄加1，年龄达到一定条件之后进入老年代。</p><h3 id="何时要进入老年代"><a href="#何时要进入老年代" class="headerlink" title="何时要进入老年代"></a>何时要进入老年代</h3><p>参数MaxnuringThreshold，默认是15个，也就是回收15次进入老年代。</p><p>未达到年龄也有可能晋升老年代。</p><h3 id="大对象进入老年代"><a href="#大对象进入老年代" class="headerlink" title="大对象进入老年代"></a>大对象进入老年代</h3><p>体积过大也可能会晋升老年代，通过PretenureSizeThresold来设置晋升老年代的阈值。</p>]]></content>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>排序算法</title>
      <link href="/2018/07/15/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
      <url>/2018/07/15/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
      <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中，ri=rj，且ri在rj之前，而在排序后的序列中，ri仍在rj之前，则称这种排序算法是稳定的；否则称为不稳定的。</p><h2 id="冒泡"><a href="#冒泡" class="headerlink" title="冒泡"></a>冒泡</h2><h3 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h3><p>两两比较相邻记录的关键字，如果反序则交换，直到没有反序的记录为止。</p><h3 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h3><p>冒泡排序就是把小的元素往前调或者把大的元素往后调。比较是相邻的两个元素比较，交换也发生在这两个元素之间。所以，如果两个元素相等，我想你是不会再无 聊地把他们俩交换一下的；如果两个相等的元素没有相邻，那么即使通过前面的两两交换把两个相邻起来，这时候也不会交换，所以相同元素的前后顺序并没有改 变，所以冒泡排序是一种稳定排序算法。</p><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><h3 id="思想-1"><a href="#思想-1" class="headerlink" title="思想"></a>思想</h3><p>每一趟在n-i+1个记录中选区关键字最小的记录作为有序序列的第i个记录，</p><h3 id="稳定性-1"><a href="#稳定性-1" class="headerlink" title="稳定性"></a>稳定性</h3><p>选择排序是给每个位置选择当前元素最小的，比如给第一个位置选择最小的，在剩余元素里面给第二个元素选择第二小的，依次类推，直到第n-1个元素，第n个 元素不用选择了，因为只剩下它一个最大的元素了。那么，在一趟选择，如果当前元素比一个元素小，而该小的元素又出现在一个和当前元素相等的元素后面，那么 交换后稳定性就被破坏了。比较拗口，举个例子，序列5 8 5 2 9， 我们知道第一遍选择第1个元素5会和2交换，那么原序列中2个5的相对前后顺序就被破坏了，所以选择排序不是一个稳定的排序算法。</p><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><h3 id="思想-2"><a href="#思想-2" class="headerlink" title="思想"></a>思想</h3><p>将一个记录插入到已经排好序的有序表中，从而得到一个新的、记录数增1的有序表。</p><h3 id="稳定性-2"><a href="#稳定性-2" class="headerlink" title="稳定性"></a>稳定性</h3><p>插入排序是在一个已经有序的小序列的基础上，一次插入一个元素。当然，刚开始这个有序的小序列只有1个元素，就是第一个元素。比较是从有序序列的末尾开 始，也就是想要插入的元素和已经有序的最大者开始比起，如果比它大则直接插入在其后面，否则一直往前找直到找到它该插入的位置。如果碰见一个和插入元素相等的，那么插入元素把想插入的元素放在相等元素的后面。所以，相等元素的前后顺序没有改变，从原无序序列出去的顺序就是排好序后的顺序，所以插入排序是稳定的。</p><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>将待排序列划分为若干组，在每一组内进行插入排序，以使整个序列基本有序，然后再对整个序列进行插入排序。<br>因为跨组排序了，是不稳定的排序算法。</p><h3 id="思想-3"><a href="#思想-3" class="headerlink" title="思想"></a>思想</h3><h3 id="稳定性-3"><a href="#稳定性-3" class="headerlink" title="稳定性"></a>稳定性</h3><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><h3 id="思想-4"><a href="#思想-4" class="headerlink" title="思想"></a>思想</h3><p>通过一趟排序将待排记录分割成独立的两部分，其中一部分记录的关键字比另一部分记录的关键字小，则可分别对这两部分记录进行排序，已达到整个序列有序的目的。</p><h3 id="稳定性-4"><a href="#稳定性-4" class="headerlink" title="稳定性"></a>稳定性</h3><p>快速排序有两个方向，左边的i下标一直往右走，当a[i] &lt;= a[center_index]，其中center_index是中枢元素的数组下标，一般取为数组第0个元素。而右边的j下标一直往左走，当a[j] &gt; a[center_index]。如果i和j都走不动了，i &lt;= j, 交换a[i]和a[j],重复上面的过程，直到i&gt;j。 交换a[j]和a[center_index]，完成一趟快速排序。在中枢元素和a[j]交换的时候，很有可能把前面的元素的稳定性打乱，比如序列为 5 3 3 4 3 8 9 10 11， 现在中枢元素5和3(第5个元素，下标从1开始计)交换就会把元素3的稳定性打乱，所以快速排序是一个不稳定的排序算法，不稳定发生在中枢元素和a[j] 交换的时刻。</p>]]></content>
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java ArrayList工作原理及实现</title>
      <link href="/2018/07/15/Java-ArrayList%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/"/>
      <url>/2018/07/15/Java-ArrayList%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/</url>
      <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>以数组实现。节约空间，但数组有容量限制。超出限制时会增加50%容量，用System.arraycopy()复制到新的数组，因此最好能给出数组大小的预估值。默认第一次插入元素时创建大小为10的数组。</p><p>按数组下标访问元素—get(i)/set(i,e) 的性能很高，这是数组的基本优势。</p><p>直接在数组末尾加入元素—add(e)的性能也高，但如果按下标插入、删除元素—add(i,e), remove(i), remove(e)，则要用System.arraycopy()来移动部分受影响的元素，性能就变差了，这是基本劣势。</p><h1 id="add函数"><a href="#add函数" class="headerlink" title="add函数"></a>add函数</h1><p>也就是说，当增加数据的时候，如果ArrayList的大小已经不满足需求时，那么就将数组变为原长度的1.5倍，之后的操作就是把老的数组拷到新的数组里面。例如，默认的数组大小是10，也就是说当我们add10个元素之后，再进行一次add时，就会发生自动扩容，数组长度由10变为了15具体情况如下</p><h1 id="set和get函数"><a href="#set和get函数" class="headerlink" title="set和get函数"></a>set和get函数</h1>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>MySQL的X锁和S锁</title>
      <link href="/2018/07/15/MySQL%E7%9A%84X%E9%94%81%E5%92%8CS%E9%94%81/"/>
      <url>/2018/07/15/MySQL%E7%9A%84X%E9%94%81%E5%92%8CS%E9%94%81/</url>
      <content type="html"><![CDATA[<p>mysql X锁和S锁基本的封锁类型有两种:</p><p>排它锁(X锁)和共享锁(S锁)：</p><h1 id="X锁"><a href="#X锁" class="headerlink" title="X锁"></a>X锁</h1><p>所谓X锁,是事务T对数据A加上X锁时,只允许事务T读取和修改数据A</p><h1 id="S锁"><a href="#S锁" class="headerlink" title="S锁"></a>S锁</h1><p>所谓S锁,是事务T对数据A加上S锁时,其他事务只能再对数据A加S锁,而不能加X锁,直到T释放A上的S锁</p><p>若事务T对数据对象A加了S锁,则T就可以对A进行读取,但不能进行更新(S锁因此又称为读锁),在T释放A上的S锁以前,其他事务可以再对A加S锁,但不能加X锁,从而可以读取A,但不能更新A.</p><p><a href="http://www.cnblogs.com/digdeep/archive/2015/11/16/4968453.html" target="_blank" rel="noopener">http://www.cnblogs.com/digdeep/archive/2015/11/16/4968453.html</a></p><p>学习了mysql加锁机制，RC，RR，与字段的索引还有关系，如何防止死锁，不同情况的加锁。</p><p>学习where条件的过滤</p><p>给定一条SQL，如何提取其中的where条件？where条件中的每个子条件，在SQL执行的过程中有分别起着什么样的作用？</p><p><a href="http://hedengcheng.com/?p=577" target="_blank" rel="noopener">http://hedengcheng.com/?p=577</a></p><p>Index Key 索引查找，第一遍找出最小值，随后需要逐个比较是否满足最大值的条件，得到最大值。</p><p>Index First Key — Index Last Key</p><p>Index Filter 索引过滤，对于索引查找出的值，均需要与索引过滤条件对比</p><p>Table Filter 对于没有命中索引的字段，需要回表查出完整记录，对其进行过滤</p><p>作者：健身编码工<br>链接：<a href="https://www.jianshu.com/p/342f526dbbc2" target="_blank" rel="noopener">https://www.jianshu.com/p/342f526dbbc2</a><br>來源：简书<br>简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。</p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>MySQL binlog_format (Mixed,Statement,Row)</title>
      <link href="/2018/07/15/MySQL-binlog-format-Mixed-Statement-Row/"/>
      <url>/2018/07/15/MySQL-binlog-format-Mixed-Statement-Row/</url>
      <content type="html"><![CDATA[<p>MySQL 5.5 中对于二进制日志 (binlog) 有 3 种不同的格式可选：Mixed,Statement,Row，默认格式是 Statement。总结一下这三种格式日志的优缺点。</p><p>MySQL Replication 复制可以是基于一条语句 (Statement Level) ，也可以是基于一条记录 (Row Level)，可以在 MySQL 的配置参数中设定这个复制级别，不同复制级别的设置会影响到 Master 端的 bin-log 日志格式。</p><h1 id="Row"><a href="#Row" class="headerlink" title="Row"></a>Row</h1><p>日志中会记录成每一行数据被修改的形式，然后在 slave 端再对相同的数据进行修改。</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>在 row 模式下，bin-log 中可以不记录执行的 SQL 语句的上下文相关的信息，仅仅只需要记录那一条记录被修改了，修改成什么样了。所以 row 的日志内容会非常清楚的记录下每一行数据修改的细节，非常容易理解。而且不会出现某些特定情况下的存储过程或 function ，以及 trigger 的调用和触发无法被正确复制的问题。</p><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>在 row 模式下，所有的执行的语句当记录到日志中的时候，都将以每行记录的修改来记录，这样可能会产生大量的日志内容，比如有这样一条 update 语句</p><p>UPDATE product SET owner_member_id = ‘b’ WHERE owner_member_id = ‘a’</p><p>执行之后，日志中记录的不是这条 update 语句所对应的事件 (MySQL 以事件的形式来记录 bin-log 日志) ，而是这条语句所更新的每一条记录的变化情况，这样就记录成很多条记录被更新的很多个事件。自然，bin-log 日志的量就会很大。尤其是当执行 alter table 之类的语句的时候，产生的日志量是惊人的。因为 MySQL 对于 alter table 之类的表结构变更语句的处理方式是整个表的每一条记录都需要变动，实际上就是重建了整个表。那么该表的每一条记录都会被记录到日志中。</p><h1 id="Statement"><a href="#Statement" class="headerlink" title="Statement"></a>Statement</h1><p>每一条会修改数据的 SQL 都会记录到 master 的 bin-log 中。slave 在复制的时候 SQL 进程会解析成和原来 master 端执行过的相同的 SQL 再次执行。</p><h2 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h2><p>在 statement 模式下，首先就是解决了 row 模式的缺点，不需要记录每一行数据的变化，减少了 bin-log 日志量，节省 I/O 以及存储资源，提高性能。因为他只需要记录在 master 上所执行的语句的细节，以及执行语句时候的上下文的信息。</p><h2 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h2><p>在 statement 模式下，由于他是记录的执行语句，所以，为了让这些语句在 slave 端也能正确执行，那么他还必须记录每条语句在执行的时候的一些相关信息，也就是上下文信息，以保证所有语句在 slave 端杯执行的时候能够得到和在 master 端执行时候相同的结果。另外就是，由于 MySQL 现在发展比较快，很多的新功能不断的加入，使 MySQL 的复制遇到了不小的挑战，自然复制的时候涉及到越复杂的内容，bug 也就越容易出现。在 statement 中，目前已经发现的就有不少情况会造成 MySQL 的复制出现问题，主要是修改数据的时候使用了某些特定的函数或者功能的时候会出现，比如：sleep() 函数在有些版本中就不能被正确复制，在存储过程中使用了 last_insert_id() 函数，可能会使 slave 和 master 上得到不一致的 id 等等。由于 row 是基于每一行来记录的变化，所以不会出现类似的问题。</p><h1 id="Mixed"><a href="#Mixed" class="headerlink" title="Mixed"></a>Mixed</h1><p>从官方文档中看到，之前的 MySQL 一直都只有基于 statement 的复制模式，直到 5.1.5 版本的 MySQL 才开始支持 row 复制。从 5.0 开始，MySQL 的复制已经解决了大量老版本中出现的无法正确复制的问题。但是由于存储过程的出现，给 MySQL Replication 又带来了更大的新挑战。另外，看到官方文档说，从 5.1.8 版本开始，MySQL 提供了除 Statement 和 Row 之外的第三种复制模式：Mixed，实际上就是前两种模式的结合。在 Mixed 模式下，MySQL 会根据执行的每一条具体的 SQL 语句来区分对待记录的日志形式，也就是在 statement 和 row 之间选择一种。新版本中的 statment 还是和以前一样，仅仅记录执行的语句。而新版本的 MySQL 中对 row 模式也被做了优化，并不是所有的修改都会以 row 模式来记录，比如遇到表结构变更的时候就会以 statement 模式来记录，如果 SQL 语句确实就是 update 或者 delete 等修改数据的语句，那么还是会记录所有行的变更。</p>]]></content>
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>MySQL使用可重复读作为默认隔离级别的原因之一</title>
      <link href="/2018/07/15/MySQL%E4%BD%BF%E7%94%A8%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E4%BD%9C%E4%B8%BA%E9%BB%98%E8%AE%A4%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E7%9A%84%E5%8E%9F%E5%9B%A0%E4%B9%8B%E4%B8%80/"/>
      <url>/2018/07/15/MySQL%E4%BD%BF%E7%94%A8%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E4%BD%9C%E4%B8%BA%E9%BB%98%E8%AE%A4%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E7%9A%84%E5%8E%9F%E5%9B%A0%E4%B9%8B%E4%B8%80/</url>
      <content type="html"><![CDATA[<p>一般的DBMS系统，默认都会使用读提交（Read-Comitted，RC）作为默认隔离级别，如Oracle、SQL Server等，而MySQL却使用可重复读（Read-Repeatable，RR）。要知道，越高的隔离级别，能解决的数据一致性问题越多，理论上性能损耗更大，可并发性越低。隔离级别依次为</p><p>RU&lt;RC&lt;RR&lt;SERIALIZABLE</p><p>在SQL标准中，4个隔离级别解决5种并发问题。对应解决了第一类丢失、脏读、（不可重复读+第二类丢失）、幻象读</p><ol><li>从Binlog说起<br>Binlog是MySQL的逻辑操作日志，广泛应用于复制和恢复。MySQL 5.1以前，Statement是Binlog的默认格式，即依次记录系统接受的SQL请求；5.1及以后，MySQL提供了Row和Mixed两个Binlog格式。</li></ol><p>从MySQL 5.1开始，Binlog为Statement，就不支持RC和Read-Uncommited隔离级别。要想使用RC隔离级别，必须使用Mixed或Row格式。</p><pre><code>mysql&gt; set tx_isolation=&#39;read-committed&#39;;Query OK, 0 rows affected (0.00 sec)mysql&gt; insert into t1 values(1,1);ERROR 1598 (HY000): Binary logging not possible. Message: Transaction level &#39;READ-COMMITTED&#39; in InnoDB is not safe for binlog mode &#39;STATEMENT&#39;</code></pre><p><a href="https://blog.csdn.net/zxk364961978/article/details/51564832" target="_blank" rel="noopener">https://blog.csdn.net/zxk364961978/article/details/51564832</a></p>]]></content>
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>MySQL InnoDB锁类型及幻象读问题</title>
      <link href="/2018/07/15/MySQL-InnoDB%E9%94%81%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%B9%BB%E8%B1%A1%E8%AF%BB%E9%97%AE%E9%A2%98/"/>
      <url>/2018/07/15/MySQL-InnoDB%E9%94%81%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%B9%BB%E8%B1%A1%E8%AF%BB%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[]]></content>
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>HashMap扩容机制</title>
      <link href="/2018/07/15/HashMap%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6/"/>
      <url>/2018/07/15/HashMap%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6/</url>
      <content type="html"><![CDATA[]]></content>
      
      
    </entry>
    
    <entry>
      <title>红黑树</title>
      <link href="/2018/07/15/%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
      <url>/2018/07/15/%E7%BA%A2%E9%BB%91%E6%A0%91/</url>
      <content type="html"><![CDATA[<h1 id="产生场景"><a href="#产生场景" class="headerlink" title="产生场景"></a>产生场景</h1><p>保证二叉排序树的平衡树</p><h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><h2 id="有颜色"><a href="#有颜色" class="headerlink" title="有颜色"></a>有颜色</h2><h2 id="保持颜色的规则"><a href="#保持颜色的规则" class="headerlink" title="保持颜色的规则"></a>保持颜色的规则</h2><ol><li>每个节点不是红的就是黑的</li><li>根总是黑色的</li><li>如果节点是红色的，他的子节点必须是黑色的,黑色的子节点可以是红的，也可以是黑的</li><li>从根到叶节点或空子节点的每条路径，必须相同数目的黑色节点</li></ol>]]></content>
      
      
    </entry>
    
    <entry>
      <title>前序、中序、后序遍历</title>
      <link href="/2018/07/15/%E5%89%8D%E5%BA%8F%E3%80%81%E4%B8%AD%E5%BA%8F%E3%80%81%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
      <url>/2018/07/15/%E5%89%8D%E5%BA%8F%E3%80%81%E4%B8%AD%E5%BA%8F%E3%80%81%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
      <content type="html"><![CDATA[<img src="/2018/07/15/前序、中序、后序遍历/traverse.JPG" title="traverse"><h1 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h1><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>*A+BC</p><h3 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h3><p>不需要括号也不会混乱</p><h3 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h3><p>每个操作符，会用于后面的两个算式，*用于A和+BC，+用于B和C</p><h1 id="中序"><a href="#中序" class="headerlink" title="中序"></a>中序</h1><p>A*（B+C），需要括号</p><h1 id="后序"><a href="#后序" class="headerlink" title="后序"></a>后序</h1><p>ABC+<em><br>倒着读，</em>用于A和BC+,+用于BC</p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>二叉排序树</title>
      <link href="/2018/07/14/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/"/>
      <url>/2018/07/14/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/</url>
      <content type="html"><![CDATA[<h2 id="产生场景"><a href="#产生场景" class="headerlink" title="产生场景"></a>产生场景</h2><p>插入和删除效率不错，又可以较高效率实现查找的算法。</p><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>左子树都比根小，右子树都比根大，左右子树也是二叉排序树</p><h1 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h1><p>平衡二叉树首先是一颗二叉排序树，左右子树之差的绝对值不超过1</p><p>非平衡二叉树是由于插入数据不随机导致的。</p><h1 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h1><h2 id="删除没有子节点的节点"><a href="#删除没有子节点的节点" class="headerlink" title="删除没有子节点的节点"></a>删除没有子节点的节点</h2><p>父节点的这个子节点设置为null</p><h2 id="删除有一个子节点的节点"><a href="#删除有一个子节点的节点" class="headerlink" title="删除有一个子节点的节点"></a>删除有一个子节点的节点</h2><p>上移</p><h2 id="删除有两个节点的节点"><a href="#删除有两个节点的节点" class="headerlink" title="删除有两个节点的节点"></a>删除有两个节点的节点</h2><p>为了保持平衡树，找后继节点</p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>平衡树</title>
      <link href="/2018/07/14/%E5%B9%B3%E8%A1%A1%E6%A0%91/"/>
      <url>/2018/07/14/%E5%B9%B3%E8%A1%A1%E6%A0%91/</url>
      <content type="html"><![CDATA[]]></content>
      
      
    </entry>
    
    <entry>
      <title>非对称加密算法</title>
      <link href="/2018/07/14/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"/>
      <url>/2018/07/14/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/</url>
      <content type="html"><![CDATA[<h1 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h1><p>1.A要向B发送信息，A和B都要产生一对用于加密和解密的公钥和私钥。<br>2.A的私钥保密，A的公钥告诉B；B的私钥保密，B的公钥告诉A。<br>3.A要给B发送信息时，A用B的公钥加密信息，因为A知道B的公钥。<br>4.A将这个消息发给B（已经用B的公钥加密消息）。<br>5.B收到这个消息后，B用自己的私钥解密A的消息。其他所有收到这个报文的人都无法解密，因为只有B才有B的私钥。</p><h1 id="数学原理"><a href="#数学原理" class="headerlink" title="数学原理"></a>数学原理</h1><p>m=明文 c=密文 N=随机数 e=公钥 d=密钥</p><p>依旧以两个大质数相乘得到的大数难以被因式分解为核心。</p><h2 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h2><p>m^e mod N = c    (明文m用公钥e加密并和随机数N取余得到密文c)<br>c^d mod N = m　(密文c用密钥解密并和随机数N取余得到明文m)<br>因此，两者合并就是：m^(e^d) mod N = m, 也就是：m^(ed) mod N =m</p><h2 id="如何敲定这个解密用d呢？"><a href="#如何敲定这个解密用d呢？" class="headerlink" title="如何敲定这个解密用d呢？"></a>如何敲定这个解密用d呢？</h2><p>这就需要引入一个概念叫：欧拉函数 φ ( n ) ：小于或等于n的正整数中与n互质的数的数目。<br>比如φ ( 8 )，1 2 3 4 5 6 7，符合这个条件的是：1 3 5 7，因此φ ( 8 )=4<br>因此我们可以得知，φ ( n ) 如果n为质数，φ ( n ) = n - 1<br>而且φ ( n )还符合φ ( a<em>b ) = φ ( a ) </em> φ ( b )</p><p>此外，还得借助欧拉定理：</p><p>因此计算e的模返元素d的方式如下：<br>1.选取两个大质数P1，P2，P1*P2=N，并能得到φ ( N )<br>2.更具欧拉定理能得知，ed=1（mod φ ( n )）<br>3.等价于ed-1 = k φ ( n )<br>4.于是等价于求解二元一次方程 ex + φ ( n )y = 1<br>求得一组解中的x便为d    </p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>常用加密算法简单整理</title>
      <link href="/2018/07/14/%E5%B8%B8%E7%94%A8%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E7%AE%80%E5%8D%95%E6%95%B4%E7%90%86/"/>
      <url>/2018/07/14/%E5%B8%B8%E7%94%A8%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E7%AE%80%E5%8D%95%E6%95%B4%E7%90%86/</url>
      <content type="html"><![CDATA[<h1 id="哈希加密"><a href="#哈希加密" class="headerlink" title="哈希加密"></a>哈希加密</h1><h2 id="md5加密"><a href="#md5加密" class="headerlink" title="md5加密"></a>md5加密</h2><p>Message Digest Algorithm MD5（中文名为消息摘要算法第五版)</p><p><a href="https://baike.baidu.com/item/MD5/212708?fr=aladdin" target="_blank" rel="noopener">https://baike.baidu.com/item/MD5/212708?fr=aladdin</a></p><p>MD5算法具有以下特点：<br>1、压缩性：任意长度的数据，算出的MD5值长度都是固定的-128bit=32位16进制,例如e10adc3949ba59abbe56e057f20f883e<br>2、容易计算：从原数据计算出MD5值很容易。<br>3、抗修改性：对原数据进行任何改动，哪怕只修改1个字节，所得到的MD5值都有很大区别。<br>4、强抗碰撞：已知原数据和其MD5值，想找到一个具有相同MD5值的数据（即伪造数据）是非常困难的。</p><p>1991年，Rivest开发出技术上更为趋近成熟的md5算法。它在MD4的基础上增加了”安全-带子”（safety-belts）的概念<br>我觉得常说的盐应该就是safety-belts的缩写<br>盐也就是向原文中加入的一串字符串,把明文盐和加密后的密码整合在一起存入数据库,至于怎么整合这里不去做过多研究.</p><h2 id="SHA-1"><a href="#SHA-1" class="headerlink" title="SHA-1"></a>SHA-1</h2><p>SHA (Secure Hash Algorithm，译作安全散列算法) 是美国国家安全局 (NSA) 设计，美国国家标准与技术研究院(NIST) 发布的一系列密码散列函数。</p><p>正式名称为 SHA 的家族第一个成员发布于 1993年(比md5晚)。然而人们给它取了一个非正式的名称 SHA-0 以避免与它的后继者混淆。两年之后， SHA-1，第一个 SHA 的后继者发布了</p><p>SHA-0在发布之后很快就被NSA撤回，并且以 1995年发布的修订版本 FIPS PUB 180-1 (通常称为 “SHA-1”) 取代。根据 NSA的说法，它修正了一个在原始算法中会降低密码安全性的错误。然而 NSA 并没有提供任何进一步的解释或证明该错误已被修正。1998年，在一次对 SHA-0 的攻击中发现这次攻击并不能适用于 SHA-1 — 我们不知道这是否就是NSA 所发现的错误，但这或许暗示我们这次修正已经提升了安全性。SHA-1已经被公众密码社群做了非常严密的检验而还没发现到有不安全的地方，它在一段时间被认为是安全的，直到Google宣布攻破SHA-1。</p><p><a href="http://www.chinaz.com/server/2017/0227/664383.shtml" target="_blank" rel="noopener">http://www.chinaz.com/server/2017/0227/664383.shtml</a></p><p> 另外还有四种变体，曾经发布以提升输出的范围和变更一些细微设计： SHA-224, SHA-256, SHA-384 和 SHA-512 (这些有时候也被称做 SHA-2)。</p><p>SHA-0 和 SHA-1 会从一个最大 2^64 位元的讯息中产生一串 160 位元的摘要，然后以设计 MD4 及 MD5 讯息摘要算法的 MIT 教授Ronald L. Rivest类似的原理为基础来加密。</p><p>NIST 发布了三个额外的 SHA 变体，每个都有更长的讯息摘要。以它们的摘要长度 (以位元计算) 加在原名后面来命名：”SHA-256”, “SHA-384” 和 “SHA-512”。它们发布于 2001年.</p><p>2004年2月，发布了一次 FIPS PUB 180-2 的变更通知，加入了一个额外的变种 “SHA-224”，定义了符合双金钥 3DES 所需的金钥长度。(虽然长度一般,当时发布的晚肯定有它的价值)</p><p>总结:SHA家族的摘要长度比MD5长,更安全,换来的代价是性能上的略微差异,不过相对安全而言,应该是值的的.</p><h2 id="PBKDF2"><a href="#PBKDF2" class="headerlink" title="PBKDF2"></a>PBKDF2</h2><p>PBKDF2简单而言就是将salted hash进行多次重复计算，这个次数是可选择的。如果计算一次所需要的时间是1微秒，那么计算1百万次就需要1秒钟。假如攻击一个密码所需的rainbow table有1千万条，建立所对应的rainbow table所需要的时间就是115天。这个代价足以让大部分的攻击者忘而生畏。　美国政府机构已经将这个方法标准化，并且用于一些政府和军方的系统。 这个方案最大的优点是标准化，实现容易同时采用了久经考验的SHA算法。</p><h2 id="Srypt"><a href="#Srypt" class="headerlink" title="Srypt"></a>Srypt</h2><p>我觉得应该吧scrypt算在单向加密中,因为介绍中提到了彩虹表.</p><p>scrypt是由著名的FreeBSD黑客 Colin Percival为他的备份服务 Tarsnap开发的。</p><p>scrypt不仅计算所需时间长，而且占用的内存也多，使得并行计算多个摘要异常困难，因此利用rainbow table(hash对照表,详细不深究</p><p><a href="https://www.zhihu.com/question/19790488" target="_blank" rel="noopener">https://www.zhihu.com/question/19790488</a></p><p>进行暴力攻击更加困难。scrypt没有在生产环境中大规模应用，并且缺乏仔细的审察和广泛的函数库支持。但是，scrypt在算法层面只要没有破绽，它的安全性应该高于PBKDF2和bcrypt。</p><h1 id="bcrypt和scrypt"><a href="#bcrypt和scrypt" class="headerlink" title="bcrypt和scrypt"></a>bcrypt和scrypt</h1><p>bcrypt是专门为密码存储而设计的算法，基于Blowfish加密算法变形而来，由Niels Provos和David Mazières发表于1999年的USENIX。　bcrypt最大的好处是有一个参数（work factor)，可用于调整计算强度，而且work factor是包括在输出的摘要中的。随着攻击者计算能力的提高，使用者可以逐步增大work factor，而且不会影响已有用户的登陆。　bcrypt经过了很多安全专家的仔细分析，使用在以安全著称的OpenBSD中，一般认为它比PBKDF2更能承受随着计算能力加强而带来的风险。bcrypt也有广泛的函数库支持，因此我们建议使用这种方式存储密码。</p><h1 id="spring-security提供的加密"><a href="#spring-security提供的加密" class="headerlink" title="spring security提供的加密"></a>spring security提供的加密</h1><p>我不是安全人员,了解不同性能,安全需求下改用什么加密算法即可.</p><p>从3.1.X(我也不太清楚具体哪个版本)开始,spring security已经不推荐使用sha1以及md5之类的加密算法了,</p><p>新版本各种加密算法强度应该是scrypt&gt;bscypt&gt;pbkdf2&gt;sha256(standard)</p><p>性能的话正好相反.</p><p>中小网站随便挑选,推荐用bcrypt</p><h1 id="spring-security提供的加密-1"><a href="#spring-security提供的加密-1" class="headerlink" title="spring security提供的加密"></a>spring security提供的加密</h1><p>我不是安全人员,了解不同性能,安全需求下改用什么加密算法即可.</p><p>从3.1.X(我也不太清楚具体哪个版本)开始,spring security已经不推荐使用sha1以及md5之类的加密算法了,</p><p>新版本各种加密算法强度应该是scrypt&gt;bscypt&gt;pbkdf2&gt;sha256(standard)</p><p>性能的话正好相反.</p><p>中小网站随便挑选,推荐用bcrypt</p><pre><code>@Configuration@EnableWebSecuritypublic class WebSecurityConfig extends WebSecurityConfigurerAdapter {    @Autowired    private AuthenticationFailureHandler authenticationFailureHandler;    @Autowired    private AuthenticationSuccessHandler authenticationSuccessHandler;    @Autowired    private  UserDetailsService userDetailsService;    public PasswordEncoder getPasswordEncoder()    {        return new BCryptPasswordEncoder(3);    }@Bean    public DaoAuthenticationProvider authProvider() {        DaoAuthenticationProvider authProvider = new DaoAuthenticationProvider();        authProvider.setPasswordEncoder(getPasswordEncoder());        authProvider.setUserDetailsService(userDetailsService);        return authProvider;    }        @Override    protected void configure(HttpSecurity http) throws Exception {        ValidateCodeFilter validateCodeFilter=new ValidateCodeFilter();        validateCodeFilter.setAuthenticationFailureHandler(authenticationFailureHandler);        http                .authorizeRequests()                .antMatchers(&quot;/**&quot;).permitAll()                .and()                .addFilterBefore(validateCodeFilter, UsernamePasswordAuthenticationFilter.class)                .formLogin().loginPage(&quot;/login&quot;).loginProcessingUrl(&quot;/shop_login&quot;)                .failureHandler(authenticationFailureHandler)                .successHandler(authenticationSuccessHandler)                .and()                .csrf().disable();    }}</code></pre>]]></content>
      
      
    </entry>
    
    <entry>
      <title>oauth2协议</title>
      <link href="/2018/07/14/oauth2%E5%8D%8F%E8%AE%AE/"/>
      <url>/2018/07/14/oauth2%E5%8D%8F%E8%AE%AE/</url>
      <content type="html"><![CDATA[<h1 id="如何知道用户是否登录？"><a href="#如何知道用户是否登录？" class="headerlink" title="如何知道用户是否登录？"></a>如何知道用户是否登录？</h1><p>通过cookie和session来查看用户是否登录.</p><p>如果cookie对应的session中保存了用户登录信息,则判定用户已登录</p><p>Jsessionid,也就是tomcat自动生成的cookie,用来匹配session,默认的domain,path以及expires都是N/A</p><p>这个N/A的意思是默认,domain和path都是/,expires关闭浏览器过期.</p><p>domain表示二级域名等是否共享cookie,如果domain为cnblogs.com表示只有cnblogs.com享有此cookie,</p><p>而如果设置为.cnblogs.com(有个点),则i.cnbolgs.com,q.cnblogs.com以及全部二级域名都享受此cookie</p><p>如果设置为/,则cnblogs.com:8080也享有此cookie,应该没有没有正则的写法.</p><p>path表示目录,比如/sso,domain为cnblogs.com,只有cnblogs.com/sso目录下的页面享有此cookie</p><h1 id="普通的缺点"><a href="#普通的缺点" class="headerlink" title="普通的缺点"></a>普通的缺点</h1><p>1.微信小程序以及类似的不支持cookie</p><p>2.app的cookie关闭后就清空了(没试过)</p><p>3.安全性,https另说,没接触过</p><h1 id="oauth协议的四种模式"><a href="#oauth协议的四种模式" class="headerlink" title="oauth协议的四种模式"></a>oauth协议的四种模式</h1><p>1.授权码</p><p>2.简化</p><p>3.密码</p><p>4.客户端</p><h1 id="oath协议如何规避二中的缺点"><a href="#oath协议如何规避二中的缺点" class="headerlink" title="oath协议如何规避二中的缺点"></a>oath协议如何规避二中的缺点</h1><p>只讨论授权码和简化模式</p><p>授权码模式有1,2,3,4,5五步,最后一步发送令牌是认证服务器通过request向第三方应用的服务器发送令牌,相比简化模式更安全.</p><p>简化没有第3步,第4步,只有1,2,5三步,因为简化模式假定没有网页没有服务器控制权,用户同意授权后认证服务器发送携带令牌的response返回第三方应用的页面.</p><p>oath协议中只需要令牌,令牌是普通字符串,不涉及cookie</p><p>而且令牌可以不需要https也能操作加密.</p><p>只需要client每次发送的时候在携带令牌即可.</p><p>而且令牌可以设置成定时更新,在用户没有察觉的情况下更新令牌,更安全.</p><p>但cookie的对应的session并没有办法更改jsessionid,如果为了安全30分钟让用户重新登录一次更换jsessionid,体验不好.</p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>oauth学习</title>
      <link href="/2018/07/14/oauth%E5%AD%A6%E4%B9%A0/"/>
      <url>/2018/07/14/oauth%E5%AD%A6%E4%B9%A0/</url>
      <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>OAUTH协议为用户资源的授权提供了一个安全的、开放而又简易的标准。与以往的授权方式不同之处是OAUTH的授权不会使第三方触及到用户的帐号信息（如用户名与密码），即第三方无需使用用户的用户名与密码就可以申请获得该用户资源的授权，因此OAUTH是安全的。oAuth是Open Authorization的简写。</p><h1 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h1><ol><li>简单：不管是OAUTH服务提供者还是应用开发者，都很易于理解与使用；</li><li>安全：没有涉及到用户密钥等信息，更安全更灵活；</li><li>开放：任何服务提供商都可以实现OAUTH，任何软件开发商都可以使用OAUTH；</li></ol><h1 id="产生背景"><a href="#产生背景" class="headerlink" title="产生背景"></a>产生背景</h1><p>典型案例：如果一个用户需要两项服务：一项服务是图片在线存储服务A，另一个是图片在线打印服务B。如<br>下图所示。由于服务A与服务B是由两家不同的服务提供商提供的，所以用户在这两家服务提供商的网站上各自注册了两个用户，假设这两个用户名各不相同，密码也各不相同。当用户<br>要使用服务B打印存储在服务A上的图片时，用户该如何处理？法一：用户可能先将待打印的图片从服务A上下载下来并上传到服务B上打印，这种方式安全但处理比较繁琐，效率低下；法二：用户将在服务A上注册的用户名与密码提供给服务B，服务B使用用户的帐号再去服务A处下载待打印的图片，这种方式效率是提高了，但是安全性大大降低了，服务B可以使用用户的用户名与密码去服务A上查看甚至篡改用户的资源。<br>很多公司和个人都尝试解决这类问题，包括Google、Yahoo、Microsoft，这也促使OAUTH项目组的产生。OAuth是由Blaine Cook、Chris Messina、Larry Halff 及David Recordon共同发起的，目的在于为API访问授权提供一个开放的标准。OAuth规范的1.0版于2007年12月4日发布。</p><h1 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h1><h2 id="三个URL"><a href="#三个URL" class="headerlink" title="三个URL"></a>三个URL</h2><ul><li>Request Token URL: 获取未授权的Request Token服务地址；</li><li>User Authorization URL: 获取用户授权的Request Token服务地址；</li><li>Access Token URL: 用授权的Request Token换取Access Token的服务地址；</li></ul><h1 id="参数定义"><a href="#参数定义" class="headerlink" title="参数定义"></a>参数定义</h1><pre><code>OAUTH_consumer_key: 使用者的ID，OAUTH服务的直接使用者是开发者开发出来的应用。所以该参数值的获取一般是要去OAUTH服务提供商处注册一个应用，再获取该应用的OAUTH_consumer_key。</code></pre><p>OAUTH_consumer_secret：OAUTH_consumer_key对应的密钥。<br>OAUTH_token:OAUTH进行到最后一步得到的一个“令牌”，通过此“令牌”请求，就可以去拥有资源的网站抓取任意有权限可以被抓取的资源。<br>OAUTH_token_secret:OAUTH_token对应的私钥。<br>OAUTH_signature_method: 请求串的签名方法，应用每次向OAUTH三个服务地址发送请求时，必须对请求进行签名。签名的方法有：HMAC-SHA1、RSA-SHA1与PLAINTEXT等三种。<br>OAUTH_signature: 用上面的签名方法对请求的签名。<br>OAUTH_timestamp: 发起请求的时间戳，其值是距1970 00:00:00 GMT的秒数，必须是大于0的整数。本次请求的时间戳必须大于或者等于上次的时间戳。<br>OAUTH_nonce: 随机生成的字符串，用于防止请求的重复，防止外界的非法攻击。<br>OAUTH_version: OAUTH的版本号。</p><h1 id="响应代码"><a href="#响应代码" class="headerlink" title="响应代码"></a>响应代码</h1><p>HTTP 400 Bad Request 请求错误<br>Unsupported parameter 参数错误<br>Unsupported signature method 签名方法错误<br>Missing required parameter 参数丢失<br>Duplicated OAUTH Protocol Parameter 参数重复<br>HTTP 401 Unauthorized 未授权<br>Invalid Consumer Key 非法key<br>Invalid / expired Token 失效或者非法的token<br>Invalid signature 签名非法<br>Invalid / used nonce 非法的nonce</p><h1 id="认证流程"><a href="#认证流程" class="headerlink" title="认证流程"></a>认证流程</h1><p>获取未授权的request token<br>请求参数：<br>OAUTH_consumer_key:消费方键值。<br>OAUTH_signature_method:消费方签署本请求所用的签名方法。<br>OAUTH_signature:签名，定义于签署请求 (签署请求)。<br>OAUTH_timestamp:定义于Nonceand Timestamp (单次值与时间戳)。<br>OAUTH_nonce:定义于Nonceand Timestamp (单次值与时间戳)。<br>OAUTH_version:可选。<br>额外参数:由服务提供方定义的任意额外参数<br>服务方返回结果，响应包含如下参数：<br>OAUTH_token:请求令牌<br>OAUTH_token_secret:令牌密钥<br>附加参数:由服务提供方定义的任意参数。<br>获取用户授权的request token<br>请求参数：<br>OAUTH_token:可选。在前述步骤中获得的请求令牌。服务提供方可以声明此参数为必须，也可以允许不包含在授权URL中并提示用户手工输入。<br>OAUTH_callback:可选。消费方可以指定一个URL，当 获取用户授权 (获取用户授权)成功后，服务提供方将重定向用户到这个URL。<br>附加参数:由服务提供方定义的任意参数。<br>服务提供方将用户引导回消费方<br>如果消费方在OAUTH_callback中提供了回调URL(在消费方引导用户至服务提供方 (消费方引导用户至服务提供方)中描述)，则服务提供方构造一个HTTP GET请求URL，重定向用户浏览器到该URL，并包含如下参数：<br>OAUTH_token:被用户授权或否决的请求令牌<br>回调URL可以包含消费方提供的查询参数，服务提供方必须保持已有查询不变并追加OAUTH_token参数。<br>用授权的request token换取Access Token<br>消费方请求访问令牌参数：<br>OAUTH_consumer_key:消费方键值。<br>OAUTH_token:之前获取的请求令牌。<br>OAUTH_signature_method:消费方使用的签署方法。<br>OAUTH_signature:签署请求 (签署请求)中定义的签名。<br>OAUTH_timestamp:在单次值与时间戳 (单次值与时间戳)中定义。<br>OAUTH_nonce:在单次值与时间戳 (单次值与时间戳)中定义。<br>OAUTH_version:版本号，可选。<br>返回参数：<br>OAUTH_token:访问令牌。<br>OAUTH_token_secret:令牌密钥。<br>访问受保护资源<br>请求参数：<br>OAUTH_consumer_key:消费方键值。<br>OAUTH_token:访问令牌。<br>OAUTH_signature_method:消费方使用的签署方法。<br>OAUTH_signature:签署请求 (签署请求)中定义的签名。<br>OAUTH_timestamp:定义于单次值与时间戳 (单次值与时间戳).<br>OAUTH_nonce:定义于单次值与时间戳 (单次值与时间戳).<br>OAUTH_version:版本号，可选。<br>附加参数:服务提供方指定的附加参数。</p><h1 id="授权流程"><a href="#授权流程" class="headerlink" title="授权流程"></a>授权流程</h1><p>在弄清楚了OAUTH的术语后，我们可以对OAUTH认证授权的流程进行初步认识。其实，简单的来说，<br>OAUTH认证授权就三个步骤，三句话可以概括：</p><ol><li>获取未授权的Request Token</li><li>获取用户授权的Request Token</li><li>用授权的Request Token换取Access Token<br>当应用拿到Access Token后，就可以有权访问用户授权的资源了。大家可能看出来了，这三个步骤不就是对应OAUTH的三个URL服务地址嘛。一点没错，上面的三个步骤中，每个步骤分别请求一个URL，并且收到相关信息，并且拿到上步的相关信息去请求接下来的URL直到拿到Access Token。<br>具体每步执行信息如下：<br>A. 使用者（第三方软件）向OAUTH服务提供商请求未授权的Request Token。向Request Token URL发起请求，请求需要带上的参数见上图。<br>B. OAUTH服务提供商同意使用者的请求，并向其颁发未经用户授权的oauth_token与对应的oauth_token_secret，并返回给使用者。<br>C. 使用者向OAUTH服务提供商请求用户授权的Request Token。向User Authorization URL发起请求，请求带上上步拿到的未授权的token与其密钥。<br>D. OAUTH服务提供商将引导用户授权。该过程可能会提示用户，你想将哪些受保护的资源授权给该应用。此步可能会返回授权的Request Token也可能不返回。如Yahoo OA<br>OAUTH流程<br>OAUTH流程<br>UTH就不会返回任何信息给使用者。<br>E. Request Token 授权后，使用者将向Access Token URL发起请求，将上步授权的Request Token换取成Access Token。请求的参数见上图，这个比第一步A多了一个参数就是Request Token。<br>F. OAUTH服务提供商同意使用者的请求，并向其颁发Access Token与对应的密钥，并返回给使用者。<br>G. 使用者以后就可以使用上步返回的Access Token访问用户授权的资源。<br>从上面的步骤可以看出，用户始终没有将其用户名与密码等信息提供给使用者（第三方软件），从而更安全。用OAUTH实现背景一节中的典型案例：当服务B（打印服务）要访问用户的服务A（图片服务）时，通过OAUTH机制，服务B向服务A请求未经用户授权的Request Token后，服务A将引导用户在服务A的网站上登录，并询问用户是否将图片服务授权给服务B。用户同意后，服务B就可以访问用户在服务A上的图片服务。整个过程服务B没有触及到用户在服务A的帐号信息。如下图所示，图中的字母对应OAUTH流程中的字母：</li></ol><h1 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h1><p>OAuth Core 1.0 版本发布于2007年12月4日，由于存在可被会话定向攻击(session fixation attack)的缘故，2009年6月24日发布了OAuth Core 1.0 Revision A 版本。最终在2010年4月，OAuth成为了RFC标准： RFC 5849: The OAuth 1.0 Protocol。<br>OAuth 2.0的草案是在2010年5月初在IETF发布的。OAuth 2.0是OAuth协议的下一版本，但不向后兼容OAuth 1.0。 OAuth 2.0关注客户端开发者的简易性，同时为Web应用，桌面应用和手机，和起居室设备提供专门的认证流程。规范还在IETF OAuth工作组的开发中，按照Eran Hammer-Lahav的说法，OAuth于2010年末完成。</p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>socket</title>
      <link href="/2018/07/13/socket/"/>
      <url>/2018/07/13/socket/</url>
      <content type="html"><![CDATA[<h1 id="telnet"><a href="#telnet" class="headerlink" title="telnet"></a>telnet</h1><p>win10的telnet已经阉割了，搞不懂弄个telnet客户端出来，有没有服务端，连接就报23端口错误。<br>用Xshell作telent连接</p><h1 id="传统socket"><a href="#传统socket" class="headerlink" title="传统socket"></a>传统socket</h1><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><h3 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h3><p>server.accept();<br>inputStream.read(bytes);</p><h3 id="每个连接都占用一个线程，浪费性能"><a href="#每个连接都占用一个线程，浪费性能" class="headerlink" title="每个连接都占用一个线程，浪费性能"></a>每个连接都占用一个线程，浪费性能</h3><h1 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>ServerSocketChannel    ServerSocket</p><p>SocketChannel        Socket</p><p>Selector</p><p>SelectionKey</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>单线程为多个客户端服务</p><h2 id="select（）"><a href="#select（）" class="headerlink" title="select（）"></a>select（）</h2><p>C写的</p><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="客户端关闭的时候会抛出异常，死循环"><a href="#客户端关闭的时候会抛出异常，死循环" class="headerlink" title="客户端关闭的时候会抛出异常，死循环"></a>客户端关闭的时候会抛出异常，死循环</h3><p>解决方案</p><pre><code>    int read = channel.read(buffer);    if(read &gt; 0){v          //回写数据        ByteBuffer outBuffer = ByteBuffer.wrap(&quot;好的&quot;.getBytes());        channel.write(outBuffer);// 将消息回送给客户端    }else{        System.out.println(&quot;客户端关闭&quot;);        key.cancel();    }</code></pre><h3 id="selector-select-阻塞，那为什么说nio是非阻塞的IO？"><a href="#selector-select-阻塞，那为什么说nio是非阻塞的IO？" class="headerlink" title="selector.select();阻塞，那为什么说nio是非阻塞的IO？"></a>selector.select();阻塞，那为什么说nio是非阻塞的IO？</h3><pre><code>selector.select()selector.select(1000); 限时阻塞selector.wakeup();也可以唤醒selectorselector.selectNow();也可以立马返还，视频里忘了讲了，哈，这里补上</code></pre><h3 id="SelectionKey-OP-WRITE是代表什么意思"><a href="#SelectionKey-OP-WRITE是代表什么意思" class="headerlink" title="SelectionKey.OP_WRITE是代表什么意思"></a>SelectionKey.OP_WRITE是代表什么意思</h3><p>OP_WRITE表示底层缓冲区是否有空间，是则响应返还true</p><h1 id="netty"><a href="#netty" class="headerlink" title="netty"></a>netty</h1><h2 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h2><pre><code>3.x 4.x 5.x ，5.x 已经被废弃了。</code></pre><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><h3 id="分布式进程通信"><a href="#分布式进程通信" class="headerlink" title="分布式进程通信"></a>分布式进程通信</h3><p>例如: hadoop、dubbo、akka等具有分布式功能的框架，底层RPC通信都是基于netty实现的，这些框架使用的版本通常都还在用netty3.x</p><h3 id="游戏服务器开发"><a href="#游戏服务器开发" class="headerlink" title="游戏服务器开发"></a>游戏服务器开发</h3><p>最新的游戏服务器有部分公司可能已经开始采用netty4.x 或 netty5.x</p><h2 id="netty服务端hello-world案例"><a href="#netty服务端hello-world案例" class="headerlink" title="netty服务端hello world案例"></a>netty服务端hello world案例</h2><pre><code>SimpleChannelHandler 处理消息接收和写{    messageReceived接收消息    channelConnected新连接，通常用来检测IP是否是黑名单    channelDisconnected链接关闭，可以再用户断线的时候清楚用户的缓存数据等}</code></pre><h2 id="netty客户端hello-world案例"><a href="#netty客户端hello-world案例" class="headerlink" title="netty客户端hello world案例"></a>netty客户端hello world案例</h2><p>channelDisconnected与channelClosed的区别？</p><p>channelDisconnected只有在连接建立后断开才会调用</p><p>channelClosed无论连接是否成功都会调用关闭资源</p><h1 id="channelDisconnected与channelClosed的区别"><a href="#channelDisconnected与channelClosed的区别" class="headerlink" title="channelDisconnected与channelClosed的区别"></a>channelDisconnected与channelClosed的区别</h1><p>channelDisconnected只有在连接建立后断开才会调用</p><p>channelClosed无论连接是否成功都会调用关闭资源</p><h1 id="Netty源码分析"><a href="#Netty源码分析" class="headerlink" title="Netty源码分析"></a>Netty源码分析</h1>]]></content>
      
      
        <tags>
            
            <tag> Socket </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>BlockingQueue</title>
      <link href="/2018/07/12/BlockingQueue/"/>
      <url>/2018/07/12/BlockingQueue/</url>
      <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>线程之间的数据共享。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><ul><li>ArrayBlockingQueue:适合做有界队列</li><li>LinkedListBlockingQueue：适合做无界队列，或者边界值非常大的队列</li></ul><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>关键在于Blocking</p><p>压入元素用</p><ul><li>offer（） 如果满了直接返回false</li><li>put（） 满了就等待，直到队列中有空闲位置</li></ul><p>弹出元素用</p><ul><li>poll（）空了直接返回null</li><li>take（） 空了就等待</li></ul>]]></content>
      
      
        <tags>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>线程池</title>
      <link href="/2018/07/12/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
      <url>/2018/07/12/%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
      <content type="html"><![CDATA[<pre><code>@startumlExecutorService--up-|&gt;ExecutorScheduledExecutorService-up-|&gt;ExecutorServiceAbstractExecutorService..-left-|&gt;ExecutorServiceThreadPoolExecutor-left-|&gt;AbstractExecutorServiceExecutors ..up-&gt; AbstractExecutorService@enduml</code></pre><img src="/2018/07/12/线程池/pool-class.png" title="pool-class"><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>任何Runnable对象都可以被ThreadPoolExecutor调用</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><ol><li>newFixedThreadPool  </li><li>newSignleThreadExecutor</li><li>newCachedThreadPool</li><li>newSingleThreadScheduledExecutor</li><li>newScheduledThreadPool</li></ol><h2 id="内部实现"><a href="#内部实现" class="headerlink" title="内部实现"></a>内部实现</h2><p>ThreadPoolExecutor(corePoolSize,maxmumPoolSize，keepAliveTime，unit，workQueue，threadFactory,handler)</p><ul><li>corePoolSize：暂时理解为线程池的初始线程数量。</li><li>maxmumPoolSize：线程池最大线程数量</li><li>keepAliveTime：因为线程池数量最大可以到maxPoolSize,当线程池线程数量超过corePoolSize时，多余的线程可以存活的时间。</li><li>workerQueue:是指被提交但未执行的任务队列，它是一个BlockingQueue接口的对象。可以使用一下几种BlockingQueue</li></ul><h3 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h3><p>一个特殊的BlockingQueue,没有容量，提交的任务不会被真实保存，而总是将新任务提供给线程执行。<br>如果线程数量大于max，执行拒绝策略</p><h3 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h3><p>有界的任务队列，构造函数包括容量。有新的任务需要执行，如果线程池实际任务数的coresize，会优先创建新的线程。如果大于coolPoolSize,新任务加入等待队列。如果等待队列已满，在总线程数不超过maximumPoolSize情况下，</p><h3 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h3><p>无界，</p>]]></content>
      
      
        <tags>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>读写锁</title>
      <link href="/2018/07/12/%E8%AF%BB%E5%86%99%E9%94%81/"/>
      <url>/2018/07/12/%E8%AF%BB%E5%86%99%E9%94%81/</url>
      <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>只有读读非阻塞</p><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>读远大于写</p>]]></content>
      
      
        <tags>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>信号量</title>
      <link href="/2018/07/12/%E4%BF%A1%E5%8F%B7%E9%87%8F/"/>
      <url>/2018/07/12/%E4%BF%A1%E5%8F%B7%E9%87%8F/</url>
      <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>信号量允许多个线程同时访问</p><h2 id="提供方法"><a href="#提供方法" class="headerlink" title="提供方法"></a>提供方法</h2><ul><li>acquire</li><li>acquireUninterruptibly</li><li>tryAcquire</li><li>tryAcquire（timeout，timeunit）</li></ul>]]></content>
      
      
    </entry>
    
    <entry>
      <title>重入锁</title>
      <link href="/2018/07/12/%E9%87%8D%E5%85%A5%E9%94%81/"/>
      <url>/2018/07/12/%E9%87%8D%E5%85%A5%E9%94%81/</url>
      <content type="html"><![CDATA[<h1 id="重入锁的特性"><a href="#重入锁的特性" class="headerlink" title="重入锁的特性"></a>重入锁的特性</h1><h2 id="中断响应"><a href="#中断响应" class="headerlink" title="中断响应"></a>中断响应</h2><p>lockInterruptibly()<br>可以在死锁的时候检测超时，中断其中一个。</p><h2 id="tryLock锁申请等待限时"><a href="#tryLock锁申请等待限时" class="headerlink" title="tryLock锁申请等待限时"></a>tryLock锁申请等待限时</h2><p>申请一个锁，如果超时申请不到，返回false</p><p>TryLock也可以不带时间参数，如果这个锁被占用了，那就直接返回false，不再申请</p><h2 id="可创建公平锁"><a href="#可创建公平锁" class="headerlink" title="可创建公平锁"></a>可创建公平锁</h2><p>使用带boolean参数的构造方法</p>]]></content>
      
      
        <tags>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>MySQL组合索引的注意点</title>
      <link href="/2018/07/11/MySQL%E7%BB%84%E5%90%88%E7%B4%A2%E5%BC%95%E7%9A%84%E6%B3%A8%E6%84%8F%E7%82%B9/"/>
      <url>/2018/07/11/MySQL%E7%BB%84%E5%90%88%E7%B4%A2%E5%BC%95%E7%9A%84%E6%B3%A8%E6%84%8F%E7%82%B9/</url>
      <content type="html"><![CDATA[<p>经常使用MySQL组合索引，也经常发现，其实匹配程度并不高，尤其是条件组合非常多的时候。<br>其实使用组合索引有这些注意点的：</p><p>比如这个索引 key(last_name, first_name, dob)<br>如果想使用索引，你必须保证按索引的最左边前缀(leftmost prefix of the index)来进行查询。</p><h3 id="匹配全值-Match-the-full-value"><a href="#匹配全值-Match-the-full-value" class="headerlink" title="匹配全值(Match the full value)"></a>匹配全值(Match the full value)</h3><p>对索引中的所有列都指定具体的值。<br>即所有条件都是等于，并且全部匹配，有不等于就用不到组合索引了</p><h3 id="匹配最左前缀-Match-a-leftmost-prefix"><a href="#匹配最左前缀-Match-a-leftmost-prefix" class="headerlink" title="匹配最左前缀(Match a leftmost prefix)"></a>匹配最左前缀(Match a leftmost prefix)</h3><p>仅仅使用索引中的第1列。<br>即索引中的最左边的用等于条件。</p><h3 id="匹配列前缀-Match-a-column-prefix"><a href="#匹配列前缀-Match-a-column-prefix" class="headerlink" title="匹配列前缀(Match a column prefix)"></a>匹配列前缀(Match a column prefix)</h3><p>这仅仅使用索引中的第1列。<br>即’X%’</p><h3 id="匹配值的范围查询-Match-a-range-of-values-：仅仅使用索引中第1列。"><a href="#匹配值的范围查询-Match-a-range-of-values-：仅仅使用索引中第1列。" class="headerlink" title="匹配值的范围查询(Match a range of values)：仅仅使用索引中第1列。"></a>匹配值的范围查询(Match a range of values)：仅仅使用索引中第1列。</h3><p>即第一列 可以用大于 小于 X&gt;0 and X&lt;1</p><h3 id="匹配部分精确而其它部分进行范围匹配-Match-one-part-exactly-and-match-a-range-on-another-part"><a href="#匹配部分精确而其它部分进行范围匹配-Match-one-part-exactly-and-match-a-range-on-another-part" class="headerlink" title="匹配部分精确而其它部分进行范围匹配(Match one part exactly and match a range on another part)"></a>匹配部分精确而其它部分进行范围匹配(Match one part exactly and match a range on another part)</h3><p>可以利用索引查找last name为Allen，而first name以字母K开始的人。<br>即，第一列 精确匹配，后面一列 范围匹配</p><h3 id="仅对索引进行查询-Index-only-queries-：如果查询的列都位于索引中，则不需要读取元组的值。"><a href="#仅对索引进行查询-Index-only-queries-：如果查询的列都位于索引中，则不需要读取元组的值。" class="headerlink" title="仅对索引进行查询(Index-only queries)：如果查询的列都位于索引中，则不需要读取元组的值。"></a>仅对索引进行查询(Index-only queries)：如果查询的列都位于索引中，则不需要读取元组的值。</h3><p>由于B-树中的节点都是顺序存储的，所以可以利用索引进行查找(找某些值)，也可以对查询结果进行ORDER BY。</p><p>当然，使用B-tree索引有以下一些限制：<br>(1) 查询必须从索引的最左边的列开始。关于这点已经提了很多遍了。例如你不能利用索引查找在某一天出生的人。<br>(2) 不能跳过某一索引列。例如，你不能利用索引查找last name为Smith且出生于某一天的人。<br>(3) 存储引擎不能使用索引中范围条件右边的列。例如，如果你的查询语句为WHERE last_name=”Smith” AND first_name LIKE ‘J%’ AND dob=’1976-12-23′，则该查询只会使用索引中的前两列，因为LIKE是范围查询。</p><p>总结出来就是，使用了组合索引以后，你必须要从左到右依次精确匹配索引，能匹配多少匹配多少，直到最后一个可以匹配范围索引，只要用了某列范围索引，后面的列的索引就无效了。。所以组合索引虽好，但必须要用巧。条件并不能随便给的。</p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>聚簇索引和非聚簇索引原理</title>
      <link href="/2018/07/11/%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E5%92%8C%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86/"/>
      <url>/2018/07/11/%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E5%92%8C%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86/</url>
      <content type="html"><![CDATA[]]></content>
      
      
    </entry>
    
    <entry>
      <title>mysql的聚集索引和非聚集索引</title>
      <link href="/2018/07/11/mysql%E7%9A%84%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95%E5%92%8C%E9%9D%9E%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95/"/>
      <url>/2018/07/11/mysql%E7%9A%84%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95%E5%92%8C%E9%9D%9E%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95/</url>
      <content type="html"><![CDATA[<h2 id="MYSQL的索引"><a href="#MYSQL的索引" class="headerlink" title="MYSQL的索引"></a>MYSQL的索引</h2><p>mysql中，不同的存储引擎对索引的实现方式不同，大致说下MyISAM和InnoDB两种存储引擎。<br>MyISAM的B+Tree的叶子节点上的data，并不是数据本身，而是数据存放的地址。主索引和辅助索引没啥区别，只是主索引中的key一定得是唯一的。这里的索引都是非聚簇索引。<br>MyISAM还采用压缩机制存储索引，比如，第一个索引为“her”，第二个索引为“here”，那么第二个索引会被存储为“3,e”，这样的缺点是同一个节点中的索引只能采用顺序查找。</p><p>InnoDB的数据文件本身就是索引文件，B+Tree的叶子节点上的data就是数据本身，key为主键，这是聚簇索引。非聚簇索引，叶子节点上的data是主键(所以聚簇索引的key，不能过长)。为什么存放的主键，而不是记录所在地址呢，理由相当简单，因为记录所在地址并不能保证一定不会变，但主键可以保证。<br>至于为什么主键通常建议使用自增id呢？</p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>mySQL索引</title>
      <link href="/2018/07/11/mySQL%E7%B4%A2%E5%BC%95/"/>
      <url>/2018/07/11/mySQL%E7%B4%A2%E5%BC%95/</url>
      <content type="html"><![CDATA[<h2 id="Mysql索引的结构"><a href="#Mysql索引的结构" class="headerlink" title="Mysql索引的结构"></a>Mysql索引的结构</h2><h3 id="Hash索引"><a href="#Hash索引" class="headerlink" title="Hash索引"></a>Hash索引</h3><p>mysql中，只有Memory(Memory表只存在内存中，断电会消失，适用于临时表)存储引擎显示支持Hash索引，是Memory表的默认索引类型，尽管Memory表也可以使用B+Tree索引。Hash索引把数据以hash形式组织起来，因此当查找某一条记录的时候，速度非常快。但是因为hash结构，每个键只对应一个值，而且是散列的方式分布。所以它并不支持范围查找和排序等功能。</p><h3 id="B-Tree索引"><a href="#B-Tree索引" class="headerlink" title="B+Tree索引"></a>B+Tree索引</h3><p>B+Tree是mysql使用最频繁的一个索引数据结构，是Inodb和Myisam存储引擎模式的索引类型。相对Hash索引，B+Tree在查找单条记录的速度比不上Hash索引，但是因为更适合排序等操作，所以它更受欢迎。毕竟不可能只对数据库进行单条记录的操作。</p><p>带顺序访问指针的B+Tree</p><p>B+Tree所有索引数据都在叶子节点上，并且增加了顺序访问指针，每个叶子节点都有指向相邻叶子节点的指针。</p><p>这样做是为了提高区间效率，例如查询key为从18到49的所有数据记录，当找到18后，只要顺着节点和指针顺序遍历就可以以此向访问到所有数据节点，极大提高了区间查询效率。</p><p>大大减少磁盘I/O读取</p><p>数据库系统的设计者巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点需要一次I/O就可以完全载入。</p><h2 id="二、选择索引的数据类型"><a href="#二、选择索引的数据类型" class="headerlink" title="二、选择索引的数据类型"></a>二、选择索引的数据类型</h2><p>Mysql支持很多数据类型，选择合适的数据类型存储数据对性能有很大的影响。</p><p>(1)越小的数据类型通常更好：越小的数据类型通常在磁盘、内存和cpu缓存中都需要更少的空间，处理起来更快。</p><p>(2)简单的数据类型更好：整形数据比起字符，处理开销更小，因为字符串的比较更复杂。在MySQL中，应用内置的日期和时间数据类型，而不是字符串来存储时间；以及用整形数据存储IP地址。</p><p>(3)尽量避免NULL：应该制定列为NOT NULL，除非你想存储NULL。在MySQL中，含有空值的列很难进行查询优化，因为他们使得索引、索引的统计信息以及比较运算更加复杂。</p><h2 id="三、MySQL常见索引有：主键索引、唯一索引、普通索引、全文索引、组合索引"><a href="#三、MySQL常见索引有：主键索引、唯一索引、普通索引、全文索引、组合索引" class="headerlink" title="三、MySQL常见索引有：主键索引、唯一索引、普通索引、全文索引、组合索引"></a>三、MySQL常见索引有：主键索引、唯一索引、普通索引、全文索引、组合索引</h2><h3 id="INDEX（普通索引）"><a href="#INDEX（普通索引）" class="headerlink" title="INDEX（普通索引）"></a>INDEX（普通索引）</h3><p>ALTER TABLE ‘table_name’ ADD INDEX index_name(‘col’)</p><p>最基本的索引，没有任何限制</p><h3 id="UNIQUE（唯一索引）：ALTER-TABLE-‘table-name’-ADD-UNIQUE-‘col’"><a href="#UNIQUE（唯一索引）：ALTER-TABLE-‘table-name’-ADD-UNIQUE-‘col’" class="headerlink" title="UNIQUE（唯一索引）：ALTER TABLE ‘table_name’ ADD UNIQUE(‘col’)"></a>UNIQUE（唯一索引）：ALTER TABLE ‘table_name’ ADD UNIQUE(‘col’)</h3><p>与“普通索引”类似，不同的就是：索引列的值必须唯一，但允许有空值。</p><h3 id="PRIMARY-KEY（主键索引）"><a href="#PRIMARY-KEY（主键索引）" class="headerlink" title="PRIMARY KEY（主键索引）"></a>PRIMARY KEY（主键索引）</h3><p>ALTER TABLE ‘table_name’ ADD PRIMARY KEY(‘col’)</p><p>是一种特殊的唯一索引，不允许有空值。</p><h3 id="FULLTEXT（全文索引）"><a href="#FULLTEXT（全文索引）" class="headerlink" title="FULLTEXT（全文索引）"></a>FULLTEXT（全文索引）</h3><p>ALTER TABLE ‘table_name’ ADD FULLTEXT(‘col’)</p><p>仅可用于MyISAM和InoDB，针对较大的数据，生成全文索引很耗时耗空间</p><p>组合索引：ALTER TABLE ‘table_name’ ADD INDEX index_name(‘col1’,’col2’,’col3’)</p><p>为了更多的提高mysql效率可建立组合索引，遵循“最左前缀”原则。创建复合索引应该将最常用（频率）做限制条件的列放在最左边，一次递减。组合索引最左字段用in是可以用到索引的。相当于建立了col1,col1col2,col1col2col3三个索引</p><h2 id="四，索引使用注意事项"><a href="#四，索引使用注意事项" class="headerlink" title="四，索引使用注意事项"></a>四，索引使用注意事项</h2><h3 id="不要滥用索引"><a href="#不要滥用索引" class="headerlink" title="不要滥用索引"></a>不要滥用索引</h3><p>索引提高查询速度，却会降低更新表的速度，因为更新表时，mysql不仅要更新数据，保存数据，还要更新索引，保存索引，索引会占用磁盘空间</p><h3 id="索引不会包含含有NULL值的列"><a href="#索引不会包含含有NULL值的列" class="headerlink" title="索引不会包含含有NULL值的列"></a>索引不会包含含有NULL值的列</h3><p>复合索引只要有一列含有NULL值,那么这一列对于此符合索引就是无效的，因此我们在设计数据库设计时不要让字段的默认值为NULL。</p><h3 id="MySQL查询只是用一个索引"><a href="#MySQL查询只是用一个索引" class="headerlink" title="MySQL查询只是用一个索引"></a>MySQL查询只是用一个索引</h3><p>如果where字句中使用了索引的话，那么order by中的列是不会使用索引的</p><h3 id="like"><a href="#like" class="headerlink" title="like"></a>like</h3><p>like ‘%aaa%’不会使用索引而like “aaa%”可以使用索引</p><h3 id="in"><a href="#in" class="headerlink" title="in"></a>in</h3><p>not in可能会使用索引失效，使用left join或者exist进行代替<br>in相比or可以更有效利用索引</p><h1 id="优化策略（一）"><a href="#优化策略（一）" class="headerlink" title="优化策略（一）"></a>优化策略（一）</h1><ul><li>使用覆盖索引 extra中using index表示用到了覆盖索引</li><li>order by用索引，要顺序一致，排序方向和索引一致</li><li>一般在in中的子查询，不包含group by，order by，union等，子查询会产生临时表，用不到索引。</li><li>不会有重复值的时候使用union all而不是union，union会把所有数据放到临时表中在进行去重操作。</li><li>大批量写操作可能造成严重的主从延迟。</li><li>大表结构修改用pt-online-schema-change修改表结构。避免主从延迟以及表锁时间长的问题</li><li>禁止为程序使用的账号使用super权限，当达到最大连接数时，只允许再多一个super权限的用户连接。</li><li></li></ul>]]></content>
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>ElasticSearch面试</title>
      <link href="/2018/07/11/ElasticSearch%E9%9D%A2%E8%AF%95/"/>
      <url>/2018/07/11/ElasticSearch%E9%9D%A2%E8%AF%95/</url>
      <content type="html"><![CDATA[<h2 id="一、Elasticsearch监控的常用工具"><a href="#一、Elasticsearch监控的常用工具" class="headerlink" title="一、Elasticsearch监控的常用工具"></a>一、Elasticsearch监控的常用工具</h2><ol><li><p>bigdesk 统计分析和图表化elasticsearch的集群信息状态<br><a href="http://blog.csdn.net/yangwenbo214/article/details/74000458" target="_blank" rel="noopener">http://blog.csdn.net/yangwenbo214/article/details/74000458</a></p></li><li><p>head 能清晰看到每个分片的信息、发送rest api请求。注意安装版本要求<br><a href="https://github.com/mobz/elasticsearch-head" target="_blank" rel="noopener">https://github.com/mobz/elasticsearch-head</a></p></li><li><p>marvel 5.*版本后集成到x-pack中了，是收费的<br><a href="https://www.elastic.co/guide/en/x-pack/current/xpack-introduction.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/x-pack/current/xpack-introduction.html</a></p></li><li><p>kopf 也是web形式，有点像head<br><a href="https://github.com/lmenezes/elasticsearch-kopf" target="_blank" rel="noopener">https://github.com/lmenezes/elasticsearch-kopf</a></p></li></ol><p>一般head和x-pack比较常用。head的安装在5.*中比较繁琐，需要注意</p><h2 id="二、Elasticsearch是如何实现Master选举的"><a href="#二、Elasticsearch是如何实现Master选举的" class="headerlink" title="二、Elasticsearch是如何实现Master选举的"></a>二、Elasticsearch是如何实现Master选举的</h2><p>Elasticsearch的选主是ZenDiscovery模块负责的，主要包含Ping（节点之间通过这个RPC来发现彼此）和Unicast（单播模块包含一个主机列表以控制哪些节点需要ping通）这两部分；</p><p>对所有可以成为master的节点（node.master: true）根据nodeId字典排序，每次选举每个节点都把自己所知道节点排一次序，然后选出第一个（第0位）节点，暂且认为它是master节点。</p><p>如果对某个节点的投票数达到一定的值（可以成为master节点数n/2+1）并且该节点自己也选举自己，那这个节点就是master。否则重新选举一直到满足上述条件。</p><p>master节点的职责主要包括集群、节点和索引的管理，不负责文档级别的管理；data节点可以关闭http功能。</p><h3 id="三、Elasticsearch是如何避免脑裂现象的"><a href="#三、Elasticsearch是如何避免脑裂现象的" class="headerlink" title="三、Elasticsearch是如何避免脑裂现象的"></a>三、Elasticsearch是如何避免脑裂现象的</h3>]]></content>
      
      
        <tags>
            
            <tag> ES </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>redis面试题</title>
      <link href="/2018/07/11/redis%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2018/07/11/redis%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      <content type="html"><![CDATA[<h2 id="Redis有哪些数据结构？"><a href="#Redis有哪些数据结构？" class="headerlink" title="Redis有哪些数据结构？"></a>Redis有哪些数据结构？</h2><p>字符串String、字典Hash、列表List、集合Set、有序集合SortedSet。</p><p>如果你是Redis中高级用户，还需要加上下面几种数据结构HyperLogLog、Geo、Pub/Sub。</p><p>如果你说还玩过Redis Module，像BloomFilter，RedisSearch，Redis-ML，面试官得眼睛就开始发亮了。</p><h2 id="使用过Redis分布式锁么，它是什么回事？"><a href="#使用过Redis分布式锁么，它是什么回事？" class="headerlink" title="使用过Redis分布式锁么，它是什么回事？"></a>使用过Redis分布式锁么，它是什么回事？</h2><p>先拿setnx来争抢锁，抢到之后，再用expire给锁加一个过期时间防止锁忘记了释放。</p><p>这时候对方会告诉你说你回答得不错，然后接着问如果在setnx之后执行expire之前进程意外crash或者要重启维护了，那会怎么样？</p><p>这时候你要给予惊讶的反馈：唉，是喔，这个锁就永远得不到释放了。紧接着你需要抓一抓自己得脑袋，故作思考片刻，好像接下来的结果是你主动思考出来的，然后回答：我记得set指令有非常复杂的参数，这个应该是可以同时把setnx和expire合成一条指令来用的！对方这时会显露笑容，心里开始默念：摁，这小子还不错。</p><h2 id="假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？"><a href="#假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？" class="headerlink" title="假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？"></a>假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？</h2><p>使用keys指令可以扫出指定模式的key列表。</p><p>对方接着追问：如果这个redis正在给线上的业务提供服务，那使用keys指令会有什么问题？</p><p>这个时候你要回答redis关键的一个特性：redis的单线程的。keys指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。这个时候可以使用scan指令，scan指令可以无阻塞的提取出指定模式的key列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用keys指令长。</p><h2 id="使用过Redis做异步队列么，你是怎么用的？"><a href="#使用过Redis做异步队列么，你是怎么用的？" class="headerlink" title="使用过Redis做异步队列么，你是怎么用的？"></a>使用过Redis做异步队列么，你是怎么用的？</h2><p>一般使用list结构作为队列，rpush生产消息，lpop消费消息。当lpop没有消息的时候，要适当sleep一会再重试。</p><p>如果对方追问可不可以不用sleep呢？list还有个指令叫blpop，在没有消息的时候，它会阻塞住直到消息到来。</p><p>如果对方追问能不能生产一次消费多次呢？使用pub/sub主题订阅者模式，可以实现1:N的消息队列。</p><p>如果对方追问pub/sub有什么缺点？在消费者下线的情况下，生产的消息会丢失，得使用专业的消息队列如rabbitmq等。</p><h2 id="redis如何实现延时队列？"><a href="#redis如何实现延时队列？" class="headerlink" title="redis如何实现延时队列？"></a>redis如何实现延时队列？</h2><p>使用sortedset，拿时间戳作为score，消息内容作为key调用zadd来生产消息，消费者用zrangebyscore指令获取N秒之前的数据轮询进行处理。</p><p>##如果有大量的key需要设置同一时间过期，一般需要注意什么？</p><p>如果大量的key过期时间设置的过于集中，到过期的那个时间点，redis可能会出现短暂的卡顿现象。一般需要在时间上加一个随机值，使得过期时间分散一些。</p><h2 id="Redis如何做持久化的？"><a href="#Redis如何做持久化的？" class="headerlink" title="Redis如何做持久化的？"></a>Redis如何做持久化的？</h2><p>bgsave做镜像全量持久化，aof做增量持久化。因为bgsave会耗费较长时间，不够实时，在停机的时候会导致大量丢失数据，所以需要aof来配合使用。在redis实例重启时，会使用bgsave持久化文件重新构建内存，再使用aof重放近期的操作指令来实现完整恢复重启之前的状态。</p><h3 id="如果突然机器掉电会怎样"><a href="#如果突然机器掉电会怎样" class="headerlink" title="如果突然机器掉电会怎样"></a>如果突然机器掉电会怎样</h3><p>取决于aof日志sync属性的配置，如果不要求性能，在每条写指令时都sync一下磁盘，就不会丢失数据。但是在高性能的要求下每次都sync是不现实的，一般都使用定时sync，比如1s1次，这个时候最多就会丢失1s的数据。</p><h2 id="bgsave的原理是什么？"><a href="#bgsave的原理是什么？" class="headerlink" title="bgsave的原理是什么？"></a>bgsave的原理是什么？</h2><p>fork和cow。fork是指redis通过创建子进程来进行bgsave操作，cow指的是copy on write，子进程创建后，父子进程共享数据段，父进程继续提供读写服务，写脏的页面数据会逐渐和子进程分离开来。</p><h2 id="Pipeline有什么好处，为什么要用pipeline？"><a href="#Pipeline有什么好处，为什么要用pipeline？" class="headerlink" title="Pipeline有什么好处，为什么要用pipeline？"></a>Pipeline有什么好处，为什么要用pipeline？</h2><p>可以将多次IO往返的时间缩减为一次，前提是pipeline执行的指令之间没有因果相关性。使用redis-benchmark进行压测的时候可以发现影响redis的QPS峰值的一个重要因素是pipeline批次指令的数目。</p><h2 id="Redis的同步机制了解么？"><a href="#Redis的同步机制了解么？" class="headerlink" title="Redis的同步机制了解么？"></a>Redis的同步机制了解么？</h2><p>Redis可以使用主从同步，从从同步。第一次同步时，主节点做一次bgsave，并同时将后续修改操作记录到内存buffer，待完成后将rdb文件全量同步到复制节点，复制节点接受完成后将rdb镜像加载到内存。加载完成后，再通知主节点将期间修改的操作记录同步到复制节点进行重放就完成了同步过程。</p><h2 id="是否使用过Redis集群，集群的原理是什么？"><a href="#是否使用过Redis集群，集群的原理是什么？" class="headerlink" title="是否使用过Redis集群，集群的原理是什么？"></a>是否使用过Redis集群，集群的原理是什么？</h2><p>Redis Sentinal着眼于高可用，在master宕机时会自动将slave提升为master，继续提供服务。</p><p>Redis Cluster着眼于扩展性，在单个redis内存不足时，使用Cluster进行分片存储。</p><h2 id="什么是redis"><a href="#什么是redis" class="headerlink" title="什么是redis?"></a>什么是redis?</h2><p>Redis 是一个基于内存的高性能key-value数据库。 </p><h2 id="Reids的特点"><a href="#Reids的特点" class="headerlink" title="Reids的特点　"></a>Reids的特点　</h2><p>　Redis本质上是一个Key-Value类型的内存数据库，很像memcached，整个数据库统统加载在内存当中进行操作，定期通过异步操作把数据库数据flush到硬盘上进行保存。因为是纯内存操作，Redis的性能非常出色，每秒可以处理超过 10万次读写操作，是已知性能最快的Key-Value DB。</p><p>Redis的出色之处不仅仅是性能，Redis最大的魅力是支持保存多种数据结构，此外单个value的最大限制是1GB，不像 memcached只能保存1MB的数据，因此Redis可以用来实现很多有用的功能，比方说用他的List来做FIFO双向链表，实现一个轻量级的高性 能消息队列服务，用他的Set可以做高性能的tag系统等等。另外Redis也可以对存入的Key-Value设置expire时间，因此也可以被当作一 个功能加强版的memcached来用。</p><p>Redis的主要缺点是数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，因此Redis适合的场景主要局限在较小数据量的高性能操作和运算上。</p><h2 id="使用redis有哪些好处？"><a href="#使用redis有哪些好处？" class="headerlink" title="使用redis有哪些好处？ 　　"></a>使用redis有哪些好处？ 　　</h2><ol><li>速度快，因为数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1) </li><li>支持丰富数据类型，支持string，list，set，sorted set，hash,hyperloglog,sub/pub,geo等</li><li>支持事务，操作都是原子性，所谓的原子性就是对数据的更改要么全部执行，要么全部不执行 </li><li>丰富的特性：可用于缓存，消息，按key设置过期时间，过期后将会自动删除</li></ol><h2 id="redis相比memcached有哪些优势？"><a href="#redis相比memcached有哪些优势？" class="headerlink" title="redis相比memcached有哪些优势？ 　　"></a>redis相比memcached有哪些优势？ 　　</h2><ol><li>memcached所有的值均是简单的字符串，redis作为其替代者，支持更为丰富的数据类型 </li><li>redis的速度比memcached快很多 </li><li>redis可以持久化其数据</li></ol><h2 id="Memcache与Redis的区别都有哪些？"><a href="#Memcache与Redis的区别都有哪些？" class="headerlink" title="Memcache与Redis的区别都有哪些？"></a>Memcache与Redis的区别都有哪些？</h2><ol><li>存储方式 Memecache把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小。 Redis有部份存在硬盘上，这样能保证数据的持久性。 </li><li>数据支持类型 Memcache对数据类型支持相对简单。 Redis有复杂的数据类型。 </li><li>使用底层模型不同 它们之间底层实现方式 以及与客户端之间通信的应用协议不一样。 Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。 </li></ol><h2 id="redis常见性能问题和解决方案："><a href="#redis常见性能问题和解决方案：" class="headerlink" title="redis常见性能问题和解决方案： 　　"></a>redis常见性能问题和解决方案： 　　</h2><ol><li><p>Master写内存快照，save命令调度rdbSave函数，会阻塞主线程的工作，当快照比较大时对性能影响是非常大的，会间断性暂停服务，所以Master最好不要写内存快照。</p></li><li><p>Master AOF持久化，如果不重写AOF文件，这个持久化方式对性能的影响是最小的，但是AOF文件会不断增大，AOF文件过大会影响Master重启的恢复速度。Master最好不要做任何持久化工作，包括内存快照和AOF日志文件，特别是不要启用内存快照做持久化,如果数据比较关键，某个Slave开启AOF备份数据，策略为每秒同步一次。</p></li><li><p>Master调用BGREWRITEAOF重写AOF文件，AOF在重写的时候会占大量的CPU和内存资源，导致服务load过高，出现短暂服务暂停现象。</p></li><li><p>Redis主从复制的性能问题，为了主从复制的速度和连接的稳定性，Slave和Master最好在同一个局域网内</p></li></ol>]]></content>
      
      
    </entry>
    
    <entry>
      <title>Springmvc面试题</title>
      <link href="/2018/07/11/Springmvc%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2018/07/11/Springmvc%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      <content type="html"><![CDATA[<h2 id="讲下SpringMvc和Struts1-Struts2的比较的优势"><a href="#讲下SpringMvc和Struts1-Struts2的比较的优势" class="headerlink" title="讲下SpringMvc和Struts1,Struts2的比较的优势"></a>讲下SpringMvc和Struts1,Struts2的比较的优势</h2><p>性能上Struts1&gt;SpringMvc&gt;Struts2 </p><p>开发速度上SpringMvc和Struts2差不多,比Struts1要高</p><h2 id="讲下SpringMvc的核心入口类是什么-Struts1-Struts2的分别是什么"><a href="#讲下SpringMvc的核心入口类是什么-Struts1-Struts2的分别是什么" class="headerlink" title="讲下SpringMvc的核心入口类是什么,Struts1,Struts2的分别是什么"></a>讲下SpringMvc的核心入口类是什么,Struts1,Struts2的分别是什么</h2><p>SpringMvc的是DispatchServlet,Struts1的是ActionServlet,Struts2的是StrutsPrepareAndExecuteFilter</p><h2 id="SpringMvc的控制器是不是单例模式-如果是-有什么问题-怎么解决"><a href="#SpringMvc的控制器是不是单例模式-如果是-有什么问题-怎么解决" class="headerlink" title="SpringMvc的控制器是不是单例模式,如果是,有什么问题,怎么解决"></a>SpringMvc的控制器是不是单例模式,如果是,有什么问题,怎么解决</h2><p>是单例模式,所以在多线程访问的时候有线程安全问题,不要用同步,会影响性能的,解决方案是在控制器里面不能写字段</p><h2 id="SpingMvc中的控制器的注解一般用那个-有没有别的注解可以替代"><a href="#SpingMvc中的控制器的注解一般用那个-有没有别的注解可以替代" class="headerlink" title="SpingMvc中的控制器的注解一般用那个,有没有别的注解可以替代"></a>SpingMvc中的控制器的注解一般用那个,有没有别的注解可以替代</h2><p>一般用@Conntroller注解,表示是表现层,不能用用别的注解代替.</p><p>5：@RequestMapping注解用在类上面有什么作用</p><p>用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。</p><p>6：怎么样把某个请求映射到特定的方法上面</p><p>直接在方法上面加上注解@RequestMapping,并且在这个注解里面写上要拦截的路径</p><p>7：如果在拦截请求中,我想拦截get方式提交的方法,怎么配置</p><p>可以在@RequestMapping注解里面加上method=RequestMethod.GET</p><p>8：如果在拦截请求中,我想拦截提交参数中包含”type=test”字符串,怎么配置</p><p>可以在@RequestMapping注解里面加上params=”type=test”</p><p>9：我想在拦截的方法里面得到从前台传入的参数,怎么得到</p><p>直接在形参里面声明这个参数就可以,但必须名字和传过来的参数一样</p><p>10： 如果前台有很多个参数传入,并且这些参数都是一个对象的,那么怎么样快速得到这个对象</p><p>直接在方法中声明这个对象,SpringMvc就自动会把属性赋值到这个对象里面</p><p> 11：怎么样在方法里面得到Request,或者Session</p><p>直接在方法的形参中声明request,SpringMvc就自动把request对象传入</p><p>12：SpringMvc中函数的返回值是什么.</p><p>返回值可以有很多类型,有String, ModelAndView,当一般用String比较好</p><p>13：SpringMvc怎么处理返回值的</p><p>SpringMvc根据配置文件中InternalResourceViewResolver的前缀和后缀,用前缀+返回值+后缀组成完整的返回值</p><p>14：SpringMVC怎么样设定重定向和转发的</p><p>在返回值前面加”forward:”就可以让结果转发,譬如”forward:user.do?name=method4” 在返回值前面加”redirect:”就可以让返回值重定向,譬如”redirect://<a href="http://www.baidu.com&quot;" target="_blank" rel="noopener">www.baidu.com&quot;</a></p><p>15：SpringMvc用什么对象从后台向前台传递数据的</p><p>通过ModelMap对象,可以在这个对象里面用put方法,把对象加到里面,前台就可以通过el表达式拿到</p><p>16：SpringMvc中有个类把视图和数据都合并的一起的,叫什么</p><p>叫ModelAndView</p><p>17：怎么样把ModelMap里面的数据放入Session里面</p><p>可以在类上面加上@SessionAttributes注解,里面包含的字符串就是要放入session里面的key</p><p>18：SpringMvc怎么和AJAX相互调用的</p><p>通过Jackson框架就可以把Java里面的对象直接转化成Js可以识别的Json对象 具体步骤如下 1.加入Jackson.jar 2.在配置文件中配置json的映射 3.在接受Ajax方法里面可以直接返回Object,List等,但方法前面要加上@ResponseBody注解</p><p>19：当一个方法向AJAX返回特殊对象,譬如Object,List等,需要做什么处理</p><p>要加上@ResponseBody注解</p><p>20：SpringMvc里面拦截器是怎么写的</p><p>有两种写法,一种是实现接口,另外一种是继承适配器类,然后在SpringMvc的配置文件中配置拦截器即可: <!-- 配置SpringMvc的拦截器 --><a href="mvc:interceptors" target="_blank" rel="noopener">mvc:interceptors</a> <!-- 配置一个拦截器的Bean就可以了 默认是对所有请求都拦截 --> <bean id="myInterceptor" class="com.et.action.MyHandlerInterceptor"></bean> <!-- 只针对部分请求拦截 --> <a href="mvc:interceptor" target="_blank" rel="noopener">mvc:interceptor</a> &lt;mvc:mapping path=”/modelMap.do” /&gt; <bean class="com.et.action.MyHandlerInterceptorAdapter"> &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt;</bean></p><p> 21：讲下SpringMvc的执行流程</p><p>系统启动的时候根据配置文件创建spring的容器, 首先是发送http请求到核心控制器disPatherServlet，spring容器通过映射器去寻找业务控制器，使用适配器找到相应的业务类，在进业务类时进行数据封装，在封装前可能会涉及到类型转换，执行完业务类后使用ModelAndView进行视图转发，数据放在model中，用map传递数据进行页面显示。</p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>mybatis相关知识点</title>
      <link href="/2018/07/10/mybatis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
      <url>/2018/07/10/mybatis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      <content type="html"><![CDATA[<h3 id="1、-和-的区别是什么？"><a href="#1、-和-的区别是什么？" class="headerlink" title="1、#{}和${}的区别是什么？"></a>1、#{}和${}的区别是什么？</h3><p>#{}是预编译处理，${}是字符串替换。</p><p>Mybatis在处理#{}时，会将sql中的#{}替换为?号，调用PreparedStatement的set方法来赋值；</p><p>Mybatis在处理${}时，就是把${}替换成变量的值。</p><p>使用#{}可以有效的防止SQL注入，提高系统安全性。</p><h3 id="2、当实体类中的属性名和表中的字段名不一样-，怎么办-？"><a href="#2、当实体类中的属性名和表中的字段名不一样-，怎么办-？" class="headerlink" title="2、当实体类中的属性名和表中的字段名不一样 ，怎么办 ？"></a>2、当实体类中的属性名和表中的字段名不一样 ，怎么办 ？</h3><h2 id="第1种：-通过在查询的sql语句中定义字段名的别名，让字段名的别名和实体类的属性名一致"><a href="#第1种：-通过在查询的sql语句中定义字段名的别名，让字段名的别名和实体类的属性名一致" class="headerlink" title="第1种： 通过在查询的sql语句中定义字段名的别名，让字段名的别名和实体类的属性名一致"></a>第1种： 通过在查询的sql语句中定义字段名的别名，让字段名的别名和实体类的属性名一致</h2><pre><code>&lt;select id=”selectorder” parametertype=”int” resultetype=”me.gacl.domain.order”&gt;     select order_id id, order_no orderno ,order_price price     form orders    where order_id=#{id}; &lt;/select&gt; </code></pre><h2 id="第2种：-通过来映射字段名和实体类属性名的一一对应的关系"><a href="#第2种：-通过来映射字段名和实体类属性名的一一对应的关系" class="headerlink" title="第2种： 通过来映射字段名和实体类属性名的一一对应的关系"></a>第2种： 通过<resultmap>来映射字段名和实体类属性名的一一对应的关系</resultmap></h2><pre><code>&lt;select id=&quot;getOrder&quot; parameterType=&quot;int&quot; resultMap=&quot;orderresultmap&quot;&gt;        select * from orders where order_id=#{id}    &lt;/select&gt;&lt;resultMap type=”me.gacl.domain.order” id=”orderresultmap”&gt;         &lt;!–用id属性来映射主键字段–&gt;         &lt;id property=”id” column=”order_id”&gt;         &lt;!–用result属性来映射非主键字段，property为实体类属性名，column为数据表中的属性–&gt;         &lt;result property = “orderno” column =”order_no”/&gt;         &lt;result property=”price” column=”order_price” /&gt; &lt;/reslutMap&gt;</code></pre><h3 id="3、-模糊查询like语句该怎么写"><a href="#3、-模糊查询like语句该怎么写" class="headerlink" title="3、 模糊查询like语句该怎么写?"></a>3、 模糊查询like语句该怎么写?</h3><pre><code>1.在Java代码中添加sql通配符。string wildcardname = “%smi%”; list&lt;name&gt; names = mapper.selectlike(wildcardname);&lt;select id=”selectlike”&gt;     select * from foo where bar like #{value} &lt;/select&gt;2.在sql语句中拼接通配符，会引起sql注入string wildcardname = “smi”; list&lt;name&gt; names = mapper.selectlike(wildcardname);&lt;select id=”selectlike”&gt;  select * from foo where bar like &quot;%&quot;#{value}&quot;%&quot;&lt;/select&gt;</code></pre><h3 id="通常一个Xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗？"><a href="#通常一个Xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗？" class="headerlink" title="通常一个Xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗？"></a>通常一个Xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗？</h3><p>Dao接口，就是人们常说的Mapper接口，接口的全限名，就是映射文件中的namespace的值，接口的方法名，就是映射文件中MappedStatement的id值，接口方法内的参数，就是传递给sql的参数。Mapper接口是没有实现类的，当调用接口方法时，接口全限名+方法名拼接字符串作为key值，可唯一定位一个MappedStatement，举例：com.mybatis3.mappers.StudentDao.findStudentById，可以唯一找到namespace为com.mybatis3.mappers.StudentDao下面id = findStudentById的MappedStatement。在Mybatis中，每一个\<select>、\<insert>、\<update>、\<delete>标签，都会被解析为一个MappedStatement对象。</delete></update></insert></select></p><p>Dao接口里的方法，是不能重载的，因为是全限名+方法名的保存和寻找策略。</p><p>Dao接口的工作原理是JDK动态代理，Mybatis运行时会使用JDK动态代理为Dao接口生成代理proxy对象，代理对象proxy会拦截接口方法，转而执行MappedStatement所代表的sql，然后将sql执行结果返回。</p><h3 id="5、Mybatis是如何进行分页的？分页插件的原理是什么？"><a href="#5、Mybatis是如何进行分页的？分页插件的原理是什么？" class="headerlink" title="5、Mybatis是如何进行分页的？分页插件的原理是什么？"></a>5、Mybatis是如何进行分页的？分页插件的原理是什么？</h3><p>Mybatis使用RowBounds对象进行分页，它是针对ResultSet结果集执行的内存分页，而非物理分页，可以在sql内直接书写带有物理分页的参数来完成物理分页功能，也可以使用分页插件来完成物理分页。</p><p>分页插件的基本原理是使用Mybatis提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的sql，然后重写sql，根据dialect方言，添加对应的物理分页语句和物理分页参数。</p><h3 id="6、Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？"><a href="#6、Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？" class="headerlink" title="6、Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？"></a>6、Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？</h3><p>答：第一种是使用<resultmap>标签，逐一定义列名和对象属性名之间的映射关系。第二种是使用sql列的别名功能，将列别名书写为对象属性名，比如T_NAME AS NAME，对象属性名一般是name，小写，但是列名不区分大小写，Mybatis会忽略列名大小写，智能找到与之对应对象属性名，你甚至可以写成T_NAME AS NaMe，Mybatis一样可以正常工作。</resultmap></p><p>有了列名与属性名的映射关系后，Mybatis通过反射创建对象，同时使用反射给对象的属性逐一赋值并返回，那些找不到映射关系的属性，是无法完成赋值的。</p><h3 id="7、如何执行批量插入"><a href="#7、如何执行批量插入" class="headerlink" title="7、如何执行批量插入?"></a>7、如何执行批量插入?</h3><p>使用动态sql的foreach</p><h3 id="9、在mapper中如何传递多个参数"><a href="#9、在mapper中如何传递多个参数" class="headerlink" title="9、在mapper中如何传递多个参数?"></a>9、在mapper中如何传递多个参数?</h3><p>Mybatis动态sql可以让我们在Xml映射文件内，以标签的形式编写动态sql，完成逻辑判断和动态拼接sql的功能。<br>Mybatis提供了9种动态sql标签：trim|where|set|foreach|if|choose|when|otherwise|bind。<br>其执行原理为，使用OGNL从sql参数对象中计算表达式的值，根据表达式的值动态拼接sql，以此来完成动态sql的功能。</p><h3 id="Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复？"><a href="#Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复？" class="headerlink" title="Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复？"></a>Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复？</h3><p>不同的Xml映射文件，如果配置了namespace，那么id可以重复；如果没有配置namespace，那么id不能重复；毕竟namespace不是必须的，只是最佳实践而已。</p><p>原因就是namespace+id是作为Map&lt;String, MappedStatement&gt;的key使用的，如果没有namespace，就剩下id，那么，id重复会导致数据互相覆盖。有了namespace，自然id就可以重复，namespace不同，namespace+id自然也就不同。</p><h3 id="12、为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？"><a href="#12、为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？" class="headerlink" title="12、为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？"></a>12、为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？</h3><p>Hibernate属于全自动ORM映射工具，使用Hibernate查询关联对象或者关联集合对象时，可以根据对象关系模型直接获取，所以它是全自动的。而Mybatis在查询关联对象或关联集合对象时，需要手动编写sql来完成，所以，称之为半自动ORM映射工具。</p><h3 id="13、-一对一、一对多的关联查询-？"><a href="#13、-一对一、一对多的关联查询-？" class="headerlink" title="13、 一对一、一对多的关联查询 ？"></a>13、 一对一、一对多的关联查询 ？</h3><pre><code>&lt;mapper namespace=&quot;com.lcb.mapping.userMapper&quot;&gt;      &lt;!--association  一对一关联查询 --&gt;      &lt;select id=&quot;getClass&quot; parameterType=&quot;int&quot; resultMap=&quot;ClassesResultMap&quot;&gt;          select * from class c,teacher t where c.teacher_id=t.t_id and c.c_id=#{id}      &lt;/select&gt;      &lt;resultMap type=&quot;com.lcb.user.Classes&quot; id=&quot;ClassesResultMap&quot;&gt;          &lt;!-- 实体类的字段名和数据表的字段名映射 --&gt;          &lt;id property=&quot;id&quot; column=&quot;c_id&quot;/&gt;          &lt;result property=&quot;name&quot; column=&quot;c_name&quot;/&gt;          &lt;association property=&quot;teacher&quot; javaType=&quot;com.lcb.user.Teacher&quot;&gt;              &lt;id property=&quot;id&quot; column=&quot;t_id&quot;/&gt;              &lt;result property=&quot;name&quot; column=&quot;t_name&quot;/&gt;          &lt;/association&gt;      &lt;/resultMap&gt;      &lt;!--collection  一对多关联查询 --&gt;      &lt;select id=&quot;getClass2&quot; parameterType=&quot;int&quot; resultMap=&quot;ClassesResultMap2&quot;&gt;          select * from class c,teacher t,student s where c.teacher_id=t.t_id and c.c_id=s.class_id and c.c_id=#{id}      &lt;/select&gt;      &lt;resultMap type=&quot;com.lcb.user.Classes&quot; id=&quot;ClassesResultMap2&quot;&gt;          &lt;id property=&quot;id&quot; column=&quot;c_id&quot;/&gt;          &lt;result property=&quot;name&quot; column=&quot;c_name&quot;/&gt;          &lt;association property=&quot;teacher&quot; javaType=&quot;com.lcb.user.Teacher&quot;&gt;              &lt;id property=&quot;id&quot; column=&quot;t_id&quot;/&gt;              &lt;result property=&quot;name&quot; column=&quot;t_name&quot;/&gt;          &lt;/association&gt;          &lt;collection property=&quot;student&quot; ofType=&quot;com.lcb.user.Student&quot;&gt;              &lt;id property=&quot;id&quot; column=&quot;s_id&quot;/&gt;              &lt;result property=&quot;name&quot; column=&quot;s_name&quot;/&gt;          &lt;/collection&gt;      &lt;/resultMap&gt;  &lt;/mapper&gt;  </code></pre>]]></content>
      
      
    </entry>
    
    <entry>
      <title>微信公众号相关</title>
      <link href="/2018/07/10/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E7%9B%B8%E5%85%B3/"/>
      <url>/2018/07/10/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E7%9B%B8%E5%85%B3/</url>
      <content type="html"><![CDATA[<h1 id="1-订阅号，服务号，企业号的区别？"><a href="#1-订阅号，服务号，企业号的区别？" class="headerlink" title="1.订阅号，服务号，企业号的区别？"></a>1.订阅号，服务号，企业号的区别？</h1><p><a href="http://kf.qq.com/faq/120911VrYVrA130805byM32u.html" target="_blank" rel="noopener">http://kf.qq.com/faq/120911VrYVrA130805byM32u.html</a></p><h1 id="微信有哪九大高级接口"><a href="#微信有哪九大高级接口" class="headerlink" title="微信有哪九大高级接口"></a>微信有哪九大高级接口</h1><ul><li>语音识别</li><li>客服接口</li><li>OAuth2.0网页授权</li><li>生成带参数二维码</li><li>获取用户地理位置</li><li>获取用户基本信息</li><li>获取关注者列表</li><li>用户分组接口</li><li>上传下载多媒体</li></ul><h1 id="3-接入微信公众平台开发的配置（本地服务器如何与微信关联）？"><a href="#3-接入微信公众平台开发的配置（本地服务器如何与微信关联）？" class="headerlink" title="3.接入微信公众平台开发的配置（本地服务器如何与微信关联）？"></a>3.接入微信公众平台开发的配置（本地服务器如何与微信关联）？</h1><ol><li>填写服务器配置 在公众平台官网的开发-基本设置页面，勾选协议成为开发者，点击“修改配置”按钮，填写服务器地址（URL）、Token和EncodingAESKey，其中URL是开发者用来接收微信消息和事件的接口URL。</li><li>验证服务器地址的有效性<br>根据微信服务器返回的签名认证参数，按要求处理（token、timestamp、nonce三个参数进行字典序排序，再sha1加密，再拼接为字符串），再与signature比对。</li><li>依据接口文档实现业务逻辑</li></ol><h1 id="4-使用微信公众号的优点？"><a href="#4-使用微信公众号的优点？" class="headerlink" title="4.使用微信公众号的优点？"></a>4.使用微信公众号的优点？</h1><ol><li>微信用户量大，高达十几亿</li><li>形成闭环：一站式服务，效益转化率高</li><li>是一个开放性平台</li><li>与开发app相比，开发成本低 </li></ol><h1 id="OAuth2-0认证流程？与微信OAuth2-0认证流程有什么不同？"><a href="#OAuth2-0认证流程？与微信OAuth2-0认证流程有什么不同？" class="headerlink" title="OAuth2.0认证流程？与微信OAuth2.0认证流程有什么不同？"></a>OAuth2.0认证流程？与微信OAuth2.0认证流程有什么不同？</h1><h2 id="OAuth2-0处理流程"><a href="#OAuth2-0处理流程" class="headerlink" title="OAuth2.0处理流程"></a>OAuth2.0处理流程</h2><ol><li>获得用户许可，得到授权码code</li><li>根据code获得access token</li><li>通过access token获得openid</li><li>通过access token 和openid调用API，获得用户授权信息<h2 id="微信认证流程（将2和3合并了）"><a href="#微信认证流程（将2和3合并了）" class="headerlink" title="微信认证流程（将2和3合并了）"></a>微信认证流程（将2和3合并了）</h2>微信认证只需要获得用户许可后，获得授权码code，<br>就可以通过code，同时获得access token以及用户的openid，<br>然后根据access token 和openid调用API，获得用户授权信息</li></ol><h2 id="access-token有效时间只有2个小时，并且每天只能请求微信服务器获取access-token-2000次，该问题是如何处理的？"><a href="#access-token有效时间只有2个小时，并且每天只能请求微信服务器获取access-token-2000次，该问题是如何处理的？" class="headerlink" title="access_token有效时间只有2个小时，并且每天只能请求微信服务器获取access_token 2000次，该问题是如何处理的？"></a>access_token有效时间只有2个小时，并且每天只能请求微信服务器获取access_token 2000次，该问题是如何处理的？</h2><p>使用监听与线程结合的方式解决。<br>在web.xml中配置监听器，启动项目时，开启线程获取acess_token，再给线程设置睡眠时间为3600s（小于7200s即可），3600s后再次获取acess_token。</p><p>当然还有其他方式：比如将acess_token存在数据库或文件或缓存或servletContext中，每隔一定时间，再去获取</p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>IOC的流水线</title>
      <link href="/2018/07/09/IOC%E7%9A%84%E6%B5%81%E6%B0%B4%E7%BA%BF/"/>
      <url>/2018/07/09/IOC%E7%9A%84%E6%B5%81%E6%B0%B4%E7%BA%BF/</url>
      <content type="html"><![CDATA[]]></content>
      
      
    </entry>
    
    <entry>
      <title>方法注入和方法替换</title>
      <link href="/2018/07/08/%E6%96%B9%E6%B3%95%E6%B3%A8%E5%85%A5%E5%92%8C%E6%96%B9%E6%B3%95%E6%9B%BF%E6%8D%A2/"/>
      <url>/2018/07/08/%E6%96%B9%E6%B3%95%E6%B3%A8%E5%85%A5%E5%92%8C%E6%96%B9%E6%B3%95%E6%9B%BF%E6%8D%A2/</url>
      <content type="html"><![CDATA[<h1 id="lookup方法注入"><a href="#lookup方法注入" class="headerlink" title="lookup方法注入"></a>lookup方法注入</h1><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>希望在一个singleton bean获取一个prototype bean时使用</p><h1 id="方法替换"><a href="#方法替换" class="headerlink" title="方法替换"></a>方法替换</h1><h2 id="场景-1"><a href="#场景-1" class="headerlink" title="场景"></a>场景</h2><p>用实现了MethodReplacer接口的方法替换另外一个bean中的方法</p>]]></content>
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>IP地址分类</title>
      <link href="/2018/07/08/IP%E5%9C%B0%E5%9D%80%E5%88%86%E7%B1%BB/"/>
      <url>/2018/07/08/IP%E5%9C%B0%E5%9D%80%E5%88%86%E7%B1%BB/</url>
      <content type="html"><![CDATA[<h2 id="A类"><a href="#A类" class="headerlink" title="A类"></a>A类</h2><p>8+24，网络地址第一位是0，第一段数字范围为0-127</p><h2 id="B类"><a href="#B类" class="headerlink" title="B类"></a>B类</h2><p>16+16，网络地址最高为为10，第一段数字范围128-191</p><h2 id="C类"><a href="#C类" class="headerlink" title="C类"></a>C类</h2><p>24+8，最高位110，第一段数字192-223</p><h2 id="D类"><a href="#D类" class="headerlink" title="D类"></a>D类</h2><p>用于多点播送，最高为1110，224-239，全0的主机地址表示当前主机，全1表示当前子网的广播地址。</p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>TCP和UDP</title>
      <link href="/2018/07/08/TCP%E5%92%8CUDP/"/>
      <url>/2018/07/08/TCP%E5%92%8CUDP/</url>
      <content type="html"><![CDATA[<h1 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h1><h2 id="网络传输"><a href="#网络传输" class="headerlink" title="网络传输"></a>网络传输</h2><ol><li>延迟敏感型 VoIP </li></ol><p>偏向UDP</p><ol start="2"><li>宽带敏感型 文件传输、备份、大数据量SQL</li></ol><p>偏向TCP</p><ol start="3"><li>群组通信 IPTV 路由公告</li></ol><p>偏向UDP</p><h2 id="系统资源开销"><a href="#系统资源开销" class="headerlink" title="系统资源开销"></a>系统资源开销</h2><ol><li>计算密集型 科学计算、AI、数据库检索 TCP</li><li>资源集约型 嵌入式设备管理维护 UDP</li></ol><p>集约化原是经济领域中的一句术语，本意是指在最充分利用一切资源的基础上，更集中合理地运用现代管理与技术，充分发挥人力资源的积极效应，以提高工作效益和效率的一种形式。</p><ol start="3"><li>大规模并发用户类型 QQ UDP</li></ol><h2 id="网络状况"><a href="#网络状况" class="headerlink" title="网络状况"></a>网络状况</h2><ol><li>任务型 内部网络 TCP</li><li>混杂型 Ineternet</li><li>故障型 卫星链路</li></ol>]]></content>
      
      
    </entry>
    
    <entry>
      <title>网络地址转换NAT</title>
      <link href="/2018/07/08/%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2NAT/"/>
      <url>/2018/07/08/%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2NAT/</url>
      <content type="html"><![CDATA[<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>内网ip向互联网的ip发送数据以及接收数据。</p><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>todo -自己抓包测一下呗。</p><ol><li>192.168.1.100要发送报文到Internet</li><li>首先由Nat主机接收，将192.168.1.100嵌入IP报文中，然后发送给目标主机</li><li>目标主机将带192.168.1.100的报文以及需要的数据返回给Nat主机</li><li>Nat将数据返回给报文</li></ol>]]></content>
      
      
    </entry>
    
    <entry>
      <title>内部类知识点</title>
      <link href="/2018/07/08/%E5%86%85%E9%83%A8%E7%B1%BB%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
      <url>/2018/07/08/%E5%86%85%E9%83%A8%E7%B1%BB%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      <content type="html"><![CDATA[<h1 id="非静态内部类"><a href="#非静态内部类" class="headerlink" title="非静态内部类"></a>非静态内部类</h1><p>有外部类的引用，可以直接使用外部类的成员变量</p><h1 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h1><p>没有外部类的引用</p><h1 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h1><p>比如</p><pre><code>new ArrayList(){{add(1);}}</code></pre><p>因为没有名字，所以不能有构造方法，但可以有构造块。</p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>线程安全的单例模式</title>
      <link href="/2018/07/08/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/07/08/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>public class WarmSingleton {    private WarmSingleton()    {        System.out.println(&quot;WarmSingleton is create&quot;);    }    /**    * 内部类不会在外部类被调用的时候实例化    */    private static class  SingletonHolder    {        static {            System.out.println(&quot;SingletonHolder is create&quot;);        }        private static WarmSingleton instance=new WarmSingleton();    }    public static WarmSingleton getInstance()    {        return SingletonHolder.instance;    }    public static void main(String[] args) {//        WarmSingleton warmSingleton=new WarmSingleton();        WarmSingleton.getInstance();    }}</code></pre><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>懒汉单例模式需要双重加锁，饿汉在加载类的时候就已经实例化了，可能只需要调用这个类中的一些static变量，不需要instance变量。<br>温和单例模式解决了以上两种的缺点，加载类也不会实例化instance，同时不需要加锁保证性能。</p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>jvm垃圾回收之判断可触及性</title>
      <link href="/2018/07/08/jvm%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E4%B9%8B%E5%88%A4%E6%96%AD%E5%8F%AF%E8%A7%A6%E5%8F%8A%E6%80%A7/"/>
      <url>/2018/07/08/jvm%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E4%B9%8B%E5%88%A4%E6%96%AD%E5%8F%AF%E8%A7%A6%E5%8F%8A%E6%80%A7/</url>
      <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>从根节点开始是否可以访问这个对象，如果从<em>所有</em>的根节点都无法访问某个对象，说明对象已经不再被使用了，即为无法触及。但是某种情况下可能会复活自己，如果这样，回收这个对象就是不合理的。</p><h1 id="触及性的状态"><a href="#触及性的状态" class="headerlink" title="触及性的状态"></a>触及性的状态</h1><ol><li>可触及 </li><li>可复活 可能在finalize中复活</li><li>不可触及 finalize已经被调用，没有复活，因为最多被调用一次，两次system.gc也只是被调用一次，进入不可触及状态</li></ol><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><h2 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h2><p>普通的引用</p><ul><li>强引用可以直接访问目标对象</li><li>不会被回收，即使要抛出OOM异常</li><li>可能导致内存泄漏<h2 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h2>SoftReference,堆空间不足时，会被回收。<br>用get（）取得强引用</li></ul><p>适合保存缓存数据。</p><h2 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h2><p>WeakReference，GC时，发现弱引用，就会回收他。<br>get（）取强引用。<br>适合保存缓存数据。</p><h2 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h2><p>和没有引用几乎是一样的，随时可能会被回收。用get（）总会失败。</p><p>虚引用必须和引用队列一起使用，作用在于跟踪垃圾回收过程。</p>]]></content>
      
      
        <tags>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>java中的传值和引用</title>
      <link href="/2018/07/08/java%E4%B8%AD%E7%9A%84%E4%BC%A0%E5%80%BC%E5%92%8C%E5%BC%95%E7%94%A8/"/>
      <url>/2018/07/08/java%E4%B8%AD%E7%9A%84%E4%BC%A0%E5%80%BC%E5%92%8C%E5%BC%95%E7%94%A8/</url>
      <content type="html"><![CDATA[<h1 id="Java是传值还是传引用"><a href="#Java是传值还是传引用" class="headerlink" title="Java是传值还是传引用"></a>Java是传值还是传引用</h1><p>传值，基本类型传拷贝值，引用类型传拷贝的引用值。</p><h1 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h1><pre><code>public  static  void call1(List list)    {        list=new ArrayList();    }    public  static  void call2(List list)    {        list.add(2);    }    public static void main(String[] args) {        List list=new ArrayList(){{add(1);}};        call1(list);        System.out.println(&quot;after call1 &quot;+list.size());        call2(list);        System.out.println(&quot;after call2 &quot;+list.size());    }</code></pre><p>如果是传引用，call1之后list的大小应该变为0，实际还是1.<br>同时拷贝的引用的堆变量改了，会反馈过来</p>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>java中的finalize方法</title>
      <link href="/2018/07/08/java%E4%B8%AD%E7%9A%84finalize%E6%96%B9%E6%B3%95/"/>
      <url>/2018/07/08/java%E4%B8%AD%E7%9A%84finalize%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<h2 id="尽量不要使用finalize（）进行资源释放"><a href="#尽量不要使用finalize（）进行资源释放" class="headerlink" title="尽量不要使用finalize（）进行资源释放"></a>尽量不要使用finalize（）进行资源释放</h2><ol><li>可能导致对象复活-如果this引用在finalize中外泄，就会复活。</li><li>执行时间没有保障，完全由GC线程决定</li><li>糟糕的finalize()会影响GC性能</li></ol><h2 id="双保险"><a href="#双保险" class="headerlink" title="双保险"></a>双保险</h2><p>比如mysql的jdbc驱动中，ConnectionImpl就实现了finalize（）</p>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Jvm </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>java运算符知识点</title>
      <link href="/2018/07/07/java%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
      <url>/2018/07/07/java%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      <content type="html"><![CDATA[<p>参考：<a href="https://introcs.cs.princeton.edu/java/11precedence/" target="_blank" rel="noopener">https://introcs.cs.princeton.edu/java/11precedence/</a></p><h1 id="关于-和-以及-amp-和-amp-amp"><a href="#关于-和-以及-amp-和-amp-amp" class="headerlink" title="关于|和||以及&amp;和&amp;&amp;"></a>关于|和||以及&amp;和&amp;&amp;</h1><p>|</p><h1 id="首先"><a href="#首先" class="headerlink" title="首先"></a>首先</h1><p>括号最大，拿不准或者太复杂用括号就好。</p><h1 id="结合性"><a href="#结合性" class="headerlink" title="结合性"></a>结合性</h1><ul><li>从左到右  72 / 2 / 3= (72 / 2) / 3</li><li>从右到左 x = y = z = 17 也就是 x = (y = (z = 17))</li><li>无结合性 (x &lt;= y &lt;= z)和x++–无意义</li></ul><p>数字越大优先级越高。</p><h2 id="Level-16"><a href="#Level-16" class="headerlink" title="Level 16"></a>Level 16</h2><ul><li>[] -访问数组</li><li>. 访问成员变量</li><li>() 方法调用<h2 id="15"><a href="#15" class="headerlink" title="15"></a>15</h2></li><li>++ 后自增，i++</li><li>– 后自减，i–<h2 id="14"><a href="#14" class="headerlink" title="14"></a>14</h2></li><li>++ 前自增，–i，当然 ++–i这种也没意义</li><li>– 前自减</li><li>+ 正数，比如int a=+1;</li><li>- 负数</li><li>! 逻辑非，boolean a=true;boolean b=!a;</li><li>~ 按位非<h2 id="13"><a href="#13" class="headerlink" title="13"></a>13</h2></li><li>() 转换，比如int a=0; short b=(short)a;</li><li><p>new 新建对象</p><h2 id="12"><a href="#12" class="headerlink" title="12"></a>12</h2><p>*/ % 算术运算</p><h2 id="11"><a href="#11" class="headerlink" title="11"></a>11</h2><ul><li>-<h2 id="10"><a href="#10" class="headerlink" title="10"></a>10</h2>>&gt; &lt;&lt; &gt;&gt;&gt;<br>32&gt;33结果是多少？</li></ul><p>移位之前先对右边的模32，相当于32&gt;&gt;1,结果是16   </p><h2 id="9"><a href="#9" class="headerlink" title="9"></a>9</h2><p>  &lt; &lt;= &gt; &gt;= instance of </p><h2 id="8"><a href="#8" class="headerlink" title="8"></a>8</h2><p>==<br>!=<br>比较</p><h2 id="7"><a href="#7" class="headerlink" title="7"></a>7</h2><p>&amp; 位运算符或者布尔逻辑与，不会短路</p><h2 id="6"><a href="#6" class="headerlink" title="6"></a>6</h2><p>^ 按位异或或者布尔逻辑异或，只有这么一个异或</p><h2 id="5"><a href="#5" class="headerlink" title="5"></a>5</h2><p>| 位运算符或者布尔逻辑或，不会短路</p><h2 id="4"><a href="#4" class="headerlink" title="4"></a>4</h2><p>&amp;&amp;</p><h2 id="3"><a href="#3" class="headerlink" title="3"></a>3</h2><p>||</p><h2 id="2"><a href="#2" class="headerlink" title="2"></a>2</h2><p>?:</p><h2 id="1"><a href="#1" class="headerlink" title="1"></a>1</h2></li></ul><p>=   +=   -=<br>*=   /=   %=<br>&amp;=   ^=   |=<br>&lt;&lt;=  &gt;&gt;= &gt;&gt;&gt;= </p><h1 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h1>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java IO知识点</title>
      <link href="/2018/07/07/Java-IO%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
      <url>/2018/07/07/Java-IO%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      <content type="html"><![CDATA[<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><h3 id="面向字符的输入输出流"><a href="#面向字符的输入输出流" class="headerlink" title="面向字符的输入输出流"></a>面向字符的输入输出流</h3><ul><li>Reader</li><li>Writer</li></ul><h3 id="面向字节的输入输出流媒"><a href="#面向字节的输入输出流媒" class="headerlink" title="面向字节的输入输出流媒"></a>面向字节的输入输出流媒</h3><ul><li>InputStream</li><li>OutputStream</li></ul><h2 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h2><p>使用Reader读取文件时，如果中文windows，那么默认编码是GBK,默认读取的文件的编码也是GBK，转换到Unicode存到内存中<br>如果读取非GBK编码的文件，需要使用InputStreamReader和OutputStreamWriter进行编码转换</p>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>utf-8和unicode</title>
      <link href="/2018/07/07/utf-8%E5%92%8Cunicode/"/>
      <url>/2018/07/07/utf-8%E5%92%8Cunicode/</url>
      <content type="html"><![CDATA[<img src="/2018/07/07/utf-8和unicode/unicode.png" title="unicode"><pre><code>@startuml:utf-8;note left美国的，最高位未用到end note:iso;note left欧洲的，加了法国，德国等字符用到了最高位end note:GBK;note left两个字节，中国用的end notepartition Unicode {:UTF-8;note leftutf-8中的表示和unicode编码相同，但是用了不同前缀来缩短占用end note:UTF-16;:UTF-32;}@enduml</code></pre>]]></content>
      
      
    </entry>
    
    <entry>
      <title>jvm知识点总结</title>
      <link href="/2018/07/07/jvm%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"/>
      <url>/2018/07/07/jvm%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<h1 id="ClassLoader"><a href="#ClassLoader" class="headerlink" title="ClassLoader"></a>ClassLoader</h1><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ol><li>bootstrap classloader C编写，加载java核心类，包括ext和appclassloader,java中没有对应的，打印String.getClassLoader会是null</li><li>extclassloader java编写，加载/lib/ext中的类</li><li>appclassloader 加载classpath变量中的类，通常自定义的类就是由他加载</li><li>自定义类加载器</li></ol><h2 id="层次关系"><a href="#层次关系" class="headerlink" title="层次关系"></a>层次关系</h2><img src="/2018/07/07/jvm知识点总结/classloader.png" title="classloader"><h3 id="自底向上检查类是否加载"><a href="#自底向上检查类是否加载" class="headerlink" title="自底向上检查类是否加载"></a>自底向上检查类是否加载</h3><p>todo,抽空看源码</p><p>为什么从底开始，我也不清楚，如果从顶开始检查有什么问题。</p><h3 id="自顶向下尝试加载类"><a href="#自顶向下尝试加载类" class="headerlink" title="自顶向下尝试加载类"></a>自顶向下尝试加载类</h3><p>安全是一个考虑</p><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><p> 引用了职责链模式</p><h2 id="为什么层次关系"><a href="#为什么层次关系" class="headerlink" title="为什么层次关系"></a>为什么层次关系</h2><ol><li>避免重复加载</li><li>安全 可能出现自定义加载器加载核心类替换bootstrapclassloader加载的，String等。<h2 id="不同加载器加载同一个类"><a href="#不同加载器加载同一个类" class="headerlink" title="不同加载器加载同一个类"></a>不同加载器加载同一个类</h2>属于不同的对象<h2 id="loadclass（）和forname（）的区别"><a href="#loadclass（）和forname（）的区别" class="headerlink" title="loadclass（）和forname（）的区别"></a>loadclass（）和forname（）的区别</h2>loaderClass默认构造函数调用的是resolve-false，不会类进行解析，因为不会初始化</li></ol><p>forName 第二个参数initialize为true，会初始化。</p><h2 id="转载类的3个阶段"><a href="#转载类的3个阶段" class="headerlink" title="转载类的3个阶段"></a>转载类的3个阶段</h2><img src="/2018/07/07/jvm知识点总结/装载流程.png" title="装载流程">]]></content>
      
      
    </entry>
    
    <entry>
      <title>线索二叉树</title>
      <link href="/2018/07/07/%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2018/07/07/%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      <content type="html"><![CDATA[]]></content>
      
      
    </entry>
    
    <entry>
      <title>异常分类</title>
      <link href="/2018/07/07/%E5%BC%82%E5%B8%B8%E5%88%86%E7%B1%BB/"/>
      <url>/2018/07/07/%E5%BC%82%E5%B8%B8%E5%88%86%E7%B1%BB/</url>
      <content type="html"><![CDATA[<h2 id="检查型异常（Checked-Exception）"><a href="#检查型异常（Checked-Exception）" class="headerlink" title="检查型异常（Checked Exception）"></a>检查型异常（Checked Exception）</h2><p>　　个人理解：所谓检查（Checked）是指编译器要检查这类异常，检查的目的一方面是因为该类异常的发生难以避免，另一方面就是让开发者去解决掉这类异常，所以称为必须处理（try …catch）的异常。如果不处理这类异常，集成开发环境中的编译器一般会给出错误提示。</p><p>　　例如：一个读取文件的方法代码逻辑没有错误，但程序运行时可能会因为文件找不到而抛出FileNotFoundException，如果不处理这些异常，程序将来肯定会出错。所以编译器会提示你要去捕获并处理这种可能发生的异常，不处理就不能通过编译。</p><h2 id="非检查型异常（Unchecked-Exception）"><a href="#非检查型异常（Unchecked-Exception）" class="headerlink" title="非检查型异常（Unchecked Exception）"></a>非检查型异常（Unchecked Exception）</h2><p>　　个人理解：所谓非检查（Unchecked）是指编译器不会检查这类异常，不检查的则开发者在代码的编辑编译阶段就不是必须处理，这类异常一般可以避免，因此无需处理（try …catch）。如果不处理这类异常，集成开发环境中的编译器也不会给出错误提示。</p><p>　　例如：你的程序逻辑本身有问题，比如数组越界、访问null对象，这种错误你自己是可以避免的。编译器不会强制你检查这种异常。</p>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>MySQL创建索引方法：ALTER TABLE和CREATE INDEX的区别</title>
      <link href="/2018/07/06/MySQL%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95%E6%96%B9%E6%B3%95%EF%BC%9AALTER-TABLE%E5%92%8CCREATE-INDEX%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2018/07/06/MySQL%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95%E6%96%B9%E6%B3%95%EF%BC%9AALTER-TABLE%E5%92%8CCREATE-INDEX%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      <content type="html"><![CDATA[<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><ul><li>ALTER TABLE HeadOfState ADD INDEX (LastName, FirstName);</li><li>CREATE INDEX index_name HeadOfState (LastName, FirstName);</li></ul><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>在网上找了一下，在一个英文网站上，总结了下面几个区别，我翻译出来，如下：</p><ol><li>CREATE INDEX必须提供索引名，对于ALTER TABLE，将会自动创建，如果你不提供；</li><li>CREATE INDEX一个语句一次只能建立一个索引，ALTER TABLE可以在一个语句建立多个，如：<br>   ALTER TABLE HeadOfState ADD PRIMARY KEY (ID), ADD INDEX (LastName,FirstName);</li><li>只有ALTER TABLE 才能创建主键，</li></ol><p>英文原句如下：</p><blockquote><p>With CREATE INDEX, we must provide a name for the index. With ALTER TABLE, MySQL creates an index name automatically if you don’t provide one.Unlike ALTER TABLE, the CREATE INDEX statement can create only a single index per statement. In addition, only ALTER TABLE supports the use of PRIMARY KEY.</p></blockquote>]]></content>
      
      
    </entry>
    
    <entry>
      <title>正确建立索引以及最左前缀原则</title>
      <link href="/2018/07/06/%E6%AD%A3%E7%A1%AE%E5%BB%BA%E7%AB%8B%E7%B4%A2%E5%BC%95%E4%BB%A5%E5%8F%8A%E6%9C%80%E5%B7%A6%E5%89%8D%E7%BC%80%E5%8E%9F%E5%88%99/"/>
      <url>/2018/07/06/%E6%AD%A3%E7%A1%AE%E5%BB%BA%E7%AB%8B%E7%B4%A2%E5%BC%95%E4%BB%A5%E5%8F%8A%E6%9C%80%E5%B7%A6%E5%89%8D%E7%BC%80%E5%8E%9F%E5%88%99/</url>
      <content type="html"><![CDATA[<h2 id="索引建立的原则"><a href="#索引建立的原则" class="headerlink" title="索引建立的原则"></a>索引建立的原则</h2><p>用于索引的最好的备选数据列是那些出现在</p><ul><li>WHERE子句</li><li>join子句</li><li>*ORDER BY</li><li>GROUP BY子句</li></ul><p>仅仅出现在SELECT关键字后面的输出数据列列表中的数据列不是很好的备选列</p><p>SELECT<br>col_a &lt;- 不是备选列<br>FROM<br>tbl1 LEFT JOIN tbl2<br>ON tbl1.col_b = tbl2.col_c &lt;- 备选列<br>WHERE<br>col_d = expr; &lt;- 备选列</p><p>当然，显示的数据列与WHERE子句中使用的数据列也可能相同。<br>我们的观点是输出列表中的数据列本质上不是用于索引的很好的备选列。</p><p>因为mysql最佳原则是小结果集驱动大结果集，所以被驱动的，也就是tbl2的col_c，应该加索引。</p><h2 id="复合索引的建立以及最左前缀原则"><a href="#复合索引的建立以及最左前缀原则" class="headerlink" title="复合索引的建立以及最左前缀原则"></a>复合索引的建立以及最左前缀原则</h2><p>索引字符串值的前缀（prefixe）。如果你需要索引一个字符串数据列，那么最好在任何适当的情况下都应该指定前缀长度。<br>例如，如果有CHAR(200)数据列，如果前面10个或20个字符都不同，就不要索引整个数据列。<br>索引前面10个或20个字符会节省大量的空间<br>你可以索引CHAR、VARCHAR、BINARY、VARBINARY、BLOB和TEXT数据列的前缀。</p><p>假设你在表的state、city和zip数据列上建立了复合索引。索引中的数据行按照state/city/zip次序排列，<br>因此它们也会自动地按照state/city和state次序排列。这意味着，即使你在查询中只指定了state值，<br>或者指定state和city值，MySQL也可以使用这个索引。因此，这个索引可以被用于搜索如下所示的数据列组合：<br>state, city, zip<br>state, city<br>state</p><p>复合索引有几个字段就有几种数据列组合。</p><p>MySQL不能利用这个索引来搜索没有包含在最左前缀的内容。例如，如果你按照city或zip来搜索，<br>就不会使用到这个索引。如果你搜索给定的state和具体的ZIP代码（索引的1和3列），<br>该索引也是不能用于这种组合值的，尽管MySQL可以利用索引来查找匹配的state从而缩小搜索的范围。</p><p>如果你考虑给已经索引过的表添加索引，那么就要考虑你将增加的索引是否是已有的多列索引的最左前缀。<br>如果是这样的，不用增加索引，因为已经有了(例如，如果你在state、city和zip上建立了索引，那么没有必要再增加state的索引)。</p><h2 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h2><p>通过实例理解单列索引、多列索引以及最左前缀原则<br>实例：现在我们想查出满足以下条件的用户id：<br>mysql&gt;SELECT ｀uid｀ FROM people WHERE lname｀=’Liu’  AND ｀fname｀=’Zhiqun’ AND ｀age｀=26<br>因为我们不想扫描整表，故考虑用索引。</p><p>单列索引：<br>ALTER TABLE people ADD INDEX lname (lname);<br>将lname列建索引，这样就把范围限制在lname=’Liu’的结果集1上，之后扫描结果集1，产生满足fname=’Zhiqun’的结果集2，再扫描结果集2，找到 age=26的结果集3，即最终结果。</p><p>由于建立了lname列的索引，与执行表的完全扫描相比，效率提高了很多，但我们要求扫描的记录数量仍旧远远超过了实际所需 要的。虽然我们可以删除lname列上的索引，再创建fname或者age 列的索引，但是，不论在哪个列上创建索引搜索效率仍旧相似。</p><p>多列索引：<br>ALTER TABLE people ADD INDEX lname_fname_age (lame,fname,age);<br>为了提高搜索效率，我们需要考虑运用多列索引,由于索引文件以B－Tree格式保存，所以我们不用扫描任何记录，即可得到最终结果。</p><p><em>注：在mysql中执行查询时，只能使用一个索引，如果我们在lname,fname,age上分别建索引,执行查询时，只能使用一个索引，mysql会选择一个最严格(获得结果集记录数最少)的索引。</em></p><p>3.最左前缀：顾名思义，就是最左优先，上例中我们创建了lname_fname_age多列索引,相当于创建了(lname)单列索引，(lname,fname)组合索引以及(lname,fname,age)组合索引。</p><p>注：在创建多列索引时，要根据业务需求，where子句中使用最频繁的一列放在最左边。</p>]]></content>
      
      <categories>
          
          <category> SQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 索引 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JavaScript中数组slice和splice的对比</title>
      <link href="/2018/07/06/JavaScript%E4%B8%AD%E6%95%B0%E7%BB%84slice%E5%92%8Csplice%E7%9A%84%E5%AF%B9%E6%AF%94/"/>
      <url>/2018/07/06/JavaScript%E4%B8%AD%E6%95%B0%E7%BB%84slice%E5%92%8Csplice%E7%9A%84%E5%AF%B9%E6%AF%94/</url>
      <content type="html"><![CDATA[<h2 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h2><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p>[start,end)</p><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>被删掉的数组，包含[start,end)，原数组不变</p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>[5,6,7].slice(1,2)</p><p>结果是6，取出index为1的，到2之前的，不包括2，所以就是6</p><h2 id="splice"><a href="#splice" class="headerlink" title="splice"></a>splice</h2><h3 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h3><p>index    必需。整数，规定添加/删除项目的位置，使用负数可从数组结尾处规定位置。<br>howmany    必需。要删除的项目数量。如果设置为 0，则不会删除项目。<br>item1, …, itemX    可选。向数组添加的新项目。</p><h3 id="返回值-1"><a href="#返回值-1" class="headerlink" title="返回值"></a>返回值</h3><p>被删除的元素的数组</p><h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><p>[5,6,7].splice(1,2)</p><p>返回是6，7，从index为1开始，取2个</p><h2 id="与splice区别"><a href="#与splice区别" class="headerlink" title="与splice区别"></a>与splice区别</h2><ol><li>slice的第二个参数是end，而splice是howmany，数量</li><li>slice不修改原数组，splice修改原数组</li><li>slice可以应用于字符串，splice不行</li><li>splice可以增加或者修改</li></ol>]]></content>
      
      
    </entry>
    
    <entry>
      <title>快速排序算法</title>
      <link href="/2018/07/06/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
      <url>/2018/07/06/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
      <content type="html"><![CDATA[<h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><h2 id="优化方案"><a href="#优化方案" class="headerlink" title="优化方案"></a>优化方案</h2><h3 id="三数取中"><a href="#三数取中" class="headerlink" title="三数取中"></a>三数取中</h3><pre><code>int pivotkey;//1.三数取中，取出左中右三个数，交换以保证中间的数非最大最小。int m=(low+high)/2;if(array[low]&gt;array[high])swap(array,low,high);if(array[low]&lt;array[m])swap(array,low,m);pivotkey=array[low];</code></pre><h3 id="减少不必要的交换"><a href="#减少不必要的交换" class="headerlink" title="减少不必要的交换"></a>减少不必要的交换</h3>]]></content>
      
      
    </entry>
    
    <entry>
      <title>只用2GB内存在20亿个数中找出现次数最多的</title>
      <link href="/2018/07/06/%E5%8F%AA%E7%94%A82GB%E5%86%85%E5%AD%98%E5%9C%A820%E4%BA%BF%E4%B8%AA%E6%95%B0%E4%B8%AD%E6%89%BE%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E6%9C%80%E5%A4%9A%E7%9A%84/"/>
      <url>/2018/07/06/%E5%8F%AA%E7%94%A82GB%E5%86%85%E5%AD%98%E5%9C%A820%E4%BA%BF%E4%B8%AA%E6%95%B0%E4%B8%AD%E6%89%BE%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E6%9C%80%E5%A4%9A%E7%9A%84/</url>
      <content type="html"><![CDATA[<p>##首先</p><p>记住20亿这个接近int的上限了，int上限是2147483647</p><h2 id="难点"><a href="#难点" class="headerlink" title="难点"></a>难点</h2><p>如果只用哈希记录，20亿个数都不同，每个key和value都是int，一条记录8字节 ，20亿就是16</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><img src="/2018/07/06/只用2GB内存在20亿个数中找出现次数最多的/uml1.png" title="只用2GB内存在20亿个数中找出现次数最多的"><p>把包含20亿的大文件用哈希函数分成16个小文件，注意是文件不是内存，每个小文件中不同的数目不会大于2亿中，对每个小文件进行用哈希表统计出现次数，得到了16个小文件出现次数最多的数以及次数，拿出最大的。</p>]]></content>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>布隆过滤器</title>
      <link href="/2018/07/06/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
      <url>/2018/07/06/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/</url>
      <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><ul><li>网页黑名单系统</li><li>垃圾邮件过滤</li><li>爬虫网址判重</li></ul><p>容忍一定的失误率，对空间要求比较严格</p><h2 id="哈希函数的特点"><a href="#哈希函数的特点" class="headerlink" title="哈希函数的特点"></a>哈希函数的特点</h2><ul><li>无限的输入值域</li><li>相同输入值，返回值一样</li><li>不同输入值，返回值可能一样，可能不一样</li><li>很多不同输入值的返回值会均匀分布在S上</li></ul><p>最后一点是评价一个哈希函数是否优秀的关键。</p><h2 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h2><p>长度为m的bit类型的数组bitArray</p><p>假设有k个哈希函数，输出域S都&gt;=m,而且足够优秀，对于同一个输入值，经过k个哈希函数计算出来的结果也是相互独立的。<br>对每一个取余m，在bitArray上设置为1（涂黑），将所有的输入值，通过k个哈希函数计算出来，取余涂黑，如果已经黑了就不涂了。</p><h3 id="如何判断"><a href="#如何判断" class="headerlink" title="如何判断"></a>如何判断</h3><p>对于一个输入a，如果取余都已经黑了，一定在里面。<br>但是可能会有误判，比如b，取余后也黑了，但是不在里面。</p><h3 id="根据输入数量n和失误率p来计算m和哈希函数的个数k"><a href="#根据输入数量n和失误率p来计算m和哈希函数的个数k" class="headerlink" title="根据输入数量n和失误率p来计算m和哈希函数的个数k"></a>根据输入数量n和失误率p来计算m和哈希函数的个数k</h3><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>建立白名单防止误报。</p>]]></content>
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>SpringCloud分布式事务管理</title>
      <link href="/2018/07/06/SpringCloud%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/"/>
      <url>/2018/07/06/SpringCloud%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/</url>
      <content type="html"><![CDATA[<h2 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h2><p>对于微服务间的事务性操作，因为不同的微服务采用了不同的数据库，将无法利用数据库本身的事务机制保证一致性，需要引入二阶段提交等技术。</p><h2 id="分布式事务解决方案"><a href="#分布式事务解决方案" class="headerlink" title="分布式事务解决方案"></a>分布式事务解决方案</h2><h3 id="基于XA协议的两阶段提交"><a href="#基于XA协议的两阶段提交" class="headerlink" title="基于XA协议的两阶段提交"></a>基于XA协议的两阶段提交</h3><p>XA是一个分布式事务协议，由提出。XA中大致分为两部分：事务管理器和本地资源管理器。其中本地资源管理器往往由数据库实现，比如Oracle、DB2这些商业数据库都实现了XA接口，而事务管理器作为全局的调度者，负责各个本地资源的提交和回滚。</p><p>总的来说，XA协议比较简单，而且一旦商业数据库实现了XA协议，使用分布式事务的成本也比较低。但是，XA也有致命的缺点，那就是性能不理想，特别是在交易下单链路，往往并发量很高，XA无法满足高并发场景。XA目前在商业数据库支持的比较理想，在mysql数据库中支持的不太理想，mysql的XA实现，没有记录prepare阶段日志，主备切换回导致主库与备库数据不一致。许多nosql也没有支持XA，这让XA的应用场景变得非常狭隘。</p><h3 id="消息事务-最终一致性"><a href="#消息事务-最终一致性" class="headerlink" title="消息事务+最终一致性"></a>消息事务+最终一致性</h3><p>所谓的消息事务就是基于消息中间件的两阶段提交，本质上是对消息中间件的一种特殊利用，它是将本地事务和发消息放在了一个分布式事务里，保证要么本地操作成功成功并且对外发消息成功，要么两者都失败，开源的RocketMQ就支持这一特性.</p><p>该方案采用最终一致的，牺牲了一致性，换来了性能的大幅度提升。存在造成数据不一致的风险</p><h3 id="TCC编程模式"><a href="#TCC编程模式" class="headerlink" title="TCC编程模式"></a>TCC编程模式</h3><p>所谓的TCC编程模式，也是两阶段提交的一个变种。TCC提供了一个编程框架，将整个业务逻辑分为三块：Try、Confirm和Cancel三个操作。以在线下单为例，Try阶段会去扣库存，Confirm阶段则是去更新订单状态，如果更新订单失败，则进入Cancel阶段，会去恢复库存。总之，TCC就是通过代码人为实现了两阶段提交，不同的业务场景所写的代码都不一样，复杂度也不一样，因此，这种模式并不能很好地被复用。</p><h3 id="LCN"><a href="#LCN" class="headerlink" title="LCN"></a>LCN</h3><p>目前 LCN为 4.1 版本</p><p>主要特点：</p><p>支持各种基于spring的db框架<br>兼容SpringCloud、Dubbo、motan<br>使用简单，低依赖，代码完全开源<br>基于切面的强一致性事务框架<br>高可用，模块可以依赖RPC模块做集群化，TxManager也可以做集群化<br>支持本地事务和分布式事务共存<br>支持事务补偿机制，增加事务补偿决策提醒<br>采用强一致性方案，事务要不全部成功，要不全部失败，保证了事务的一致性，代码简单，原有项目只需引入相关 jar 包，并在需要参与的事务的方法添加注解即可，节省了代码改造成本.</p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>RabbitMQ的应用场景以及基本原理介绍</title>
      <link href="/2018/07/06/RabbitMQ%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E4%BB%A5%E5%8F%8A%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D/"/>
      <url>/2018/07/06/RabbitMQ%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E4%BB%A5%E5%8F%8A%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D/</url>
      <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>RabbitMQ是一个由erlang开发的AMQP(Advanved Message Queue)的开源实现。</p><h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><h2 id="异步处理"><a href="#异步处理" class="headerlink" title="异步处理"></a>异步处理</h2><p>场景说明：用户注册后，需要发注册邮件和注册短信,传统的做法有两种1.串行的方式;2.并行的方式 </p><h3 id="串行方式"><a href="#串行方式" class="headerlink" title="串行方式"></a>串行方式</h3><p>将注册信息写入数据库后,发送注册邮件,再发送注册短信,以上三个任务全部完成后才返回给客户端。 这有一个问题是,邮件,短信并不是必须的,它只是一个通知,而这种做法让客户端等待没有必要等待的东西. </p><h3 id="并行方式"><a href="#并行方式" class="headerlink" title="并行方式"></a>并行方式</h3><p>将注册信息写入数据库后,发送邮件的同时,发送短信,以上三个任务完成后,返回给客户端,并行的方式能提高处理的时间。 </p><p>假设三个业务节点分别使用50ms,串行方式使用时间150ms,并行使用时间100ms。虽然并性已经提高的处理时间,但是,前面说过,邮件和短信对我正常的使用网站没有任何影响，客户端没有必要等着其发送完成才显示注册成功,英爱是写入数据库后就返回. </p><h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p>引入消息队列后，把发送邮件,短信不是必须的业务逻辑异步处理 </p><p>由此可以看出,引入消息队列后，用户的响应时间就等于写入数据库的时间+写入消息队列的时间(可以忽略不计),引入消息队列后处理后,响应时间是串行的3倍,是并行的2倍。</p><h2 id="应用解耦"><a href="#应用解耦" class="headerlink" title="应用解耦"></a>应用解耦</h2><p>场景：双11是购物狂节,用户下单后,订单系统需要通知库存系统,传统的做法就是订单系统调用库存系统的接口. </p><p>这种做法有一个缺点:</p><p>当库存系统出现故障时,订单就会失败。(这样马云将少赚好多好多钱^ ^)<br>订单系统和库存系统高耦合.<br>引入消息队列 </p><p>订单系统:用户下单后,订单系统完成持久化处理,将消息写入消息队列,返回用户订单下单成功。</p><p>库存系统:订阅下单的消息,获取下单消息,进行库操作。 </p><p>就算库存系统出现故障,消息队列也能保证消息的可靠投递,不会导致消息丢失(马云这下高兴了).</p><h2 id="流量削峰"><a href="#流量削峰" class="headerlink" title="流量削峰"></a>流量削峰</h2><p>流量削峰一般在秒杀活动中应用广泛 </p><p>场景:秒杀活动，一般会因为流量过大，导致应用挂掉,为了解决这个问题，一般在应用前端加入消息队列。 </p><h3 id="作用"><a href="#作用" class="headerlink" title="作用:"></a>作用:</h3><p>1.可以控制活动人数，超过此一定阀值的订单直接丢弃(我为什么秒杀一次都没有成功过呢^^)<br>2.可以缓解短时间的高流量压垮应用(应用程序按自己的最大处理能力获取订单) </p><p>1.用户的请求,服务器收到之后,首先写入消息队列,加入消息队列长度超过最大值,则直接抛弃用户请求或跳转到错误页面.<br>2.秒杀业务根据消息队列中的请求信息，再做后续处理.</p><h1 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h1><p>Rabbitmq系统最核心的组件是Exchange和Queue。</p><p>Exchange和Queue是在rabbitmq server（又叫做broker）端，producer和consumer在应用端。</p><h2 id="producer-amp-Consumer"><a href="#producer-amp-Consumer" class="headerlink" title="producer&amp;Consumer"></a>producer&amp;Consumer</h2><p>producer指的是消息生产者，consumer消息的消费者。</p><h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h2><p>消息队列，提供了FIFO的处理机制，具有缓存消息的能力。rabbitmq中，队列消息可以设置为持久化，临时或者自动删除。</p><ul><li>设置为持久化的队列，queue中的消息会在server本地硬盘存储一份，防止系统crash，数据丢失</li><li>设置为临时队列，queue中的数据在系统重启之后就会丢失</li><li>设置为自动删除的队列，当不存在用户连接到server，队列中的数据会被自动删除</li></ul><h2 id="Exchange"><a href="#Exchange" class="headerlink" title="Exchange"></a>Exchange</h2><p>Exchange类似于数据通信网络中的交换机，提供消息路由策略。rabbitmq中，producer不是通过信道直接将消息发送给queue，而是先发送给Exchange。一个Exchange可以和多个Queue进行绑定，producer在传递消息的时候，会传递一个ROUTING_KEY，Exchange会根据这个ROUTING_KEY按照特定的路由算法，将消息路由给指定的queue。和Queue一样，Exchange也可设置为持久化，临时或者自动删除。</p><p>Exchange有4种类型：direct(默认)，fanout, topic, 和headers，不同类型的Exchange转发消息的策略有所区别：</p><h3 id="Direct"><a href="#Direct" class="headerlink" title="Direct"></a>Direct</h3><p>直接交换器，工作方式类似于单播，Exchange会将消息发送完全匹配ROUTING_KEY的Queue</p><h3 id="fanout"><a href="#fanout" class="headerlink" title="fanout"></a>fanout</h3><p>广播是式交换器，不管消息的ROUTING_KEY设置为什么，Exchange都会将消息转发给所有绑定的Queue。</p><h3 id="topic"><a href="#topic" class="headerlink" title="topic"></a>topic</h3><p>主题交换器，工作方式类似于组播，Exchange会将消息转发和ROUTING_KEY匹配模式相同的所有队列，比如，ROUTING_KEY为user.stock的Message会转发给绑定匹配模式为 <em> .stock,user.stock， </em> . <em> 和#.user.stock.#的队列。（ </em> 表是匹配一个任意词组，#表示匹配0个或多个词组）</p><h3 id="headers"><a href="#headers" class="headerlink" title="headers"></a>headers</h3><p>消息体的header匹配（ignore）</p><h2 id="Binding"><a href="#Binding" class="headerlink" title="Binding"></a>Binding</h2><p>所谓绑定就是将一个特定的 Exchange 和一个特定的 Queue 绑定起来。Exchange 和Queue的绑定可以是多对多的关系。</p><h2 id="virtual-host"><a href="#virtual-host" class="headerlink" title="virtual host"></a>virtual host</h2><p>在rabbitmq server上可以创建多个虚拟的message broker，又叫做virtual hosts (vhosts)。每一个vhost本质上是一个mini-rabbitmq server，分别管理各自的exchange，和bindings。vhost相当于物理的server，可以为不同app提供边界隔离，使得应用安全的运行在不同的vhost实例上，相互之间不会干扰。producer和consumer连接rabbit server需要指定一个vhost。</p><h2 id="通信过程"><a href="#通信过程" class="headerlink" title="通信过程"></a>通信过程</h2><p>假设P1和C1注册了相同的Broker，Exchange和Queue。P1发送的消息最终会被C1消费。基本的通信流程大概如下所示：</p><ol><li>P1生产消息，发送给服务器端的Exchange</li><li>Exchange收到消息，根据ROUTINKEY，将消息转发给匹配的Queue1</li><li>Queue1收到消息，将消息发送给订阅者C1</li><li>C1收到消息，发送ACK给队列确认收到消息</li><li>Queue1收到ACK，删除队列中缓存的此条消息</li><li>Consumer收到消息时需要显式的向rabbit broker发送basic.ack消息或者consumer订阅消息时设置auto_ack参数为true。在通信过程中，队列对ACK的处理有以下几种情况：</li></ol><ul><li>如果consumer接收了消息，发送ack,rabbitmq会删除队列中这个消息，发送另一条消息给consumer。</li><li>如果cosumer接受了消息, 但在发送ack之前断开连接，rabbitmq会认为这条消息没有被deliver,在consumer在次连接的时候，这条消息会被redeliver。</li><li>如果consumer接受了消息，但是程序中有bug,忘记了ack,rabbitmq不会重复发送消息。</li></ul><p>rabbitmq2.0.0和之后的版本支持consumer reject某条（类）消息，可以通过设置requeue参数中的reject为true达到目地，那么rabbitmq将会把消息发送给下一个注册的consumer。</p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>redis的内存淘汰机制</title>
      <link href="/2018/07/06/redis%E7%9A%84%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E6%9C%BA%E5%88%B6/"/>
      <url>/2018/07/06/redis%E7%9A%84%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E6%9C%BA%E5%88%B6/</url>
      <content type="html"><![CDATA[<p>Redis提供了下面几种淘汰策略供用户选择，其中默认的策略为noeviction策略：</p><ul><li>noeviction：当内存使用达到阈值的时候，所有引起申请内存的命令会报错。</li><li>allkeys-lru：在主键空间中，优先移除最近未使用的key。</li><li>volatile-lru：在设置了过期时间的键空间中，优先移除最近未使用的key。</li><li>allkeys-random：在主键空间中，随机移除某个key。</li><li>volatile-random：在设置了过期时间的键空间中，随机移除某个key。</li><li>volatile-ttl：在设置了过期时间的键空间中，具有更早过期时间的key优先移除。</li></ul><p>这里补充一下主键空间和设置了过期时间的键空间，举个例子，假设我们有一批键存储在Redis中，则有那么一个哈希表用于存储这批键及其值，如果这批键中有一部分设置了过期时间，那么这批键还会被存储到另外一个哈希表中，这个哈希表中的值对应的是键被设置的过期时间。设置了过期时间的键空间为主键空间的子集。</p><p>我们了解了Redis大概提供了这么几种淘汰策略，那么如何选择呢？淘汰策略的选择可以通过下面的配置指定：</p><h1 id="maxmemory-policy-noeviction"><a href="#maxmemory-policy-noeviction" class="headerlink" title="maxmemory-policy noeviction"></a>maxmemory-policy noeviction</h1><p>但是这个值填什么呢？为解决这个问题，我们需要了解我们的应用请求对于Redis中存储的数据集的访问方式以及我们的诉求是什么。同时Redis也支持Runtime修改淘汰策略，这使得我们不需要重启Redis实例而实时的调整内存淘汰策略。</p><p>下面看看几种策略的适用场景：</p><ul><li>allkeys-lru：如果我们的应用对缓存的访问符合幂律分布（也就是存在相对热点数据），或者我们不太清楚我们应用的缓存访问分布状况，我们可以选择allkeys-lru策略。</li><li>allkeys-random：如果我们的应用对于缓存key的访问概率相等，则可以使用这个策略。</li><li>volatile-ttl：这种策略使得我们可以向Redis提示哪些key更适合被eviction。<br>另外，volatile-lru策略和volatile-random策略适合我们将一个Redis实例既应用于缓存和又应用于持久化存储的时候，然而我们也可以通过使用两个Redis实例来达到相同的效果，值得一提的是将key设置过期时间实际上会消耗更多的内存，因此我们建议使用allkeys-lru策略从而更有效率的使用内存。</li></ul>]]></content>
      
      
    </entry>
    
    <entry>
      <title>一致性哈希算法</title>
      <link href="/2018/07/06/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/"/>
      <url>/2018/07/06/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/</url>
      <content type="html"><![CDATA[<h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><p>为了解决普通取余哈希算法时增加和移除机器时迁移成本太高的问题</p><h3 id="一致性哈希算法"><a href="#一致性哈希算法" class="headerlink" title="一致性哈希算法"></a>一致性哈希算法</h3><p>哈希到2的32次方或者其他值上，根据机器id也是计算出哈希值，顺时针进行映射。</p><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>为了解决不均衡问题，引入了虚拟节点。</p>]]></content>
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>交换两个变量的值，不使用第3个变量</title>
      <link href="/2018/07/06/%E4%BA%A4%E6%8D%A2%E4%B8%A4%E4%B8%AA%E5%8F%98%E9%87%8F%E7%9A%84%E5%80%BC%EF%BC%8C%E4%B8%8D%E4%BD%BF%E7%94%A8%E7%AC%AC3%E4%B8%AA%E5%8F%98%E9%87%8F/"/>
      <url>/2018/07/06/%E4%BA%A4%E6%8D%A2%E4%B8%A4%E4%B8%AA%E5%8F%98%E9%87%8F%E7%9A%84%E5%80%BC%EF%BC%8C%E4%B8%8D%E4%BD%BF%E7%94%A8%E7%AC%AC3%E4%B8%AA%E5%8F%98%E9%87%8F/</url>
      <content type="html"><![CDATA[<h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><p>a=a^b;<br>b=a^b=(a^b)^b=^a^(b^b)=a=a^(111…)=a<br>a=a^b=a^(a^b)=(a^a)^b=(111…)^b=b</p>]]></content>
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>关于volatile</title>
      <link href="/2018/07/06/%E5%85%B3%E4%BA%8Evolatile/"/>
      <url>/2018/07/06/%E5%85%B3%E4%BA%8Evolatile/</url>
      <content type="html"><![CDATA[<h2 id="能保证什么"><a href="#能保证什么" class="headerlink" title="能保证什么"></a>能保证什么</h2><p>可见性</p><h3 id="是否线程安全"><a href="#是否线程安全" class="headerlink" title="是否线程安全"></a>是否线程安全</h3><p>否，保证不了复合操作，比如i++之类的原子性，也就不能保证线程安全</p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>Java实现多线程的方式</title>
      <link href="/2018/07/06/Java%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E5%BC%8F/"/>
      <url>/2018/07/06/Java%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E5%BC%8F/</url>
      <content type="html"><![CDATA[<h2 id="继承Thread"><a href="#继承Thread" class="headerlink" title="继承Thread"></a>继承Thread</h2><h2 id="实现Runnable"><a href="#实现Runnable" class="headerlink" title="实现Runnable"></a>实现Runnable</h2><h2 id="实现Callable接口通过FutureTask包装器来创建Thread线程"><a href="#实现Callable接口通过FutureTask包装器来创建Thread线程" class="headerlink" title="实现Callable接口通过FutureTask包装器来创建Thread线程"></a>实现Callable接口通过FutureTask包装器来创建Thread线程</h2><h2 id="使用ExecutorService、Callable、Future实现有返回结果的线程"><a href="#使用ExecutorService、Callable、Future实现有返回结果的线程" class="headerlink" title="使用ExecutorService、Callable、Future实现有返回结果的线程"></a>使用ExecutorService、Callable、Future实现有返回结果的线程</h2>]]></content>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>jvm基本结构</title>
      <link href="/2018/07/06/jvm%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84/"/>
      <url>/2018/07/06/jvm%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84/</url>
      <content type="html"><![CDATA[<h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><ol><li>类加载子系统<br>加载class信息，加载的类信息放在方法区,方法区还放运行时常量池信息，包括字符串和数字常量，是class文件中常量池部分的内存映射。</li><li>Java栈<br>线程私有，保存帧信息，局部变量、方法参数、返回类型等    </li><li>方法区<br>加载class信息，加载的类信息，比如字段、方法、常量等，放在方法区,方法区还放运行时常量池信息，包括字符串和数字常量，是class文件中常量池部分的内存映射。<br>JDK6、7中，方法区可以理解为永久区，-XX:PermSize， -XX:MaxPermSize 默认MaxPermSize为64M,如果使用了动态代理，需要设置合适大小。<br>JDK1.8中 ，使用元数据区，-XX:MaxMetaspaceSize,使用堆外的直接内存，上限就是系统内存上限。</li><li>Java堆<br><em>几乎所有</em>的对象实例都存在于Java堆中，堆空间是线程共享的。</li><li>直接内存<br>Java堆外的，NIO使用直接内存，不会受限与Xmx</li><li>本地方法栈<br>调用本地方法，通常是C写的</li><li>垃圾回收系统<br>对方法区，Java堆和直接内存进行回收。</li><li>PC寄存器<br>线程私有，如果本地方法，指向当前正在被执行的指令，如果是，值为undefined</li><li>执行引擎<br>执行虚拟机字节码或者热点数据编译后的机器码</li></ol><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ol><li>线程私有<br>Java栈、本地方法栈、PC寄存器</li><li>线程共享<br>Java堆，直接内存，方法区</li></ol><p><a href="https://chriswhocodes.com/hotspot_options_jdk8.html" target="_blank" rel="noopener">https://chriswhocodes.com/hotspot_options_jdk8.html</a></p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>Spring之AOP</title>
      <link href="/2018/07/06/Spring%E4%B9%8BAOP/"/>
      <url>/2018/07/06/Spring%E4%B9%8BAOP/</url>
      <content type="html"><![CDATA[<h2 id="代理机制"><a href="#代理机制" class="headerlink" title="代理机制"></a>代理机制</h2><ul><li>JDK 只提供接口的代理</li><li>CGLIB 同时支持接口和类的代理</li></ul>]]></content>
      
      
    </entry>
    
    <entry>
      <title>Hashmap</title>
      <link href="/2018/07/06/Hashmap/"/>
      <url>/2018/07/06/Hashmap/</url>
      <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>从本文你可以学习到：</p><p>什么时候会使用HashMap？他有什么特点？<br>你知道HashMap的工作原理吗？<br>你知道get和put的原理吗？equals()和hashCode()的都有什么作用？<br>你知道hash的实现吗？为什么要这样实现？<br>如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？</p><p>在官方文档中是这样描述HashMap的：</p><p>Hash table based implementation of the Map interface. This implementation provides all of the optional map operations, and permits null values and the null key. (The HashMap class is roughly equivalent to Hashtable, except that it is unsynchronized and permits nulls.) This class makes no guarantees as to the order of the map; in particular, it does not guarantee that the order will remain constant over time.</p><p>几个关键的信息：基于Map接口实现、允许null键/值、非同步、不保证有序(比如插入的顺序)、也不保证序不随时间变化。</p><h1 id="两个重要的参数"><a href="#两个重要的参数" class="headerlink" title="两个重要的参数"></a>两个重要的参数</h1><p>在HashMap中有两个很重要的参数，容量(Capacity)和负载因子(Load factor)</p><p>Initial capacity The capacity is the number of buckets in the hash table, The initial capacity is simply the capacity at the time the hash table is created.</p><p>Load factor The load factor is a measure of how full the hash table is allowed to get before its capacity is automatically increased.</p><p>简单的说，Capacity就是bucket的大小，Load factor就是bucket填满程度的最大比例。如果对迭代性能要求很高的话不要把capacity设置过大，也不要把load factor设置过小。当bucket中的entries的数目大于capacity*load factor时就需要调整bucket的大小为当前的2倍。</p><h1 id="put函数的实现"><a href="#put函数的实现" class="headerlink" title="put函数的实现"></a>put函数的实现</h1><p>put函数大致的思路为：</p><p>对key的hashCode()做hash，然后再计算index;<br>如果没碰撞直接放到bucket里；<br>如果碰撞了，以链表的形式存在buckets后；<br>如果碰撞导致链表过长(大于等于TREEIFY_THRESHOLD)，就把链表转换成红黑树；<br>如果节点已经存在就替换old value(保证key的唯一性)<br>如果bucket满了(超过load factor*current capacity)，就要resize。</p><h1 id="get函数的实现"><a href="#get函数的实现" class="headerlink" title="get函数的实现"></a>get函数的实现</h1><p>在理解了put之后，get就很简单了。大致思路如下：</p><p>bucket里的第一个节点，直接命中；<br>如果有冲突，则通过key.equals(k)去查找对应的entry<br>若为树，则在树中通过key.equals(k)查找，O(logn)；<br>若为链表，则在链表中通过key.equals(k)查找，O(n)。</p><h1 id="hash函数的实现"><a href="#hash函数的实现" class="headerlink" title="hash函数的实现"></a>hash函数的实现</h1><p>在get和put的过程中，计算下标时，先对hashCode进行hash操作，然后再通过hash值进一步计算下标，如下图所示：</p><h1 id="resize的实现"><a href="#resize的实现" class="headerlink" title="resize的实现"></a>resize的实现</h1><p>当put时，如果发现目前的bucket占用程度已经超过了Load Factor所希望的比例，那么就会发生resize。在resize的过程，简单的说就是把bucket扩充为2倍，之后重新计算index，把节点再放到新的bucket中。resize的注释是这样描述的：</p><p>Initializes or doubles table size. If null, allocates in accord with initial capacity target held in field threshold. Otherwise, because we are using power-of-two expansion, the elements from each bin must either stay at same index, or move with a power of two offset in the new table.</p><p>大致意思就是说，当超过限制的时候会resize，然而又因为我们使用的是2次幂的扩展(指长度扩为原来2倍)，所以，元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置。</p><p>怎么理解呢？例如我们从16扩展为32时，具体的变化如下所示：</p><p>因此元素在重新计算hash之后，因为n变为2倍，那么n-1的mask范围在高位多1bit(红色)，因此新的index就会发生这样的变化：</p><p>因此，我们在扩充HashMap的时候，不需要重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”。可以看看下图为16扩充为32的resize示意图：</p><p>这个设计确实非常的巧妙，既省去了重新计算hash值的时间，而且同时，</p><blockquote><p>由于新增的1bit是0还是1可以认为是随机的，</p></blockquote><p> 因此resize的过程，均匀的把之前的冲突的节点分散到新的bucket了。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>我们现在可以回答开始的几个问题，加深对HashMap的理解：</p><h2 id="什么时候会使用HashMap？他有什么特点？"><a href="#什么时候会使用HashMap？他有什么特点？" class="headerlink" title="什么时候会使用HashMap？他有什么特点？"></a>什么时候会使用HashMap？他有什么特点？</h2><p>是基于Map接口的实现，存储键值对时，它可以接收null的键值，是非同步的，HashMap存储着Entry(hash, key, value, next)对象。</p><h2 id="你知道HashMap的工作原理吗？"><a href="#你知道HashMap的工作原理吗？" class="headerlink" title="你知道HashMap的工作原理吗？"></a>你知道HashMap的工作原理吗？</h2><p>通过hash的方法，通过put和get存储和获取对象。存储对象时，我们将K/V传给put方法时，它调用hashCode计算hash从而得到bucket位置，进一步存储，HashMap会根据当前bucket的占用情况自动调整容量(超过Load Facotr则resize为原来的2倍)。获取对象时，我们将K传给get，它调用hashCode计算hash从而得到bucket位置，并进一步调用equals()方法确定键值对。如果发生碰撞的时候，Hashmap通过链表将产生碰撞冲突的元素组织起来，在Java 8中，如果一个bucket中碰撞冲突的元素超过某个限制(默认是8)，则使用红黑树来替换链表，从而提高速度。</p><h2 id="你知道get和put的原理吗？equals-和hashCode-的都有什么作用？"><a href="#你知道get和put的原理吗？equals-和hashCode-的都有什么作用？" class="headerlink" title="你知道get和put的原理吗？equals()和hashCode()的都有什么作用？"></a>你知道get和put的原理吗？equals()和hashCode()的都有什么作用？</h2><p>通过对key的hashCode()进行hashing，并计算下标( n-1 &amp; hash)，从而获得buckets的位置。如果产生碰撞，则利用key.equals()方法去链表或树中去查找对应的节点</p><h2 id="你知道hash的实现吗？为什么要这样实现？"><a href="#你知道hash的实现吗？为什么要这样实现？" class="headerlink" title="你知道hash的实现吗？为什么要这样实现？"></a>你知道hash的实现吗？为什么要这样实现？</h2><p>在Java 1.8的实现中，是通过hashCode()的高16位异或低16位实现的：(h = k.hashCode()) ^ (h &gt;&gt;&gt; 16)，主要是从速度、功效、质量来考虑的，这么做可以在bucket的n比较小的时候，也能保证考虑到高低bit都参与到hash的计算中，同时不会有太大的开销。</p><h2 id="如果HashMap的大小超过了负载因子-load-factor-定义的容量，怎么办？"><a href="#如果HashMap的大小超过了负载因子-load-factor-定义的容量，怎么办？" class="headerlink" title="如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？"></a>如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？</h2><p>如果超过了负载因子(默认0.75)，则会重新resize一个原来长度两倍的HashMap，并且重新调用hash方法。</p><h2 id="关于Java集合的小抄中是这样描述的："><a href="#关于Java集合的小抄中是这样描述的：" class="headerlink" title="关于Java集合的小抄中是这样描述的："></a>关于Java集合的小抄中是这样描述的：</h2><p>以Entry[]数组实现的哈希桶数组，用Key的哈希值取模桶数组的大小可得到数组下标。</p><p>插入元素时，如果两条Key落在同一个桶(比如哈希值1和17取模16后都属于第一个哈希桶)，Entry用一个next属性实现多个Entry以单向链表存放，后入桶的Entry将next指向桶当前的Entry。</p><p>查找哈希值为17的key时，先定位到第一个哈希桶，然后以链表遍历桶里所有元素，逐个比较其key值。</p><p>当Entry数量达到桶数量的75%时(很多文章说使用的桶数量达到了75%，但看代码不是)，会成倍扩容桶数组，并重新分配所有原来的Entry，所以这里也最好有个预估值。</p><p>取模用位运算(hash &amp; (arrayLength-1))会比较快，所以数组的大小永远是2的N次方， 你随便给一个初始值比如17会转为32。默认第一次放入元素时的初始值是16。</p><p>iterator()时顺着哈希桶数组来遍历，看起来是个乱序。</p><p>在JDK8里，新增默认为8的閥值，当一个桶里的Entry超过閥值，就不以单向链表而以红黑树来存放以加快Key的查找</p><h1 id="线程安全用法"><a href="#线程安全用法" class="headerlink" title="线程安全用法"></a>线程安全用法</h1><p>Collection.synchronize(hashmap);<br>hashtable<br>ConcurrentHashMap</p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>sql面试题之学生教师课程分数</title>
      <link href="/2018/07/05/sql%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8B%E5%AD%A6%E7%94%9F%E6%95%99%E5%B8%88%E8%AF%BE%E7%A8%8B%E5%88%86%E6%95%B0/"/>
      <url>/2018/07/05/sql%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8B%E5%AD%A6%E7%94%9F%E6%95%99%E5%B8%88%E8%AF%BE%E7%A8%8B%E5%88%86%E6%95%B0/</url>
      <content type="html"><![CDATA[<pre><code>SET FOREIGN_KEY_CHECKS=0;-- ------------------------------ Table structure for course-- ----------------------------DROP TABLE IF EXISTS `course`;CREATE TABLE `course` (`id` int(11) DEFAULT NULL,`name` varchar(32) CHARACTER SET utf8 DEFAULT NULL,`teacher_id` int(11) DEFAULT NULL) ENGINE=InnoDB DEFAULT CHARSET=gbk;-- ------------------------------ Records of course-- ----------------------------INSERT INTO `course` VALUES (&#39;1&#39;, &#39;语文&#39;, &#39;1&#39;);INSERT INTO `course` VALUES (&#39;2&#39;, &#39;数学&#39;, &#39;2&#39;);INSERT INTO `course` VALUES (&#39;3&#39;, &#39;英语&#39;, &#39;3&#39;);-- ------------------------------ Table structure for score-- ----------------------------DROP TABLE IF EXISTS `score`;CREATE TABLE `score` (`student_id` int(10) DEFAULT NULL,`course_id` int(10) DEFAULT NULL,`score` int(5) DEFAULT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;-- ------------------------------ Records of score-- ----------------------------INSERT INTO `score` VALUES (&#39;1&#39;, &#39;1&#39;, ceiling(rand()*60+40));INSERT INTO `score` VALUES (&#39;2&#39;, &#39;1&#39;, ceiling(rand()*60+40));INSERT INTO `score` VALUES (&#39;3&#39;, &#39;1&#39;, ceiling(rand()*60+40));INSERT INTO `score` VALUES (&#39;4&#39;, &#39;1&#39;, ceiling(rand()*60+40));INSERT INTO `score` VALUES (&#39;5&#39;, &#39;1&#39;, ceiling(rand()*60+40));INSERT INTO `score` VALUES (&#39;6&#39;, &#39;1&#39;, ceiling(rand()*60+40));INSERT INTO `score` VALUES (&#39;1&#39;, &#39;2&#39;, ceiling(rand()*60+40));INSERT INTO `score` VALUES (&#39;2&#39;, &#39;2&#39;, ceiling(rand()*60+40));INSERT INTO `score` VALUES (&#39;3&#39;, &#39;2&#39;, ceiling(rand()*60+40));INSERT INTO `score` VALUES (&#39;4&#39;, &#39;2&#39;, ceiling(rand()*60+40));INSERT INTO `score` VALUES (&#39;5&#39;, &#39;2&#39;, ceiling(rand()*60+40));INSERT INTO `score` VALUES (&#39;6&#39;, &#39;2&#39;, ceiling(rand()*60+40));INSERT INTO `score` VALUES (&#39;1&#39;, &#39;3&#39;, ceiling(rand()*60+40));INSERT INTO `score` VALUES (&#39;2&#39;, &#39;3&#39;, ceiling(rand()*60+40));INSERT INTO `score` VALUES (&#39;3&#39;, &#39;3&#39;, ceiling(rand()*60+40));INSERT INTO `score` VALUES (&#39;4&#39;, &#39;3&#39;, ceiling(rand()*60+40));INSERT INTO `score` VALUES (&#39;5&#39;, &#39;3&#39;, ceiling(rand()*60+40));INSERT INTO `score` VALUES (&#39;6&#39;, &#39;3&#39;, ceiling(rand()*60+40));-- ------------------------------ Table structure for student-- ----------------------------DROP TABLE IF EXISTS `student`;CREATE TABLE `student` (`id` int(11) DEFAULT NULL,`name` varchar(32) CHARACTER SET utf8 DEFAULT NULL) ENGINE=InnoDB DEFAULT CHARSET=gbk;-- ------------------------------ Records of student-- ----------------------------INSERT INTO `student` VALUES (&#39;1&#39;, &#39;刘一&#39;);INSERT INTO `student` VALUES (&#39;2&#39;, &#39;钱二&#39;);INSERT INTO `student` VALUES (&#39;3&#39;, &#39;张三&#39;);INSERT INTO `student` VALUES (&#39;4&#39;, &#39;李四&#39;);INSERT INTO `student` VALUES (&#39;5&#39;, &#39;王五&#39;);INSERT INTO `student` VALUES (&#39;6&#39;, &#39;赵六&#39;);-- ------------------------------ Table structure for teacher-- ----------------------------DROP TABLE IF EXISTS `teacher`;CREATE TABLE `teacher` (`id` int(11) DEFAULT NULL,`name` varchar(16) CHARACTER SET utf8 DEFAULT NULL) ENGINE=InnoDB DEFAULT CHARSET=gbk;-- ------------------------------ Records of teacher-- ----------------------------INSERT INTO `teacher` VALUES (&#39;1&#39;, &#39;叶平&#39;);INSERT INTO `teacher` VALUES (&#39;2&#39;, &#39;贺高&#39;);INSERT INTO `teacher` VALUES (&#39;3&#39;, &#39;杨艳&#39;);INSERT INTO `teacher` VALUES (&#39;4&#39;, &#39;周磊&#39;);-- ----------------------------</code></pre><h1 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h1><h2 id="from-子查询"><a href="#from-子查询" class="headerlink" title="from 子查询"></a>from 子查询</h2><h3 id="查询“语文”课程比“数学”课程成绩高的所有学生的学号和姓名；"><a href="#查询“语文”课程比“数学”课程成绩高的所有学生的学号和姓名；" class="headerlink" title="查询“语文”课程比“数学”课程成绩高的所有学生的学号和姓名；"></a>查询“语文”课程比“数学”课程成绩高的所有学生的学号和姓名；</h3><ol><li>查询所有的学生的语文分数 score_chinese</li><li>查询所有学生的数学分数 score_math</li><li>连接score_chinese和score_math</li><li>条件是语文大于数学分数</li><li><p>取出score_chinese的语文</p><p> SELECT</p><pre><code> score_chinese.student_id, score_chinese.student_name</code></pre><p> FROM</p><pre><code> (     SELECT         score.score,         student.id student_id,         student.`name` student_name     FROM         score,         student,         course     WHERE         score.course_id = course.id     AND score.student_id = student.id     AND course. NAME = &#39;语文&#39; ) score_chinese, (     SELECT         score.score,         student.id student_id,         student.`name` student_name     FROM         score,         student,         course     WHERE         score.course_id = course.id     AND score.student_id = student.id     AND course. NAME = &#39;数学&#39; ) score_math</code></pre><p> WHERE</p><pre><code> score_chinese.student_id = score_math.student_id</code></pre><p> AND score_chinese.score &gt; score_math.score</p></li></ol><h2 id="select-子查询"><a href="#select-子查询" class="headerlink" title="select 子查询"></a>select 子查询</h2><h3 id="查询学生平均成绩及其名次"><a href="#查询学生平均成绩及其名次" class="headerlink" title="查询学生平均成绩及其名次"></a>查询学生平均成绩及其名次</h3><pre><code>SELECT    1 + (        SELECT            COUNT(others_avg_score)        FROM            (                SELECT                    student_id,                    AVG(score) AS others_avg_score                FROM                    score                GROUP BY                    student_id            ) AS score_1        WHERE            others_avg_score &gt; my.my_avg_score    ) AS 名次,    student_id 学生学号,    my.my_avg_score 平均成绩FROM    (        SELECT            student_id,            AVG(score) my_avg_score        FROM            score        GROUP BY            student_id    ) AS myORDER BY    my_avg_score DESC;</code></pre><h2 id="group-by-和having"><a href="#group-by-和having" class="headerlink" title="group by 和having"></a>group by 和having</h2><h3 id="查询平均成绩大于70分的同学的学号和平均成绩；"><a href="#查询平均成绩大于70分的同学的学号和平均成绩；" class="headerlink" title="查询平均成绩大于70分的同学的学号和平均成绩；"></a>查询平均成绩大于70分的同学的学号和平均成绩；</h3><pre><code>SELECT    score.student_id,    AVG(score)FROM    scoreGROUP BY    score.student_idHAVING    avg(score) &gt; 70</code></pre><p>SELECT<br>    student_id<br>FROM<br>    score<br>WHERE<br>    course_id IN (<br>        SELECT<br>            course_id<br>        FROM<br>            score<br>        WHERE<br>            student_id = ‘2’<br>    )<br>GROUP BY<br>    student_id<br>HAVING<br>    count(<em>) = (<br>        SELECT<br>            count(</em>)<br>        FROM<br>            score<br>        WHERE<br>            student_id = ‘2’<br>    );</p><h3 id="查询和“2”号的同学学习的课程完全相同的其他同学学号和姓名；"><a href="#查询和“2”号的同学学习的课程完全相同的其他同学学号和姓名；" class="headerlink" title="查询和“2”号的同学学习的课程完全相同的其他同学学号和姓名；"></a>查询和“2”号的同学学习的课程完全相同的其他同学学号和姓名；</h3><pre><code>SELECT    student_idFROM    scoreWHERE    course_id IN (        SELECT            course_id        FROM            score        WHERE            student_id = &#39;2&#39;    )GROUP BY    student_idHAVING    count(*) = (        SELECT            count(*)        FROM            score        WHERE            student_id = &#39;2&#39;    );</code></pre><h3 id="查询所有同学的学号、姓名、选课数、总成绩；"><a href="#查询所有同学的学号、姓名、选课数、总成绩；" class="headerlink" title="查询所有同学的学号、姓名、选课数、总成绩；"></a>查询所有同学的学号、姓名、选课数、总成绩；</h3><pre><code>SELECT    student.id,    student.name,    count(score.course_id),    sum(score)FROM    student,    scoreWHERE    student.id = score.student_idGROUP BY    student.id</code></pre><h2 id="in-not-in-any-all-exists子查询"><a href="#in-not-in-any-all-exists子查询" class="headerlink" title="in,not in ,any,all,exists子查询"></a>in,not in ,any,all,exists子查询</h2><h3 id="查询没学过“叶平”老师课的同学的学号、姓名；"><a href="#查询没学过“叶平”老师课的同学的学号、姓名；" class="headerlink" title="查询没学过“叶平”老师课的同学的学号、姓名；"></a>查询没学过“叶平”老师课的同学的学号、姓名；</h3><pre><code>SELECT    student.id,    student.`name`FROM    studentWHERE    id NOT IN (        SELECT DISTINCT            score.student_id        FROM            score,            course,            teacher        WHERE            score.course_id = course.id        AND course.teacher_id = teacher.id        AND teacher.`name` = &#39;叶平&#39;    );</code></pre><h3 id="查询学过“1”并且也学过编号“2”课程的同学的学号、姓名；"><a href="#查询学过“1”并且也学过编号“2”课程的同学的学号、姓名；" class="headerlink" title="查询学过“1”并且也学过编号“2”课程的同学的学号、姓名；"></a>查询学过“1”并且也学过编号“2”课程的同学的学号、姓名；</h3><pre><code>SELECTstudent.id,student.`name`FROM    student,    scoreWHERE    student.id = score.student_idAND score.course_id = 1AND EXISTS (    SELECT        *    FROM        score score_2    WHERE        score_2.student_id = score.student_id    AND score_2.course_id = 2)</code></pre><h3 id="查询至少有一门课与学号为“1”的同学所学相同的同学的学号和姓名；"><a href="#查询至少有一门课与学号为“1”的同学所学相同的同学的学号和姓名；" class="headerlink" title="查询至少有一门课与学号为“1”的同学所学相同的同学的学号和姓名；"></a>查询至少有一门课与学号为“1”的同学所学相同的同学的学号和姓名；</h3><pre><code>SELECT DISTINCT    id,    NAMEFROM    student,    scoreWHERE    student.id = score.student_idAND score.course_id IN (    SELECT        score.course_id    FROM        score    WHERE        student_id = &#39;1&#39;);</code></pre><h2 id="gt-lt-子查询"><a href="#gt-lt-子查询" class="headerlink" title="= &gt; &lt; 子查询"></a>= &gt; &lt; 子查询</h2><h3 id="查询各科成绩最高和最低的分：以如下形式显示：课程ID，最高分，最低分"><a href="#查询各科成绩最高和最低的分：以如下形式显示：课程ID，最高分，最低分" class="headerlink" title="查询各科成绩最高和最低的分：以如下形式显示：课程ID，最高分，最低分"></a>查询各科成绩最高和最低的分：以如下形式显示：课程ID，最高分，最低分</h3><pre><code>SELECT    score_high.course_id 课程号,score_high.score 最高分,score_low.score 最低分FROM    score score_high,    score score_lowWHERE    score_high.course_id = score_low.course_idAND score_high.score = (    SELECT        max(score)    FROM        score,        student    WHERE        score.course_id = score_high.course_id    GROUP BY        score.course_id)AND score_low.score = (    SELECT        min(score)    FROM        score,        student    WHERE        score.course_id = score_low.course_id    GROUP BY        score.course_id);</code></pre><h2 id="至少系列"><a href="#至少系列" class="headerlink" title="至少系列"></a>至少系列</h2><h3 id="检索至少选修两门课程的学生学号"><a href="#检索至少选修两门课程的学生学号" class="headerlink" title="检索至少选修两门课程的学生学号"></a>检索至少选修两门课程的学生学号</h3><pre><code>SELECT    student_idFROM    scoreGROUP BY    student_idHAVING    count(*) &gt;= 2</code></pre><h3 id="查询至少有一门课与学号为“1”的同学所学相同的同学的学号和姓名；-1"><a href="#查询至少有一门课与学号为“1”的同学所学相同的同学的学号和姓名；-1" class="headerlink" title="查询至少有一门课与学号为“1”的同学所学相同的同学的学号和姓名；"></a>查询至少有一门课与学号为“1”的同学所学相同的同学的学号和姓名；</h3><pre><code>SELECT DISTINCT    id,    NAMEFROM    student,    scoreWHERE    student.id = score.student_idAND score.course_id IN (    SELECT        score.course_id    FROM        score    WHERE        student_id = &#39;1&#39;);</code></pre><h3 id="查询至少学过学号为“1”同学所有一门课的其他同学学号和姓名；"><a href="#查询至少学过学号为“1”同学所有一门课的其他同学学号和姓名；" class="headerlink" title="查询至少学过学号为“1”同学所有一门课的其他同学学号和姓名；"></a>查询至少学过学号为“1”同学所有一门课的其他同学学号和姓名；</h3>]]></content>
      
      <categories>
          
          <category> SQL </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>mock server简介</title>
      <link href="/2018/06/29/mock-server%E7%AE%80%E4%BB%8B/"/>
      <url>/2018/06/29/mock-server%E7%AE%80%E4%BB%8B/</url>
      <content type="html"><![CDATA[<ol><li>接触过的moco、wiremock</li><li>moco使用json文件做配置，wiremock使用restful接受模拟的response</li><li>好处是方便前后端共同开发</li><li>推荐用wiremock，可以调用项目中的一些变量和方法。</li><li></li></ol>]]></content>
      
      
    </entry>
    
    <entry>
      <title>使用swagger自动生成文档</title>
      <link href="/2018/06/29/%E4%BD%BF%E7%94%A8swagger%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E6%96%87%E6%A1%A3/"/>
      <url>/2018/06/29/%E4%BD%BF%E7%94%A8swagger%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E6%96%87%E6%A1%A3/</url>
      <content type="html"><![CDATA[<ol><li>增加swaager2和swaager-ui的依赖</li><li>springboot的mian类上加@EnableSwagger2注解</li><li>范围/swagger-ui.html</li><li>常用注解 @ApiOperation</li><li>配合jenkins，否则后端改了api不持续构建的话前端拿不到新的接口文档。</li></ol>]]></content>
      
      
    </entry>
    
    <entry>
      <title>单元测试实战</title>
      <link href="/2018/06/29/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E5%AE%9E%E6%88%98/"/>
      <url>/2018/06/29/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E5%AE%9E%E6%88%98/</url>
      <content type="html"><![CDATA[<p>使用h2内存数据库，配置ddl和dml，没有mock不能测试到dao层的缺点，也没有直接在mysql数据中做污染数据的缺点。</p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>使用python豆瓣自动顶贴以及识别验证码</title>
      <link href="/2018/06/29/%E4%BD%BF%E7%94%A8python%E8%B1%86%E7%93%A3%E8%87%AA%E5%8A%A8%E9%A1%B6%E8%B4%B4%E4%BB%A5%E5%8F%8A%E8%AF%86%E5%88%AB%E9%AA%8C%E8%AF%81%E7%A0%81/"/>
      <url>/2018/06/29/%E4%BD%BF%E7%94%A8python%E8%B1%86%E7%93%A3%E8%87%AA%E5%8A%A8%E9%A1%B6%E8%B4%B4%E4%BB%A5%E5%8F%8A%E8%AF%86%E5%88%AB%E9%AA%8C%E8%AF%81%E7%A0%81/</url>
      <content type="html"><![CDATA[<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p>使用python3，需要pytesseract，requests依赖</p><h2 id="安装Tesseract-OCR"><a href="#安装Tesseract-OCR" class="headerlink" title="安装Tesseract-OCR"></a>安装Tesseract-OCR</h2><p><a href="https://digi.bib.uni-mannheim.de/tesseract/tesseract-ocr-setup-4.0.0-alpha.20170804.exe" target="_blank" rel="noopener">https://digi.bib.uni-mannheim.de/tesseract/tesseract-ocr-setup-4.0.0-alpha.20170804.exe</a></p><p>配置path加上C:\Program Files (x86)\Tesseract-OCR\tesseract.exe</p><p>配置TESSDATA_PREFIX为C:\Program Files (x86)\Tesseract-OCR\tessdata</p><p>这些都是pytesseract需要的</p><h2 id="验证码"><a href="#验证码" class="headerlink" title="验证码"></a>验证码</h2><p>因为豆瓣的验证码都是英文，加上白名单只识别英文字母提高准确率   </p><pre><code>pytesseract.image_to_string(Image.open(&#39;imgs/rebuild.jpg&#39;),lang=&#39;eng&#39;,config=&quot;-c tessedit_char_whitelist=ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz --psm 7&quot;)</code></pre><p>参考:</p><p><a href="https://stackoverflow.com/questions/44619077/pytesseract-ocr-multiple-config-options" target="_blank" rel="noopener">https://stackoverflow.com/questions/44619077/pytesseract-ocr-multiple-config-options</a></p><p><a href="https://stackoverflow.com/questions/43705481/pytesser-set-character-whitelist" target="_blank" rel="noopener">https://stackoverflow.com/questions/43705481/pytesser-set-character-whitelist</a></p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>mybatis中的二级缓存</title>
      <link href="/2018/06/27/mybatis%E4%B8%AD%E7%9A%84%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98/"/>
      <url>/2018/06/27/mybatis%E4%B8%AD%E7%9A%84%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98/</url>
      <content type="html"><![CDATA[<ol><li>默认情况下,mybatis的二级缓存是开启的,但是没有使用;</li><li>在对象的mapper文件中直接开启<cache>,就可以为这个对象开启二级缓存(注意一下,在mybatis中,一般我们都不说二级缓存,我们就直接说缓存);</cache></li><li>在对象中开启了cache,这个对象的所有的select都享受到了缓存待遇;在mybatis中根本不会区分二级缓存和查询缓存;</li><li>需要使用缓存的对象必须实现序列化接口</li><li>现象:<br> get一个对象,插入一个对象,get一个对象,2条SELECT;<br> 对数据表的改变导致这个表关联对象的查询缓存全部失效;</li><li><p>缓存的控制:<br>1,可以通过select元素的useCache=false来关闭某一个查询不需要使用缓存;一般会把执行查询的缓存关闭,只保留get方法的查询缓存;<br>2,可以修改insert元素的flushCache=false来关闭insert语句对查询缓存的刷新;</p></li><li><p>使用第三方的缓存;(ehcache)<br>1,拷贝ehcache相关包,(mybatis-ehcache);<br>2,在对象上配置:<br><cache type="ehcache"><br>注意,这里的ehcache是<typealias type="org.mybatis.caches.ehcache.EhcacheCache" alias="ehcache"><br>3,把查询的对象放到指定的区块(在ehcache中,自定的cache的名字=这个mapper的namespace)</typealias></cache></p></li></ol>]]></content>
      
      
        <tags>
            
            <tag> MyBatis </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hibernate中的悲观锁和乐观锁</title>
      <link href="/2018/06/27/Hibernate%E4%B8%AD%E7%9A%84%E6%82%B2%E8%A7%82%E9%94%81%E5%92%8C%E4%B9%90%E8%A7%82%E9%94%81/"/>
      <url>/2018/06/27/Hibernate%E4%B8%AD%E7%9A%84%E6%82%B2%E8%A7%82%E9%94%81%E5%92%8C%E4%B9%90%E8%A7%82%E9%94%81/</url>
      <content type="html"><![CDATA[<p>使用Hibernate的锁机制主要是用来避免第一类丢失更新和第二类丢失更新;</p><h2 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h2><p>Hibernate使用悲观锁其实就是使用数据库锁：<br>如果数据库不支持设置的锁机制，hibernate会使用该数据库提供的合适的锁机制来完成，而不会报错。</p><p>事务延后执行，性能较低</p><ol><li><p>使用session.load(class,id,LockOptions);加悲观锁，相当于发送SELECT … FOR UPDATE</p></li><li><p>使用session.get(class,id,LockOptions);加悲观锁，相当于发送SELECT … FOR UPDATE</p></li><li><p>使用session.buildLockRequest(LockOptions).lock(entity);加悲观锁，相当于发送SELECT id FROM … FOR UPDATE</p></li><li><p>使用query.setLockOptions(LockOptions)；加悲观锁，相当于发送SELECT… FOR UPDATE</p></li></ol><h1 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h1><p>在hibernate中使用乐观锁，推荐使用version方式；</p><p>提供了和cas无锁类似的机制</p><ol><li><p>给对象添加一个int version字段，最好设置属性为private；</p></li><li><p>在mapping文件中添加<version>元素即可；</version></p></li></ol><h3 id="使用一个额外的版本控制字段来防止第二类丢失更新；"><a href="#使用一个额外的版本控制字段来防止第二类丢失更新；" class="headerlink" title="使用一个额外的版本控制字段来防止第二类丢失更新；"></a>使用一个额外的版本控制字段来防止第二类丢失更新；</h3><ol><li><p>给表添加一个额外的数字类型字段version；</p></li><li><p>在insert一个对象的时候初始化version值为0；</p></li><li><p>在select的时候，查询出对象的版本号；</p></li><li><p>在update的时候，</p><p> 1，更新版本号，version = version+1；</p><p> 2，在update的where条件中带上当前更新对象的版本号 where .. and version = ?</p><p> 3，如果update返回影响条数&gt;0，说明更新成功；</p><p> 4，如果update返回影响条数=0，说明更新的对象已经被其他事务更新或者删除，抛出异常，回滚当前事务；</p></li></ol><p>数据库的隔离级别除了SERIALIZABLE，都不能处理第一类丢失更新和第二类丢失更新；</p><p>所以，数据库提供了锁机制来防止第一类丢失更新和第二类丢失更新；</p>]]></content>
      
      
        <tags>
            
            <tag> Hibernate </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hibernate的一级缓存和二级缓存</title>
      <link href="/2018/06/27/Hibernate%E7%9A%84%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98%E5%92%8C%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98/"/>
      <url>/2018/06/27/Hibernate%E7%9A%84%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98%E5%92%8C%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98/</url>
      <content type="html"><![CDATA[<h1 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h1><p>Session对象:session对象提供了对象持久化的各种方法:</p><ol><li>beginTransaction:开启一个事务;</li><li>save(object):保存一个对象;</li><li>get(Class,Serializable):根据主键加载一个指定类型的对象实例;</li><li>update(object):修改一个对象,要求对象需要有id等值;</li><li>delete(object):删除一个对象,要求对象必须有id;</li><li>createQuery(String hql):创建一个查询对象;</li><li>close():关闭一个session;</li></ol><p>session的生命周期有多长?session是线程不安全的,所以session的生命周期最长为一个线程;<br>  在web应用里面,一个session的生命周期有多长?一次请求;</p><h1 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存"></a>一级缓存</h1><p>在Session对象上面有一个缓存;这个缓存在hibernate里面叫做一级缓存;</p><p>一级缓存能够保证:</p><ol><li>在一个session中拿到的多个相同类型,相同id的对象实例是同一个实例;</li><li>一级缓存的生命周期?和session相同;在web应用中,一级缓存的生命周期一次请求;</li><li>一级缓存能够提高一定的性能,但是非常有限;</li><li>一级缓存提供了对该session加载出来的对象的一个管理的区域;(session加载出来的对象都放在一级缓存里面进行管理)</li><li>sessionFactory.openSession还代表开启一个全新的一级缓存空间;</li><li>session.clear方法:清空一级缓存所有对象;</li><li>session.evict(object)方法:从一级缓存中去掉一个指定的对象;</li></ol><h1 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ol><li>生命周期为整个应用的缓存（二级缓存是sessionFactory上的缓存，能提供整个应用中所有的session使用。）</li><li>所有的get,load方法，总是先查一级缓存，再查二级缓存，如果都没有，在去数据库里面查询。</li><li>不是所有的对象都适合放到二级缓存中。（读&gt;&gt;&gt;写）</li><li>二级缓存有一些性能的指标<br>1，命中率（总的从二级缓存中取得的数量/总的取的数量）<br>2，最大对象数量；<br>3，最大空闲时间；</li><li>二级缓存实际上就是一个缓存，所以，hibernate并没有实现自己的二级缓存框架，而是用的开源的，比如ehcache</li></ol><h2 id="对象缓存策略"><a href="#对象缓存策略" class="headerlink" title="对象缓存策略"></a>对象缓存策略</h2><ol><li>usage=”read-only” ：放到二级缓存里面的对象是只读（性能最高）</li><li>usage=”read-write”：允许读写(对并发支持较好)</li><li>usage=”nonstrict-read-write”:允许读写，但是在并发事务情况下会产生脏数据</li><li>usage=”transactional” :允许读写，并且支持全事务（只能在ApplicationServer环境下有用）</li></ol><h2 id="Ehcache配置"><a href="#Ehcache配置" class="headerlink" title="Ehcache配置"></a>Ehcache配置</h2><p><defaultcache>：默认的cache，相当于公用cache；</defaultcache></p><p><cache>：自定义的cache；</cache></p><h3 id="共同的配置"><a href="#共同的配置" class="headerlink" title="共同的配置"></a>共同的配置</h3><ol><li>maxElementsInMemory：该缓存池放在内存中最大的缓存对象个数；</li><li>eternal：是否永久有效，如果设置为true，内存中对象永不过期；</li><li>timeToIdleSeconds：缓存对象最大空闲时间，单位：秒；</li><li>timeToLiveSeconds：缓存对象最大生存时间，单位：秒；</li><li>overflowToDisk：当内存中对象超过最大值，是否临时保存到磁盘；</li><li>maxElementsOnDisk：能保存到磁盘上最大对象数量；</li><li>diskExpiryThreadIntervalSeconds:磁盘失效线程运行时间间隔，默认是120秒</li><li>memoryStoreEvictionPolicy：当达到maxElementsInMemory限制时，Ehcache将会根据指定的策略去清理内存。</li></ol><p>默认策略是LRU（最近最少使用），可以设置为FIFO（先进先出）或是LFU（较少使用）<br>在默认的情况下,不同类型的对象都是放在defaultCache中的;</p><h2 id="自定义二级缓存（把某一个对象放到某一个特定的二级缓存区域）"><a href="#自定义二级缓存（把某一个对象放到某一个特定的二级缓存区域）" class="headerlink" title="自定义二级缓存（把某一个对象放到某一个特定的二级缓存区域）"></a>自定义二级缓存（把某一个对象放到某一个特定的二级缓存区域）</h2><ol><li><p>在hibernate.cfg.xml文件中的class-cache添加region；              （添加二级缓存区域）</p><p><class-cache usage="nonstrict-read-write" class="com._520it.hibernate.day4.query.Employee" region="EMPLOYEE"></class-cache></p></li><li><p>在hibernate.cfg.xml文件中的hibernate.propertie属性上添加region_prefix （添加二级缓存前缀）</p></li></ol><property name="cache.region_prefix">hibernate</property><ol start="3"><li><p>在ehcache.xml中配置一个cache,名字为region_prefix.region   （为自己的对象配置一个缓存区域 ：前缀.缓存区域）</p> <cache name="hibernate.EMPLOYEE" maxelementsinmemory="10000" eternal="true" timetoidleseconds="300" timetoliveseconds="600" overflowtodisk="true"></cache></li></ol><h2 id="二级缓存的操作"><a href="#二级缓存的操作" class="headerlink" title="二级缓存的操作"></a>二级缓存的操作</h2><p>//得到二级缓存对象<br>  Cache cache=sf.getCache();<br>//剔除一个实例<br>  cache.evictEntity(User.class, 1L);<br>//剔除某种类型的所有实例<br>  cache.evictEntityRegion(User.class);<br>//剔除所有二级缓存实例<br>  cache.evictEntityRegions();</p><h1 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h1><ol><li><p>查询是数据库技术中最常用的操作，Hibernate为查询提供了缓存，用来提高查询速度，优化查询性能相同HQL语句检索结果的缓存！</p></li><li><p>查询缓存依赖于二级缓存，查询缓存是针对普通属性结果集的缓存，对实体对象的结果集只缓存id（其id不是对象的真正id，可以看成是HQL或者SQL语句，它与查询的条件相关即where后的条件相关，不同的查询条件，其缓存的id也不一样）。查询缓存的生命周期，当前关联的表发生修改或是查询条件改变时，那么查询缓存生命周期结束，它不受一级缓存和二级缓存生命周期的影响，要想使用查询缓存需要手动配置。</p></li><li>二级缓存和查询缓存都相当于一个map。<br>二级缓存缓存的key为id，value为实体对象。一般load（），iterate（）使用到二级缓存，list()需要结合查询缓存使用。iterate（）和list（）区别如下： </li></ol>]]></content>
      
      
        <tags>
            
            <tag> Hibernate </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring对DAO的支持</title>
      <link href="/2018/06/27/Spring%E5%AF%B9DAO%E7%9A%84%E6%94%AF%E6%8C%81/"/>
      <url>/2018/06/27/Spring%E5%AF%B9DAO%E7%9A%84%E6%94%AF%E6%8C%81/</url>
      <content type="html"><![CDATA[<h2 id="Spring-dao的体系"><a href="#Spring-dao的体系" class="headerlink" title="Spring-dao的体系"></a>Spring-dao的体系</h2><img src="/2018/06/27/Spring对DAO的支持/spring-dao.png" title="spring-dao"><h2 id="异常体系"><a href="#异常体系" class="headerlink" title="异常体系"></a>异常体系</h2><h2 id="Spring为不同持久化技术提供的模板类"><a href="#Spring为不同持久化技术提供的模板类" class="headerlink" title="Spring为不同持久化技术提供的模板类"></a>Spring为不同持久化技术提供的模板类</h2>]]></content>
      
      
    </entry>
    
    <entry>
      <title>ElasticSearch基本用法</title>
      <link href="/2018/06/25/ElasticSearch%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/"/>
      <url>/2018/06/25/ElasticSearch%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/</url>
      <content type="html"><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>再安装elasticsearch-head，可视化工具</p><p>head依赖node.js</p><pre><code>node installnpm run start</code></pre><p>启动head</p><p>在elasticSearch.yml加入</p><pre><code>http.cors.enabled: true http.cors.allow-origin: &quot;*&quot;</code></pre><p>解决跨域问题，因为elastic和head是两个不同的进程，端口号不同。</p><p>细框是粗框的备份分片</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h3><p>由多个节点组成，有唯一的名字，堕胎服务器</p><h3 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h3><p>一个节点只能在一个集群中，相当于服务器</p><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>含有相同属性的文档集合，相当于数据库的表。</p><h3 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h3><p>文档是可以被索引的基本数据单位，最小的存储单位，相当于数据库的记录。</p><h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><p>索引可以定义一个或多个类型，文档必须属于一个类型，相当于sql中的表</p><h3 id="分片"><a href="#分片" class="headerlink" title="分片"></a>分片</h3><p>每个索引有多个分片，每个分片是一个Lucene索引。<br>多个分片组成这一个索引</p><h3 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h3><p>分片的备份。</p><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><p><a href="http://ip:port/索引/类型/文档id" target="_blank" rel="noopener">http://ip:port/索引/类型/文档id</a></p><h3 id="动词"><a href="#动词" class="headerlink" title="动词"></a>动词</h3><p>GET,PUT,POST,DELETE</p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>Springboot简单理解</title>
      <link href="/2018/06/24/Springboot%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3/"/>
      <url>/2018/06/24/Springboot%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3/</url>
      <content type="html"><![CDATA[<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>Spring boot是Spiring框架对约定优先于配置（Conversion Over Configuration）COC的里面的最佳实践产物。<br>特点是</p><ol><li>快速构建Spring应用</li><li>内嵌tomcat，无需安装tomcat等中间件，可以直接运行jar文件</li><li>简化了maven、gradle等的配置</li><li>通过注解自动化配置Spring，实现零配置。</li><li>可以和其他主流框架，如Spring Cloud等无缝集成。</li></ol>]]></content>
      
      
    </entry>
    
    <entry>
      <title>Web中的安全防御</title>
      <link href="/2018/06/23/Web%E4%B8%AD%E7%9A%84%E5%AE%89%E5%85%A8%E9%98%B2%E5%BE%A1/"/>
      <url>/2018/06/23/Web%E4%B8%AD%E7%9A%84%E5%AE%89%E5%85%A8%E9%98%B2%E5%BE%A1/</url>
      <content type="html"><![CDATA[<h1 id="XSS-跨站脚本攻击"><a href="#XSS-跨站脚本攻击" class="headerlink" title="XSS-跨站脚本攻击"></a>XSS-跨站脚本攻击</h1><p>全称Cross Site Scripting，CSS是层叠样式表，所以缩写为XSS</p><p>跨站的意思是运行了非本网站的脚本，用户写的<script>alert(“sb”)</script>就算</p><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ol><li>反射型</li></ol><p>脚本在url中，将url发送给其他人，其他人将url放入浏览器执行就可以执行url中的脚本。<br>可以将一串很长的带脚本的网址转为短网址发送给别人，减小怀疑。</p><ol start="2"><li>存储型</li></ol><p>比如留言板，A留言存储到数据库中，B查看留言时即执行脚本。</p><h2 id="XSS攻击注入点"><a href="#XSS攻击注入点" class="headerlink" title="XSS攻击注入点"></a>XSS攻击注入点</h2><ol><li>html节点内容</li><li>html属性</li></ol><p>提前关闭属性，加新属性<br>普通内容+右引号+左引号+脚本</p><ol start="3"><li>js脚本中</li><li>富文本</li></ol><h2 id="防御方法"><a href="#防御方法" class="headerlink" title="防御方法"></a>防御方法</h2><ol><li>x-xss-protection</li></ol><p>头部加上这个，浏览器提供XSS防御，只能防御html节点内容和属性的，并且是反射型的XSS攻击。</p><ol start="2"><li>过滤特殊字符</li></ol><p>&lt; 、&gt;、”、 ‘,&amp;转不转都行，碰到需要转的情况再更新<br>属性需要加上””,如果不加，可以运行，但是需要转义空格<br>空格转义可能与业务逻辑冲突，所以属性加””就可以了。</p><ol start="3"><li>使用JSON.stringfy过滤js脚本，不给转义</li><li>node可以使用cherio白名单校验富文本编辑</li><li>使用CSP，内容安全策略    </li></ol><h1 id="CSRF-跨站请求伪造"><a href="#CSRF-跨站请求伪造" class="headerlink" title="CSRF-跨站请求伪造"></a>CSRF-跨站请求伪造</h1><p>Cross Site Request Forgy</p><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><ol><li>登陆A网站，浏览器保存cookie作为身份</li><li>打开B网站页面，页面中包含发送A网站的请求，请求会携带cookie</li></ol><h2 id="防御方法-1"><a href="#防御方法-1" class="headerlink" title="防御方法"></a>防御方法</h2><ol><li>使用same-site，strict任何第三方网站发送的请求都不允许带cookie，lax链接可以带cookie</li><li>使用验证码,比如评论中</li><li>使用随机数作token<br>每个用户不同的token，cookie中存token，关闭浏览器失效。当请求中带有csrf的tooken则不生成token。<br>因为如果每次访问都生成toekn，比如每次访问留言页面都生成token，同时更新meta或者表单元素的token以及cookie token，<br>那打开多个页面，之前打开的页面cookie变了，meta或者表单的cookie不变，会造成提交失败的。<br>但还有重放攻击问题，所以token要存储，相同token再次发送则无效</li></ol><p>ajax请求可以用meta的token，普通form提交可以用表单token</p><p>这样的话即使第三方页面访问A网站，带了cookie但是不带meta或者表单的token，编造也编不出来，就会造成提交失败。</p><ol start="4"><li>验证referer，禁止来自第三方网站的请求</li></ol><h1 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h1><h2 id="防御方式"><a href="#防御方式" class="headerlink" title="防御方式"></a>防御方式</h2><ol><li>使用httponly禁止脚本读取cookie，防止XSS</li><li>签名，hmac签名</li><li>加密，比如des加密</li><li>secure 只在https下传输</li><li>same-site 只有chrome支持，第三方网站的请求不带cookie</li></ol><h2 id="存储方式"><a href="#存储方式" class="headerlink" title="存储方式"></a>存储方式</h2><ol><li>userid -非常不安全</li><li>userid+hmac(userid)签名 访问时根据userid哈希出sign与hmac的cookie对比</li></ol><p>缺点：每次访问都需要哈希验证，效率高</p><ol start="3"><li>sessionId 服务器端存储userid，name</li></ol><p>最好放到redis中，尤其是分布式情况下，一是防止丢失，二是防止分布式下的session不同步。</p><h1 id="Cookie和XSS以及CSRF的关系"><a href="#Cookie和XSS以及CSRF的关系" class="headerlink" title="Cookie和XSS以及CSRF的关系"></a>Cookie和XSS以及CSRF的关系</h1><p>XSS的可能会偷cookie</p><p>CSRF带着cookie冒充身份</p><h1 id="点击劫持"><a href="#点击劫持" class="headerlink" title="点击劫持"></a>点击劫持</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>嵌入iframe，设置为透明，在按钮的位置覆盖一层新的图片，相当于点击iframe中的按钮</p><h2 id="防御办法"><a href="#防御办法" class="headerlink" title="防御办法"></a>防御办法</h2><ol><li>脚本禁止iframe，通过windows==top来判断，但是加了sandbox=’allow-form’会失效</li><li>使用X-FRAME-Options,deny禁止内嵌，same-origin，同一个域名可以内嵌</li><li>加验证码等，用户需要输入验证码</li></ol><h1 id="传输安全"><a href="#传输安全" class="headerlink" title="传输安全"></a>传输安全</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><p>可能在传输过程中被监听或者篡改。</p><h2 id="范围办法"><a href="#范围办法" class="headerlink" title="范围办法"></a>范围办法</h2><ol><li>SSL（TLS）(一个意思)加密</li><li>过程<br><a href="https://my.oschina.net/glarystar/blog/465799" target="_blank" rel="noopener">https://my.oschina.net/glarystar/blog/465799</a></li></ol><h1 id="密码安全"><a href="#密码安全" class="headerlink" title="密码安全"></a>密码安全</h1><h2 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h2><h4 id="防御办法-1"><a href="#防御办法-1" class="headerlink" title="防御办法"></a>防御办法</h4><ol><li>加盐，每个用户不同的盐</li><li>多次hash，比如md5(sha256(pwd))</li><li>https传输加密</li><li>登陆频率限制</li><li>前端加密，防止被监听之后撞库，但是不能阻止监听之后伪造身份登陆</li></ol><h1 id="SQL-安全"><a href="#SQL-安全" class="headerlink" title="SQL 安全"></a>SQL 安全</h1><h2 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h2><h3 id="防御办法-2"><a href="#防御办法-2" class="headerlink" title="防御办法"></a>防御办法</h3><ol><li>关闭输出</li><li>检查输入类型，比如只允许数字</li><li>对数据转义，比如=</li><li>使用预编译</li><li>使用ORM</li></ol><h1 id="上传"><a href="#上传" class="headerlink" title="上传"></a>上传</h1><h2 id="防御方法-2"><a href="#防御方法-2" class="headerlink" title="防御方法"></a>防御方法</h2><ol><li>限制后缀</li><li>文件类型检查</li><li>文件内容检查</li><li>程序输出</li><li>权限控制</li></ol><h1 id="DOS"><a href="#DOS" class="headerlink" title="DOS"></a>DOS</h1><h1 id="重放攻击"><a href="#重放攻击" class="headerlink" title="重放攻击"></a>重放攻击</h1><h2 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h2><p>replay</p><h2 id="防御方法-3"><a href="#防御方法-3" class="headerlink" title="防御方法"></a>防御方法</h2><ol><li>HTTPS</li><li>时间戳，短时间无效</li><li>token，发送一次就换token</li><li>nonce number-once， 客户端产生随机数携带</li><li>签名 防止时间戳和nonce篡改</li></ol>]]></content>
      
      
    </entry>
    
    <entry>
      <title>npm常用操作</title>
      <link href="/2018/06/23/npm%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"/>
      <url>/2018/06/23/npm%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</url>
      <content type="html"><![CDATA[<h2 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h2><p>以安装msbuild为例</p><ol><li>npm install msbuild</li></ol><p>本地安装</p><p>（1）将安装包放在 ./node_modules 下（运行 npm 命令时所在的目录），如果没有 node_modules 目录，会在当前执行 npm 命令的目录下生成 node_modules 目录。</p><p>（2）可以通过 require() 来引入本地安装的包。</p><ol><li>npm install msbuild -g</li></ol><p>全局安装</p><p>(1) 将安装包放在 /usr/local 下或者你 node 的安装目录。</p><p>(2)可以直接在命令行里使用。</p><ol start="3"><li>npm install msbuild –save</li></ol><p>(1)会把msbuild包安装到node_modules目录中</p><p>(2)会在package.json的dependencies属性下添加msbuild</p><p>(3)之后运行npm install命令时，会自动安装msbuild到node_modules目录中</p><p>(4)之后运行npm install –production或者注明NODE_ENV变量值为production时，会自动安装msbuild到node_modules目录中</p><ol start="4"><li>npm install msbuild –save-dev</li></ol><p>(1)会把msbuild包安装到node_modules目录中</p><p>(2)会在package.json的devDependencies属性下添加msbuild</p><p>(3)之后运行npm install命令时，会自动安装msbuild到node_modules目录中</p><p>(4)之后运行npm install –production或者注明NODE_ENV变量值为production时，不会自动安装msbuild到node_modules目录中</p>]]></content>
      
      <categories>
          
          <category> Node.Js </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>redis的持久化策略</title>
      <link href="/2018/06/22/redis%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96%E7%AD%96%E7%95%A5/"/>
      <url>/2018/06/22/redis%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96%E7%AD%96%E7%95%A5/</url>
      <content type="html"><![CDATA[<h1 id="RDB-快照-redis-db"><a href="#RDB-快照-redis-db" class="headerlink" title="RDB-快照-redis db"></a>RDB-快照-redis db</h1><h2 id="方式"><a href="#方式" class="headerlink" title="方式"></a>方式</h2><ol><li>save 非后台保存，会阻塞redis正常使用</li><li>bgsave 后台线程保存</li><li>触发 满足一定条件，比如命令数新增了6000条，触发快照机制，快照是后台还是前台没试过</li></ol><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol><li>O(n)数据：耗时</li><li>fork():消耗内存，copy-on-write策略</li><li>IO：因为写到硬盘上</li><li>丢失数据：只能恢复到上一次rdb的快照点</li></ol><h1 id="AOF-append-only-file"><a href="#AOF-append-only-file" class="headerlink" title="AOF- append only file"></a>AOF- append only file</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>写命令之前先写到AOF缓冲区中</p><h2 id="方式-1"><a href="#方式-1" class="headerlink" title="方式"></a>方式</h2><ol><li>always 每条命令都fsync把缓冲区到硬盘</li><li>everysec 每秒fsync把缓冲区到硬盘</li><li>no 操作系统决定何时fsync</li></ol><h2 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h2><ol><li>always IO开销大，TPS少 throughout per seconds</li><li>everysec 丢1秒数据</li><li>no 不可控</li></ol><h2 id="AOF重写"><a href="#AOF重写" class="headerlink" title="AOF重写"></a>AOF重写</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>过期的、重复的、可优化的命令化简<br>比如set a 1；set a 2，优化成set a 2</p><h3 id="方式-2"><a href="#方式-2" class="headerlink" title="方式"></a>方式</h3><ol><li>bgrewriteaof fork后对内存中redis进行重写</li><li>AOF重写配置<br>auto-aof-rewrite-min-size</li></ol>]]></content>
      
      
    </entry>
    
    <entry>
      <title>Spring拦截器、Servlet过滤器、Spring AOP、Servet监听器的区别</title>
      <link href="/2018/06/21/Spring%E6%8B%A6%E6%88%AA%E5%99%A8%E5%92%8C%E8%BF%87%E6%BB%A4%E5%99%A8%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2018/06/21/Spring%E6%8B%A6%E6%88%AA%E5%99%A8%E5%92%8C%E8%BF%87%E6%BB%A4%E5%99%A8%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      <content type="html"><![CDATA[<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><ol><li>拦截器和AOP是Spring提供的，过滤器和监听器是Servlet提供的</li><li>拦截器和AOP在Spring的配置文件中进行配置，过滤器和监听器在web.xml中进行配置</li><li>拦截器，过滤器和监听器都是通过接口调用实现的，因为他们都实现了特定的接口。AOP是通过动态代理实现的</li><li>目前继承了HandlerInterceptorAdapter，使用registry.addInterceptor(accessInterceptor);只拦截@RequestMapping的请求，不拦截静态资源的请求，以后再深入-todo</li></ol><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><h3 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h3><p>限制频率访问</p><h3 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h3><p>XSS过滤</p><h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h3><p>日志</p><h3 id="监听器"><a href="#监听器" class="headerlink" title="监听器"></a>监听器</h3><p>并发用户数量</p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>Spring中Bean的生命周期</title>
      <link href="/2018/06/20/Spring%E4%B8%ADBean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
      <url>/2018/06/20/Spring%E4%B8%ADBean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
      <content type="html"><![CDATA[<p>或不多说，直接上图</p><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><p><a href="https://github.com/zwxbest/Demo/tree/master/SpringSource/BeanFactoryAndApplicationContextLifeCycle" target="_blank" rel="noopener">https://github.com/zwxbest/Demo/tree/master/SpringSource/BeanFactoryAndApplicationContextLifeCycle</a></p><img src="/2018/06/20/Spring中Bean的生命周期/BeanFactory.png" title="BeanFactory"><img src="/2018/06/20/Spring中Bean的生命周期/ApplicationContext.png" title="ApplicationContext"><h3 id="关于ApplicationContext和BeanFactory的最大不同"><a href="#关于ApplicationContext和BeanFactory的最大不同" class="headerlink" title="关于ApplicationContext和BeanFactory的最大不同"></a>关于ApplicationContext和BeanFactory的最大不同</h3><p>ApplicationContext利用反射自动识别出配置文件中定义的BeanPostProcessor、InstantiationAwareBeanPostProcessor和BeanFactoryProcessor并注册。</p><p>而BeanFactory需要手动在代码中使用addBeanPostProcessor（）进行注册。</p>]]></content>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Chrome网页关键词屏蔽插件</title>
      <link href="/2018/06/20/Chrome%E7%BD%91%E9%A1%B5%E5%85%B3%E9%94%AE%E8%AF%8D%E5%B1%8F%E8%94%BD%E6%8F%92%E4%BB%B6/"/>
      <url>/2018/06/20/Chrome%E7%BD%91%E9%A1%B5%E5%85%B3%E9%94%AE%E8%AF%8D%E5%B1%8F%E8%94%BD%E6%8F%92%E4%BB%B6/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前写了个小脚本-虎扑帖子关键词屏蔽，配合暴躁猴使用，因为无脑黑和无脑吹太多。</p><p><a href="https://greasyfork.org/scripts/32168-%E8%99%8E%E6%89%91%E5%B8%96%E5%AD%90%E5%85%B3%E9%94%AE%E8%AF%8D%E5%B1%8F%E8%94%BD" target="_blank" rel="noopener">https://greasyfork.org/scripts/32168-%E8%99%8E%E6%89%91%E5%B8%96%E5%AD%90%E5%85%B3%E9%94%AE%E8%AF%8D%E5%B1%8F%E8%94%BD</a></p><img src="/2018/06/20/Chrome网页关键词屏蔽插件/block4.jpg" title="block4"><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol><li>用户体验不好</li></ol><p>需要改脚本增加关键词，不改的话 又要写配置页面，写页面又要做的漂亮又要花时间，好麻烦的。</p><ol start="2"><li>适用性不高</li></ol><p>只针对虎扑发帖和回帖。其他功能以及其他网站不能用</p><ol start="3"><li>屏蔽词闪现</li></ol><p>因为是前端过滤，页面加载完成之后才会开始过滤，所以可能一打开看到屏蔽词，下一秒才会消失。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>可手机电脑一起用，手机用Firefox，可装暴躁猴。手机版chrome不行，有个Yandex，爱折腾的可以了解一下啊</p><h2 id="后来"><a href="#后来" class="headerlink" title="后来"></a>后来</h2><p>后来想造个通用点的脚本，根据网址，选择器以及keyword进行匹配，后来觉得换成插件比用暴躁猴稳定，自定义页面和js也比较方便。</p><p>先搜资料，搜到了神器，本来就想专注后端，不用造轮子了。</p><p><a href="https://chrome.google.com/webstore/detail/customblocker/elnfhbjabfcepfnaeoehffgmifcfjlha" target="_blank" rel="noopener">https://chrome.google.com/webstore/detail/customblocker/elnfhbjabfcepfnaeoehffgmifcfjlha</a></p><h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><p>可以自定义网址，css选择器，关键词</p><h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><ul><li>屏蔽词闪现</li></ul><p>因为大部分网站都是异步加载，这个没有什么好办法</p><ul><li>跨平台问题</li></ul><p>手机版chrome不能装扩展，firefox不知道有没有这插件</p><ul><li>使用有门槛</li></ul><p>需要会点css知识</p><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><img src="/2018/06/20/Chrome网页关键词屏蔽插件/block.jpg" title="block"><p><a href="https://bbs.hupu.com/匹配https://bbs.hupu.com/topic，https://bbs.hupu.com/yingchao，也可以自定义正则匹配" target="_blank" rel="noopener">https://bbs.hupu.com/匹配https://bbs.hupu.com/topic，https://bbs.hupu.com/yingchao，也可以自定义正则匹配</a></p><p>Elements to  hide表示要隐藏的元素，可以右键直接copy css selector更快。</p><p>Search Range表示具体的元素，如果这个元素被Elements to  hide包含，并且Search Range包含Keywords，那么匹配成功，隐藏掉Elements to  hide.</p><p>点击test rule，蓝色的即为要屏蔽的内容</p><img src="/2018/06/20/Chrome网页关键词屏蔽插件/block3.jpg" title="block3"><h3 id="为什么要设置两个规则"><a href="#为什么要设置两个规则" class="headerlink" title="为什么要设置两个规则"></a>为什么要设置两个规则</h3><p>因为可能ElementsToHide包含两个子节点，node1和node2，node1包含过滤词，但不希望屏蔽，node2不包含过滤词，如果只用ElementsToHides,那么如果只有node1包含过滤词，也要将ElementsToHide屏蔽掉。</p><p>设置Element to hide为#ajaxtable &gt; div.show-list &gt; ul &gt; li</p><p>设置Search Range为#ajaxtable &gt; div.show-list &gt; ul &gt; li &gt; div.titlelink.box &gt; a</p><p>也可以生效，按照他的介绍，好像就是这么个伪算放</p><img src="/2018/06/20/Chrome网页关键词屏蔽插件/block2.jpg" title="block2"><pre><code>for(eleB:ElementsToSearch)    {        for（eleA :ElementsToHide）        {            if(eleB.contains(&quot;过滤词&quot;)&amp;&amp; eleA.contains(eleB))            {                屏蔽掉eleA;                break;            }        }    }</code></pre><p>其实我觉得可以用</p><pre><code>$(ElementToHide ElementToSearch:Contains(过滤词))</code></pre><p>这样效率也会高点</p><p>关于插件位置，搜id，</p><p>C:\Users\admin\AppData\Local\Google\Chrome\User Data\Profile 1\Extensions\elnfhbjabfcepfnaeoehffgmifcfjlha\2.6.4_0</p><p>js并没有压缩，可以直接修改。</p><p>反正源码都有了，修改完了按照开发者模式再装上就行了。</p>]]></content>
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Spring中的父子容器</title>
      <link href="/2018/06/20/Spring%E4%B8%AD%E7%9A%84%E7%88%B6%E5%AD%90%E5%AE%B9%E5%99%A8/"/>
      <url>/2018/06/20/Spring%E4%B8%AD%E7%9A%84%E7%88%B6%E5%AD%90%E5%AE%B9%E5%99%A8/</url>
      <content type="html"><![CDATA[<p>通过HierarchyBeanFactory，Spring的IoC容器可以建立父子层级关联的容器体系，自容器可以访问父容器中的Bean，父容器不能访问自容器中的Bean。子容器可以拥有一个和父容器id相同的Bean。</p><p>SpringMVC，展现层位于子容器中，业务层和持久层位于父容器中。展现层可以引用业务层和持久层Bean，业务层和持久层看不到展现层。</p><p>因为子容器可以访问父容器的Bean，所以可以在SpringMVC的配置文件中扫描父容器的Bean。但如果SpringMVC不做扫描，Spring配置文件扫描Springmvc的Bean,比如@Controller，会扫描不到，访问会报404</p>]]></content>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring中的事务管理</title>
      <link href="/2018/06/20/Spring%E4%B8%AD%E7%9A%84%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/"/>
      <url>/2018/06/20/Spring%E4%B8%AD%E7%9A%84%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/</url>
      <content type="html"><![CDATA[<h2 id="事务传播行为"><a href="#事务传播行为" class="headerlink" title="事务传播行为"></a>事务传播行为</h2><p>7种事务传播行为</p><ul><li>propagation_required<br>默认，没有新建，有就加入</li><li>propagation_supports 如果当前没有事务，以非事务方式运行</li><li>propagation_mandatory  当前没有事务，抛出异常</li><li>propagation_required_new 新建事务，如果当前有事务，就挂起它</li><li>propagation_not_support  非事务方式执行，如果当前有事务，就挂起</li><li>propagation_never   非事务方式运行，当前有抛出异常</li><li>propagation_nested  嵌套事务，底层数据源必须基于JDBC3.0，并且需要支持save point</li></ul><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><table><thead><tr><th>-</th><th style="text-align:center">外层无事务，新建事务</th><th style="text-align:right">外层无事务，非事务运行</th><th>外层无事务，抛异常</th></tr></thead><tbody><tr><td>外层有事务，加入</td><td style="text-align:center">REQUIRED</td><td style="text-align:right">SUPPORTS</td><td>MANADATORY</td></tr><tr><td>外层有事务，挂起外层</td><td style="text-align:center">REQUIRED_NEW</td><td style="text-align:right">NOT_SUPPORTED</td><td>-</td></tr><tr><td>外层有事务，抛异常</td><td style="text-align:center">-</td><td style="text-align:right">NEVER</td><td>-</td></tr><tr><td>外层有事务，嵌套事务运行</td><td style="text-align:center">NESTED</td><td style="text-align:right">-</td><td>-</td></tr></tbody></table><h4 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h4><p>加入的意思是外层rollback内层rollback，内层rollback外层rollback<br>挂起的意识是外层rollback内层不rollback，内层rollback外层rollback，同时内层都是独立的事务</p><p>区别是当required和nested中的exception被catch，nested只回滚嵌套子事务，而required因为是一个事务，即使被catch了也全部回滚。</p><h1 id="事务管理支持"><a href="#事务管理支持" class="headerlink" title="事务管理支持"></a>事务管理支持</h1><p>通过PlantformTransactionManager、TransactionDefinition、TransactionStatus三个类</p><h2 id="TransactionDefinition"><a href="#TransactionDefinition" class="headerlink" title="TransactionDefinition"></a>TransactionDefinition</h2><p>定义了</p><h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3><ol><li>isolation_read_uncommitted</li><li>isolation_read_committed</li><li>isolation_read_repeatable</li><li>isolation_seriablizable</li><li>isolation_default 数据库默认的级别，mysql是read_repeatable,<h3 id="事务传播级别"><a href="#事务传播级别" class="headerlink" title="事务传播级别"></a>事务传播级别</h3><h3 id="事务超时"><a href="#事务超时" class="headerlink" title="事务超时"></a>事务超时</h3><h3 id="只读事务"><a href="#只读事务" class="headerlink" title="只读事务"></a>只读事务</h3></li></ol><h3 id="TransactionStatus"><a href="#TransactionStatus" class="headerlink" title="TransactionStatus"></a>TransactionStatus</h3><p>代表事务状态，支持保存点，innodb支持</p><h3 id="PlantformTransactionManager"><a href="#PlantformTransactionManager" class="headerlink" title="PlantformTransactionManager"></a>PlantformTransactionManager</h3><p>将事务委托给持久层框架来完成</p><h2 id="Spring-下默认事务机制中-Transactional无效的原因"><a href="#Spring-下默认事务机制中-Transactional无效的原因" class="headerlink" title="Spring 下默认事务机制中@Transactional无效的原因"></a>Spring 下默认事务机制中@Transactional无效的原因</h2><ol><li>同一个类中, 一个nan-transactional的方法去调用transactional的方法, 事务会失效</li><li>在private方法上标注transactional, 事务无效</li></ol>]]></content>
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 事务 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>mysql中的MyISAM和InnoDb存储引擎对比</title>
      <link href="/2018/06/19/mysql%E4%B8%AD%E7%9A%84MyISAM%E5%92%8CInnoDb%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E5%AF%B9%E6%AF%94/"/>
      <url>/2018/06/19/mysql%E4%B8%AD%E7%9A%84MyISAM%E5%92%8CInnoDb%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E5%AF%B9%E6%AF%94/</url>
      <content type="html"><![CDATA[<ul><li>innodb支持事务，myIsam不支持</li><li>innodb通过undo log对数据多版本读取的支持</li><li>innodb不支持全文索引，myisam支持全文索引</li><li>myisam效率相比innodb高</li><li>myisam保存成文件的形式，更容易做转移</li><li>innodb通过索引实现行锁定，myisam表锁定</li><li>innodb支持外键</li><li>innodb的配置参数都带有前缀innodb_</li><li>innodb可以在保证数据不丢失的情况下，切换非事务表到事务表</li></ul><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>myisa</p>]]></content>
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>数据库事务基础知识</title>
      <link href="/2018/06/19/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/2018/06/19/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>4个特性，一致性是最终目标，一般采用重执行日志来保证ACD，隔离性I使用锁来避免</p><ul><li>原子性：组成事务的多个数据库操作都成功执行，整个事务才提交，否则撤销回所有操作都未执行的初始状态</li><li>一致性：数据库内容和业务规则一致，比如A转钱100到B，不管成功与否，A和B总额不变</li><li>隔离性：不同事务相互隔离</li><li>持久性： 一旦事务成功提交，事务中所有操作持久化到数据库中。即使是提交事务到持久化过程中崩溃，也要保证通过某种机制恢复数据<h2 id="数据并发的问题"><a href="#数据并发的问题" class="headerlink" title="数据并发的问题"></a>数据并发的问题</h2></li></ul><p>有个小问题：为什么要读取两次？</p><h3 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h3><p>BU+ARUC+BW<br>A事务读取B事务尚未提交的更改数据，并在此基础上操作以及提交。<br>此时B withdraw,A的R是脏读</p><h3 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h3><p>AR+BUC+AR<br>A事务读取了B事务已经提交的更改数据，两次读取不一致</p><h3 id="幻象读"><a href="#幻象读" class="headerlink" title="幻象读"></a>幻象读</h3><p>AR+BI+AR<br>A事务读取了B事务提交的新增数据，两次读取不一致</p><h3 id="幻想读和不可重复读的区别"><a href="#幻想读和不可重复读的区别" class="headerlink" title="幻想读和不可重复读的区别"></a>幻想读和不可重复读的区别</h3><p>不可重复读是因为B事务更改或者删除，幻想度是B事务增加<br>前者加行级锁避免，后者加表级锁避免</p><h3 id="第一类更新丢失"><a href="#第一类更新丢失" class="headerlink" title="第一类更新丢失"></a>第一类更新丢失</h3><p>AR+BUC+AUW<br>A事务撤销时，把已经提交的B事务的更新数据覆盖了</p><h3 id="第二类更新丢失"><a href="#第二类更新丢失" class="headerlink" title="第二类更新丢失"></a>第二类更新丢失</h3><p>AR+BUC+AUC<br>A事务提交时覆盖B事务已经提交的数据</p><h3 id="更新丢失总结"><a href="#更新丢失总结" class="headerlink" title="更新丢失总结"></a>更新丢失总结</h3><p>第一类是撤销造成的覆盖，第二类是提交造成的覆盖</p><h2 id="数据库锁"><a href="#数据库锁" class="headerlink" title="数据库锁"></a>数据库锁</h2><h3 id="Oracle常用的5中锁定方式"><a href="#Oracle常用的5中锁定方式" class="headerlink" title="Oracle常用的5中锁定方式"></a>Oracle常用的5中锁定方式</h3><ul><li>行共享锁定 排斥表独占锁定</li><li>行独占锁定 排斥其他锁定</li><li>表共享锁定 允许行共享和表共享锁定</li><li>表共享独占锁定 允许行共享锁定</li><li>表独占锁定 排斥表共享和表独占锁定<h2 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h2></li></ul><p>指定会话的事务隔离级别，数据库就会自动加锁</p><p>从上到下隔离级别一次加强，吞吐量依次降低</p><ul><li>read uncommmitted 解决了第一类丢失更新，解决了1种</li><li>read committed 解决了脏读和第一类丢失更新，解决了2种</li><li>repeatable read 未解决幻象读，解决了4种</li><li>serializable 全都解决了，解决了5种</li></ul><p>推荐使用repeatable read作为隔离级别</p>]]></content>
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>docker常用操作</title>
      <link href="/2018/06/19/docker%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"/>
      <url>/2018/06/19/docker%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</url>
      <content type="html"><![CDATA[<p>容器=镜像+可读层</p><h3 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h3><ul><li>删除 docker rmi</li><li>当前所有镜像 docker images</li><li>新增镜像 docerk commit container-id 将读写层转换为只读层，将容器转换为镜像</li><li>docker build 根据Dockerfile文件，from-&gt;run-&gt;commit,创建新镜像</li><li>查看元数据 docker inspect</li><li>历史镜像 docker history</li><li>导出镜像 docker save </li><li>导入镜像 docker import<h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3></li><li>删除 docker rm </li><li>重命名 docker rename </li><li>创建 docker create image-id</li><li>启动 docker start </li><li>一步启动 docker run=docker create+docker start,如果不存在镜像，则下载镜像后启动，如果存在则直接启动</li><li>当前启动容器 docker ps</li><li>当前所有容器 docker ps -a</li><li>停止容器 docker stop 发送sigterm停止容器，contaier-id可以输入部分前缀，只要能区分。如果只有一个容器jvxcodfencv，输入j即可。</li><li>杀死容器 docker kill 发送sigkill杀死容器</li><li>暂停容器 docker pause 发送sigstp</li><li>查看元数据 docker inspect</li><li>进入容器 docker exec runnig-container-id</li><li>导出容器 docker export</li><li>导入容器 docker import</li></ul><h1 id="进入内部"><a href="#进入内部" class="headerlink" title="进入内部"></a>进入内部</h1><ul><li>docker cp index.html d8e306c6d8a8://usr/share/nginx/html 复制文件到nginx目录</li></ul><h1 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h1><p>docker exec -it nginx /bin/bash</p><p>-d :分离模式: 在后台运行</p><p>-i :即使没有附加也保持STDIN 打开</p><p>-t :分配一个伪终端</p><h1 id="查看容器内部"><a href="#查看容器内部" class="headerlink" title="查看容器内部"></a>查看容器内部</h1><p>docker inspect <container-id></container-id></p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="启动redis"><a href="#启动redis" class="headerlink" title="启动redis"></a>启动redis</h3><p>docker run -p 7004:6379 -v E:\Docker\ps1\redis/conf/redis2.conf:/usr/local/etc/redis/redis.conf –name myredis1 -d redis redis-server /usr/local/etc/redis/redis.conf</p><p>-d： 后台运行容器，并返回容器ID；</p><p>-p： 端口映射</p><p>-v： 文件映射，本地路径：容器路径</p><p>如果 -v 没有冒号，相当于没指定本地路径,只指定了容器路径。不指定本地路径，那就由docker分配，具体怎么分配不清楚。 </p><p>–name： 容器名字</p><p>redis  镜像名字</p><p>redis-server /usr/local/etc/redis/redis.conf 启动容器后要执行的操作</p><p>docker create -v $PWD/data:/var/mydata –name container1</p><p>–volumes-from container1 从contaier1容器挂载卷，将会直接进入这个新创建的容器,新创建的容器中的$PWD/data对应container1中的/var/mydata</p><p>-P 大p，所有的监听端口都会和主机建立映射。</p><h1 id="保存"><a href="#保存" class="headerlink" title="保存"></a>保存</h1><ul><li>docker commit -m “fun” d8e306c6d8a8 nginx-test 保存修改过的d8e306c6d8a8容器为一个新的镜像，-m为提交说明，nginx-test为名字</li></ul><h1 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h1><pre><code>from alpine:latestmaintainer xbfcmd echo &#39;hello docker&#39;from ubuntumaintainer xbfrun sed -i &#39;s/archive.ubuntu.com/mirrors.ustc.edu.cn/g&#39; /etc/apt/sources.listrun apt-get updaterun apt-get install -y nginxcopy index.html /var/www/htmlentrypoint [&quot;/usr/sbin/nginx&quot;,&quot;-g&quot;,&quot;daemon off;&quot;]expose 80</code></pre><p>docker build -t hello-docker .</p><p>-t 表示镜像的名字，.点在当前目录下找dockerfile文件</p><h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><ul><li>from 表示哪个从哪个镜像作为基础</li><li>maintainer 表示</li></ul><h2 id="volume"><a href="#volume" class="headerlink" title="volume"></a>volume</h2><h1 id="registry"><a href="#registry" class="headerlink" title="registry"></a>registry</h1><h2 id="docker-search"><a href="#docker-search" class="headerlink" title="docker search"></a>docker search</h2><h2 id="docker-pull"><a href="#docker-pull" class="headerlink" title="docker pull"></a>docker pull</h2><h2 id="docker-push"><a href="#docker-push" class="headerlink" title="docker push"></a>docker push</h2><h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><h2 id="docker-cp之后再docker-run一个新的容器，是否是新的index-html页面？"><a href="#docker-cp之后再docker-run一个新的容器，是否是新的index-html页面？" class="headerlink" title="docker cp之后再docker run一个新的容器，是否是新的index.html页面？"></a>docker cp之后再docker run一个新的容器，是否是新的index.html页面？</h2><p> 否，docker容器内的改动都是暂时的。</p><h1 id="Registry"><a href="#Registry" class="headerlink" title="Registry"></a>Registry</h1><ul><li>docker search nginx 搜索</li><li>docker pull nginx</li><li>docker push myname/nginx 放上去我的</li><li>docker tag 镜像重命名，不光可以tag重命名，可以给reposity命名，但是不占空间</li><li>docker push push之前需要docker login 登陆</li></ul><h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1><ul><li>host模式 和主机使用同一块网卡</li><li>bridge 这是默认的，先创建网桥，和宿主机网卡相连，docker内虚拟出来的网卡再和网桥相连。有独立ip和端口，可以做端口映射。</li><li></li></ul>]]></content>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java并发优化方案</title>
      <link href="/2018/06/19/Java%E5%B9%B6%E5%8F%91%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88/"/>
      <url>/2018/06/19/Java%E5%B9%B6%E5%8F%91%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88/</url>
      <content type="html"><![CDATA[<ol><li>加redis</li><li>加多个redis集群<br>注意分布式session处理，uuid的token做cookie和redis的key，user的json做redis的值</li><li>如果使用了jsp、freemarker等，可以做页面缓存，在controller的方法中解析html，存入redis并返回text/html(通过@RequestMapping的produces参数配置)</li><li>对象缓存，缓存用户信息等 </li><li>静态化，前后端分离，通过yml配置设置cache-control设置页面缓存。</li><li>jss和css压缩，减小流量</li><li>js和css合并请求，减少请求次数，tengine可以提供</li><li>买cdn</li><li>因为高并发会带来安全方面新挑战，使用jsr303参数检验，全局的异常处理，代码更优雅</li><li>两次md5+盐，客户端一次md5，服务端一次md5</li><li>在sql中加and count&gt;0条件防止超库</li><li>使用唯一索引+事务防止同一个用户同时多个请求秒杀多次</li><li>使用mycat做分库分表</li><li>内存标记是否库存已空，减少redis访问</li><li>使用消息队列排队等待</li><li>使用秒杀地址，给每个用户分配一个uuid加在地址中，配合@PathVariable,这样可以让用户在秒杀时才知道地址</li><li>使用验证码，使用算术验证码，配合ScriptEngine使用Javacript在后台运算出来，验证码存到redis</li><li>使用Redis以及自定义注解接口限流，1分钟超过100次就限制访问。</li></ol>]]></content>
      
      
        <tags>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>git状态整理</title>
      <link href="/2018/06/18/git%E7%8A%B6%E6%80%81%E6%95%B4%E7%90%86/"/>
      <url>/2018/06/18/git%E7%8A%B6%E6%80%81%E6%95%B4%E7%90%86/</url>
      <content type="html"><![CDATA[<h3 id="git下文件的状态"><a href="#git下文件的状态" class="headerlink" title="git下文件的状态"></a>git下文件的状态</h3><p>一个git文件可以有4中状态:</p><ol><li>untracked 未跟踪</li><li>modified 已修改</li><li>staged/cached/indexed 已暂存</li><li>unmodified 未修改</li></ol><h3 id="按照文件的存放位置"><a href="#按照文件的存放位置" class="headerlink" title="按照文件的存放位置"></a>按照文件的存放位置</h3><p>在你自建的Git本地仓库中，有三个区域：</p><ul><li>本地目录</li></ul><p>也叫work tree, 就是受Git控制的文件夹，所有被跟踪记录的文件都包括在其中</p><p>文件的状态包括untracked和modified状态。<br>如果新建一个，就是untracked，如果对这个新建的做了修改，就是modified。</p><ul><li>暂存区</li></ul><p>也叫index或者stage或cached，类似一个缓存区域，临时保存你做的改动；</p><p>文件的状态是staged/cached/inexed</p><ul><li>HEAD</li></ul><p>指向最近一次提交后的结果。<br>文件的状态是unmodified。<br>如果修改了，那就是modified了，modified是在本地目录中。</p><h3 id="按照文件的状态"><a href="#按照文件的状态" class="headerlink" title="按照文件的状态"></a>按照文件的状态</h3><p>工作目录下面的所有文件都不外乎这两种状态：已跟踪或未跟踪</p><p>未跟踪的文件的改动不受到Git的版本控制。</p><p>已跟踪的文件，即被纳入版本控制的文件，又分为未修改（unmodified）、已修改（modified）、已暂存（staged）三种状态。</p> <img src="/2018/06/18/git状态整理/git_state.png" title="git_state"><p>当在工作目录中新加入一个文件时，它处于未跟踪状态，这表示其没有纳入Git的版本控制。</p><p>通过 git add 命令可以将其加入跟踪，并同时放入暂存区。</p><p>一个已经被跟踪的文件，如果没有做过新的修改，就是未修改状态。</p><p>一旦对其做了改动，就变成了已修改状态。通过 git add 命令可以将已修改的文件放入暂存区。</p><p>初次克隆某个仓库时，工作目录中所有文件都是已跟踪且未修改的状态。</p><p>git commit 命令会将暂存区中的文件提交至HEAD所指向的分支。当被commit之后，暂存区的文件将回到未修改状态。</p><img src="/2018/06/18/git状态整理/git_state_2.png" title="git_state_2"><p>对于如下图所示的git status</p><p>最上面的两行绿色,表示已经通过git add 将new file和修改放入暂存区了.</p><p>下面的一行红色,表示修改过了,但是没有git add提交修改,也就不会放入暂存区</p><p>最下面两行,untracked,没有加入版本控制.</p><p>所以git add和git rm是打通工作目录和暂存区的桥梁.</p><p>其实git add应该是将untracked和modified连接到staged,貌似上图不对.</p>]]></content>
      
      <categories>
          
          <category> 版本控制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>框架中常用的设计模式以及如何判断</title>
      <link href="/2018/06/18/%E6%A1%86%E6%9E%B6%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD/"/>
      <url>/2018/06/18/%E6%A1%86%E6%9E%B6%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD/</url>
      <content type="html"><![CDATA[]]></content>
      
      
    </entry>
    
    <entry>
      <title>spring中的设计模式</title>
      <link href="/2018/06/18/spring%E4%B8%AD%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/06/18/spring%E4%B8%AD%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<ul><li>工厂方法模式<br>BeanFactory和ApplicationContext</li><li>代理模式<br>AOP</li><li>享元模式<br>线程池、数据库连接池以及各种尺</li><li>原型模式</li><li>单例模式</li><li>迭代器模式</li><li>策略模式-InstantiationStrategy采用不同的实例化策略</li><li>观察者模式 监听器、广播器、注册器 </li></ul>]]></content>
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>redis数据结构整理</title>
      <link href="/2018/06/17/redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%95%B4%E7%90%86/"/>
      <url>/2018/06/17/redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%95%B4%E7%90%86/</url>
      <content type="html"><![CDATA[<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><h3 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h3><p>get、set、del</p><h3 id="自增自减"><a href="#自增自减" class="headerlink" title="自增自减"></a>自增自减</h3><p>incr、decr、incrby、decrby、incrbyfloat</p><h3 id="处理字符串和二进制位"><a href="#处理字符串和二进制位" class="headerlink" title="处理字符串和二进制位"></a>处理字符串和二进制位</h3><p>append、getranget、setrange<br>getbit、setbit、bitcount、bitop</p><h1 id="列表-linked-list"><a href="#列表-linked-list" class="headerlink" title="列表-linked-list"></a>列表-linked-list</h1><h2 id="命令-1"><a href="#命令-1" class="headerlink" title="命令"></a>命令</h2><h3 id="基本-1"><a href="#基本-1" class="headerlink" title="基本"></a>基本</h3><ul><li>rpush 右端push</li><li>lpush 左端push</li><li>lrange 指定范围的所有元素</li><li>lindex 指定位置的单个元素</li><li>lpop 在左边弹出 </li><li>rpop</li><li>ltrim 修剪列表，保留[start,end]之间的元素</li><li>blpop -blop list1 [list2…] timeout 从一个非空队列弹出最左端的元素或者在timeout秒之内阻塞并等待可弹出的元素出现</li><li>brpop</li><li>rpoplpush -rpoplpush list1 list2,从list1 pop最右元素，push到list2最左端，并返回这个元素</li><li>brpoplpush 在timeout秒之内阻塞并等待可弹出的元素出现<h1 id="集合-set"><a href="#集合-set" class="headerlink" title="集合-set"></a>集合-set</h1><h2 id="命令-2"><a href="#命令-2" class="headerlink" title="命令"></a>命令</h2><h3 id="基本-2"><a href="#基本-2" class="headerlink" title="基本"></a>基本</h3></li><li>sadd </li><li>smembers 返回所有元素</li><li>sismember 是否存在</li><li>srem 如果存在则移除</li><li>sinter 交集</li><li>sinterstore 交集存储到一个key中</li><li>sunion 并集 </li><li>sunionstore 并存存储到一个key中</li><li>sdiff 差集</li><li>sdiffstore 差集存储到一个一个key中</li><li>scard 返回包含的数量</li><li>spop 随机移除一个元素并返回</li><li>smove -smove set1 set2 item 从set1移动item到set2<h1 id="散列-hash"><a href="#散列-hash" class="headerlink" title="散列-hash"></a>散列-hash</h1><h2 id="命令-3"><a href="#命令-3" class="headerlink" title="命令"></a>命令</h2><h3 id="基本-3"><a href="#基本-3" class="headerlink" title="基本"></a>基本</h3></li><li>hset 增加键值对</li><li>hget 获取指定hashkey的值</li><li>hgetall 获取所有键值对</li><li>hdel 删除hashkey</li><li>hlen</li><li>hexists</li><li>hkeys</li><li>hvals</li><li>hincrby -hincrby hash hashkey increment 将key存储的值加上整数increment</li><li>hincrbyfloat 加上浮点数</li><li><h1 id="有序集合-zset"><a href="#有序集合-zset" class="headerlink" title="有序集合-zset"></a>有序集合-zset</h1><h2 id="命令-4"><a href="#命令-4" class="headerlink" title="命令"></a>命令</h2><h3 id="基本-4"><a href="#基本-4" class="headerlink" title="基本"></a>基本</h3></li><li>zadd 添加带score的成员</li><li>zrange 返回排名在start和stop之间的成员，按照分值从小到大排名</li><li>zrangebyscore 获取分值范围内所有元素</li><li>zrem 移除</li><li>zcard 返回数量</li><li>zincrby 增加分值</li><li>zcount 返回分值介于min和max之间的数量</li><li>zrank 返回成员的member的排名，从小到达排名</li><li>zscore 返回成员的分值</li><li>zrevrank -zrevrank zset member 返回member排名，按照分值从大到小</li><li>zrevrange</li><li>zrevrangebyscore</li><li>zremrangebyrank 移除排名之间的成员</li><li>zremrangebyscore </li><li>zinterstore 执行交集运算</li><li>zunionstore 执行并集运算</li></ul>]]></content>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>PO、VO、TO、BO、POJO等解释</title>
      <link href="/2018/06/17/PO%E3%80%81VO%E3%80%81TO%E3%80%81BO%E3%80%81POJO%E7%AD%89%E8%A7%A3%E9%87%8A/"/>
      <url>/2018/06/17/PO%E3%80%81VO%E3%80%81TO%E3%80%81BO%E3%80%81POJO%E7%AD%89%E8%A7%A3%E9%87%8A/</url>
      <content type="html"><![CDATA[]]></content>
      
      
    </entry>
    
    <entry>
      <title>UML类图中的6种关系</title>
      <link href="/2018/06/15/UML%E7%B1%BB%E5%9B%BE%E4%B8%AD%E7%9A%846%E7%A7%8D%E5%85%B3%E7%B3%BB/"/>
      <url>/2018/06/15/UML%E7%B1%BB%E5%9B%BE%E4%B8%AD%E7%9A%846%E7%A7%8D%E5%85%B3%E7%B3%BB/</url>
      <content type="html"><![CDATA[<p>关系强度依次降低</p><p>因为Java单继承，所以继承&gt;实现</p><p>继承&gt;实现&gt;聚合&gt;组合&gt;关联&gt;依赖</p><ol><li>继承-Generalization</li></ol><p>符号:实线+空心三角箭头</p><p>语法:继承父类</p><ol start="2"><li>实现（Realization）</li></ol><p>符号：虚线+空心三角箭头</p><p>语法：实现接口</p><ol start="3"><li>聚合（Aggregation）</li></ol><p>符号：空心菱形+实线+普通箭头</p><p>含义：部分和整体，部分离开整体单独存在有意义，比如车和轮胎</p><p>语法：成员变量</p><ol start="4"><li>组合（composition）</li></ol><p>符号：实心菱形+实线+普通箭头</p><p>含义：部分离开整体无意义，比如公司和部门</p><p>语法：内部类+成员变量</p><ol start="5"><li>关联（Association）</li></ol><p>符号：实线+单向或双向箭头</p><p>含义：非部分和整体关系，一般来说双向关联都是关联关系，例如学生和老师，单向也可能是，例如学生和课程。</p><p>语法：成员变量</p><ol start="6"><li>依赖（Dependency）</li></ol><p>符号：虚线+普通箭头</p><p>语法：局部变量、方法参数、返回值、静态类的调用</p>]]></content>
      
      
        <tags>
            
            <tag> uml </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>设计模式六大原则</title>
      <link href="/2018/06/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99/"/>
      <url>/2018/06/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99/</url>
      <content type="html"><![CDATA[<h3 id="单一职责原则（SRP-Single-Responsibility-Principle）"><a href="#单一职责原则（SRP-Single-Responsibility-Principle）" class="headerlink" title="单一职责原则（SRP-Single Responsibility Principle）"></a>单一职责原则（SRP-Single Responsibility Principle）</h3><p>定义：有且仅有一个原因引起类的变更</p><p>实践：合理拆分接口、类、和方法</p><p>好处：</p><ol><li>类的复杂性降低</li><li>可读性提高</li><li>可维护性提高</li><li>变更引起的风险降低</li></ol><h3 id="里氏替换原则（LSP-Lis-Substitution-Principle）"><a href="#里氏替换原则（LSP-Lis-Substitution-Principle）" class="headerlink" title="里氏替换原则（LSP-Lis Substitution Principle）"></a>里氏替换原则（LSP-Lis Substitution Principle）</h3><p>定义：</p><ol><li>所有引用基类的地方必须能够透明使用子类的对象，父类的所有方法对子类来说都要有意义，调用时必须使用父类或接口</li><li>有子类出现的地方其他子类不可用</li><li>覆盖或者实现父类的方法时参数可以被放大，比如父类是HashMap，子类是Map，实现了重载（Overload）<br>4.覆盖或者实现父类的方法时返回值可以缩小，比如父类是Map，子类是Hashmap,实现了覆盖（Override） </li></ol><p>实践：如果子类不能完整实现父类的方法，或者父类方法对子类没意义，建议断开继承关系，采用依赖，聚集，组合等关系代替。比如玩具枪和枪</p><h3 id="依赖倒置原则-DIP-Dependenc-Inversion-Principle"><a href="#依赖倒置原则-DIP-Dependenc-Inversion-Principle" class="headerlink" title="依赖倒置原则(DIP-Dependenc Inversion Principle)"></a>依赖倒置原则(DIP-Dependenc Inversion Principle)</h3><p>定义：</p><ol><li>高层模块不应该依赖底层模块，两者都应该依赖其抽象（抽象类或者接口）</li><li>抽象不应该依赖细节</li><li>细节应该依赖抽象</li></ol><p>实践：Spring的依赖注入</p><h3 id="接口隔离原则（IIP-Interface-Isolate-Principle）"><a href="#接口隔离原则（IIP-Interface-Isolate-Principle）" class="headerlink" title="接口隔离原则（IIP-Interface Isolate Principle）"></a>接口隔离原则（IIP-Interface Isolate Principle）</h3><p>定义：类间的依赖关系应该建立在最小的接口上<br>和SRP的区别：接口符合SRP，但不一定符合IIP，SRP可以再细分包含多个IIP</p><p>实践：一个接口只服务于一个子模块或者业务逻辑</p><h3 id="迪米特法则-最少知识原则（LKP-Least-Knowledge-Principle）"><a href="#迪米特法则-最少知识原则（LKP-Least-Knowledge-Principle）" class="headerlink" title="迪米特法则-最少知识原则（LKP-Least Knowledge Principle）"></a>迪米特法则-最少知识原则（LKP-Least Knowledge Principle）</h3><p>定义：</p><ol><li>之和直接朋友交流，出现在成员变量，方法输入输出中的类是朋友，局部变量不算朋友。不要出现getA().getB().getC()这种</li><li>朋友之间不要太亲密，即不要依赖太多朋友的方法或者成员</li><li>方法放在本类中可以，放在其他类也可以，那就方法本类。</li></ol><h3 id="开闭原则-OCP-OPEN-CLOSE-Principle"><a href="#开闭原则-OCP-OPEN-CLOSE-Principle" class="headerlink" title="开闭原则(OCP-OPEN CLOSE Principle)"></a>开闭原则(OCP-OPEN CLOSE Principle)</h3><p>定义:<br>1.对扩展开放，对修改关闭。</p><p>实践：使用继承</p>]]></content>
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>springmvc工作原理</title>
      <link href="/2018/06/12/springmvc%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"/>
      <url>/2018/06/12/springmvc%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</url>
      <content type="html"><![CDATA[<ol><li>匹配DispatcherServlet</li></ol><p>客户端发送HTTP请求，web应用服务器（tomcat或者jetty等）接收到HTTP请求之后，如果匹配DispatcherServlet的请求路径（web.xml指定），则交给DispatcherServlet处理</p><ol start="2"><li><p>DispathcerServelt接收到请求之后，根据请求的信息（url，header，请求方法，cookie等）找到相应的HanlerMaping（RequestMapping），根据HandlerMapping找到对应的处理方法</p></li><li><p>处理方法完成之后，因为@ResponseBody指定了当前Handler使用JsonViewer解析器，并设置头为application/json，返回Json</p></li></ol>]]></content>
      
      
        <tags>
            
            <tag> springmvc </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>程序员的出路在哪里</title>
      <link href="/2018/06/03/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E5%87%BA%E8%B7%AF%E5%9C%A8%E5%93%AA%E9%87%8C/"/>
      <url>/2018/06/03/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E5%87%BA%E8%B7%AF%E5%9C%A8%E5%93%AA%E9%87%8C/</url>
      <content type="html"><![CDATA[]]></content>
      
      
    </entry>
    
    <entry>
      <title>lombok的@RequiredArgsConstructor</title>
      <link href="/2018/06/01/lombok%E7%9A%84-RequiredArgsConstructor/"/>
      <url>/2018/06/01/lombok%E7%9A%84-RequiredArgsConstructor/</url>
      <content type="html"><![CDATA[<p>细节方面请阅读：<a href="https://projectlombok.org/features/constructor" target="_blank" rel="noopener">https://projectlombok.org/features/constructor</a></p><p>如果想用注解快速实现一个构造方法，构造方法包含部分字段，用@RequiredArgsConstructor以及@NonNull即可</p><p>如下包含一个参数为start和end的构造方法<br><img src="/2018/06/01/lombok的-RequiredArgsConstructor/constructor.png" title="constructor"></p><pre><code>@RequiredArgsConstructorpublic class ForkJoinDemo extends RecursiveTask&lt;Long&gt;{    private static final int THRESHOLD=10000;    @NonNull    private long start;    @NonNull    private long end;    private long delay=0;    @Override    protected Long compute() {        long sum=0;        return null;    }    public static void main(String[] args) {        ForkJoinDemo forkJoinDemo=new ForkJoinDemo();    }}</code></pre>]]></content>
      
      
    </entry>
    
    <entry>
      <title>jdk和jvm</title>
      <link href="/2018/05/30/jdk%E5%92%8Cjvm/"/>
      <url>/2018/05/30/jdk%E5%92%8Cjvm/</url>
      <content type="html"><![CDATA[<p>对《Java虚拟机精讲》学习到的内容做简要概括。</p><h2 id="jvm"><a href="#jvm" class="headerlink" title="jvm"></a>jvm</h2><h3 id="HotSpot-VM"><a href="#HotSpot-VM" class="headerlink" title="HotSpot VM"></a>HotSpot VM</h3><p>特点：</p><ol><li>热点探测</li></ol><p>将频繁调用的方法标记为“热点代码”</p><ol start="2"><li>双重JIT</li></ol><p>JIT包括JIT编译器和JIT执行器，两者并行。</p><p>内嵌两个JIT编译器-Client Compiler和Server Compiler,Server Compiler优化程度高，编译时间长，但可能会因为优化过高出现指令重排导致的并发问题。</p><p>解释器解释字节码，“热点代码”通过JIT编译器编译成本地机器指令。</p><p>虚拟机启动时编译器进行热点代码编译，解释器直接解释先发挥作用，编译器将热点代码编译完成机器指令后，后续可以直接执行机器指令提高效率。</p><p>可以通过命令指定完全编译还是完全解释。可以完全解释，但完全编译不一定成功，即使完全编译，必要时还会解释来保证顺序执行。</p><h2 id="JDK"><a href="#JDK" class="headerlink" title="JDK"></a>JDK</h2><p>OpenJdk是JDK的完全开源版本，两者除了部分存在版权的代码之其他部分几乎一摸一样，90%相同。是研究JVM的好方案。</p>]]></content>
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>js的类数组对象</title>
      <link href="/2018/05/21/js%E7%9A%84%E7%B1%BB%E6%95%B0%E7%BB%84%E5%AF%B9%E8%B1%A1/"/>
      <url>/2018/05/21/js%E7%9A%84%E7%B1%BB%E6%95%B0%E7%BB%84%E5%AF%B9%E8%B1%A1/</url>
      <content type="html"><![CDATA[<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>/*** Created by zhangweixiao on 2018/5/21.*///like-array test</code></pre><h3 id="1-元素下标不是数字，未定义length"><a href="#1-元素下标不是数字，未定义length" class="headerlink" title="1. 元素下标不是数字，未定义length"></a>1. 元素下标不是数字，未定义length</h3><pre><code>function func1() {    var likeArray={};    var i=0;    for(;i&lt;2;i++)    {        likeArray[&quot;i&quot;+i]=i*5;    }    // likeArray.length=i;    Array.prototype.push.call(likeArray,&#39;first&#39;);    console.log(likeArray.length);    console.log(likeArray[0])    console.log(likeArray[1])    console.log(likeArray[2])};func1();console.log(&quot;---------------------------------&quot;);</code></pre><h3 id="2-元素下标不是数字，定义length"><a href="#2-元素下标不是数字，定义length" class="headerlink" title="2. 元素下标不是数字，定义length"></a>2. 元素下标不是数字，定义length</h3><pre><code>function func2() {    var likeArray={};    var i=0;    for(;i&lt;2;i++)    {        likeArray[&quot;i&quot;+i]=i*5;    }    likeArray.length=i;    Array.prototype.push.call(likeArray,&#39;first&#39;);    console.log(likeArray.length);    console.log(likeArray[&quot;i0&quot;])    console.log(likeArray[&quot;i1&quot;])    console.log(likeArray[2])};func2();console.log(&quot;---------------------------------&quot;);</code></pre><h3 id="3-元素下表是数字，未定义length"><a href="#3-元素下表是数字，未定义length" class="headerlink" title="3.元素下表是数字，未定义length"></a>3.元素下表是数字，未定义length</h3><pre><code>function func3() {    var likeArray={};    var i=0;    for(;i&lt;2;i++)    {        likeArray[i]=i*5;    }    // likeArray.length=i;    Array.prototype.push.call(likeArray,&#39;first&#39;);    console.log(likeArray.length);    console.log(likeArray[0])    console.log(likeArray[1])    console.log(likeArray[2])};func3();console.log(&quot;---------------------------------&quot;);</code></pre><h3 id="4-元素下标是数字，定义length"><a href="#4-元素下标是数字，定义length" class="headerlink" title="4.元素下标是数字，定义length"></a>4.元素下标是数字，定义length</h3><pre><code>function func4() {    var likeArray={};    var i=0;    for(;i&lt;2;i++)    {        likeArray[i]=i*5;    }    likeArray.length=i;    Array.prototype.push.call(likeArray,&#39;first&#39;);    console.log(likeArray.length);    console.log(likeArray[0])    console.log(likeArray[1])    console.log(likeArray[2])};func4();console.log(&quot;---------------------------------&quot;);</code></pre><h3 id="5-length不可写"><a href="#5-length不可写" class="headerlink" title="5.length不可写"></a>5.length不可写</h3><pre><code>function func5(){    var func41=function()    {        console.log(Object.getOwnPropertyDescriptor(func41,&#39;length&#39;));    };    Array.prototype.push.call(func41,&#39;first&#39;);    console.log(func41.length);}func5();console.log(&quot;---------------------------------&quot;);</code></pre><h3 id="6-对象不可存取"><a href="#6-对象不可存取" class="headerlink" title="6.对象不可存取"></a>6.对象不可存取</h3><pre><code>function func6(){    var num=1;    Array.prototype.push.call(num,&#39;first&#39;);    console.log(num.length);}func6();</code></pre><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>以上5个测试方法中，方法4报错。</p><p>注释掉后，运行结果：</p><pre><code>1firstundefinedundefined---------------------------------1first5undefined---------------------------------305first---------------------------------undefined</code></pre><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>一个类数组对象，数组元素的下标不必必须是数字,如果对象的数组中有元素，需要指定length。</p><p>同时要求对象本身可存取属性-func6，length可写-func5</p><p>func2，func4是正确的类数组对象。</p>]]></content>
      
      <categories>
          
          <category> Javascript </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>call和apply的区别</title>
      <link href="/2018/05/20/call%E5%92%8Capply%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2018/05/20/call%E5%92%8Capply%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      <content type="html"><![CDATA[<h3 id="如果不用call和apply呢？"><a href="#如果不用call和apply呢？" class="headerlink" title="如果不用call和apply呢？"></a>如果不用call和apply呢？</h3><p>下面的结果会是多少？</p><pre><code>var func1=function(){    var args=arguments.join(&#39;-&#39;);    return args;};func1(1,2,3);</code></pre><p>结果：运行错误，因为arguements是一个类数组，实际上是一个object.<br>根本没有join这个方法。</p><p>用arguements instance of Array测试即可。</p><h3 id="下面的结果是"><a href="#下面的结果是" class="headerlink" title="下面的结果是?"></a>下面的结果是?</h3><pre><code>var func2=function(){    var args=Array.prototype.join.call(arguments,&#39;-&#39;);    return args;};func2(1,2,3);</code></pre><p>结果：1-2-3</p><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>翻看chrome的v8引擎中的push部分代码</p><p><a href="https://github.com/v8/v8/blob/0c76b0ae850027006d5ec0d92449e449d996d3bb/src/js/array.js" target="_blank" rel="noopener">https://github.com/v8/v8/blob/0c76b0ae850027006d5ec0d92449e449d996d3bb/src/js/array.js</a></p><pre><code>function ArrayPush() {CHECK_OBJECT_COERCIBLE(this, &quot;Array.prototype.push&quot;);var array = TO_OBJECT(this);var n = TO_LENGTH(array.length);//如果this是个对象，n为0var m = arguments.length;// Subtract n from kMaxSafeInteger rather than testing m + n &gt;// kMaxSafeInteger. n may already be kMaxSafeInteger. In that case adding// e.g., 1 would not be safe.if (m &gt; kMaxSafeInteger - n) throw MakeTypeError(kPushPastSafeLength, m, n);for (var i = 0; i &lt; m; i++) {    array[i+n] = arguments[i];//追加到arguments}var new_length = n + m;//更新lenghtharray.length = new_length;return new_length;}</code></pre>]]></content>
      
      
    </entry>
    
    <entry>
      <title>两个栈组成队列</title>
      <link href="/2018/05/20/%E4%B8%A4%E4%B8%AA%E6%A0%88%E7%BB%84%E6%88%90%E9%98%9F%E5%88%97/"/>
      <url>/2018/05/20/%E4%B8%A4%E4%B8%AA%E6%A0%88%E7%BB%84%E6%88%90%E9%98%9F%E5%88%97/</url>
      <content type="html"><![CDATA[<pre><code>import java.util.Stack;/*** Created by zwxbest on 2018/5/20.*/public class TwoStatckQueue {    private Stack&lt;Integer&gt; stackPush=new Stack&lt;&gt;();    private Stack&lt;Integer&gt; stackPop=new Stack&lt;&gt;();    public static void main(String[] args)    {        TwoStatckQueue queue=new TwoStatckQueue();        queue.add(1);        queue.add(2);        System.out.println(queue.poll());        queue.add(3);        System.out.println(queue.peek());    }    public void add(int value)    {        stackPush.add(value);    }    public int poll()    {        handlePop();        return stackPop.pop();    }    private void handlePop()    {        if(stackPop.empty()&amp;&amp;stackPush.empty())        {            throw new RuntimeException(&quot;Query is Empty&quot;);        }        else if(stackPop.empty())        {            //当push栈不为空时，且pop栈为空时，将pop栈全部数据pop后push到push栈            while (!stackPush.empty())            {                stackPop.push(stackPush.pop());            }        }    }    public int peek()    {        handlePop();        return stackPop.peek();    }}</code></pre>]]></content>
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
            <tag> 队列 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>linux常用命令</title>
      <link href="/2018/05/20/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2018/05/20/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      <content type="html"><![CDATA[<h3 id="快速打开日志"><a href="#快速打开日志" class="headerlink" title="快速打开日志"></a>快速打开日志</h3><p>我们的日志是按照小时来写文件的，名字很长，比如</p><p>com.nizouba.log.2018-05-19-11<br>com.nizouba.log.2018-05-18-12<br>com.nizouba.log.2018-05-19-10</p><p>用通配符，比如vim <em>19</em>11</p><h1 id="打印"><a href="#打印" class="headerlink" title="打印"></a>打印</h1><h3 id="find命令"><a href="#find命令" class="headerlink" title="find命令"></a>find命令</h3><p>-o or的意思</p><p>-a and，默认是-a</p><p>比如find .git -name HEAD -o -name master</p><p>参考：<a href="http://man7.org/linux/man-pages/man1/find.1.html" target="_blank" rel="noopener">http://man7.org/linux/man-pages/man1/find.1.html</a></p><h1 id="yum"><a href="#yum" class="headerlink" title="yum"></a>yum</h1><h2 id="yum-install"><a href="#yum-install" class="headerlink" title="yum install"></a>yum install</h2><p>-y 对所有的提问都回答“yes”；</p><h1 id="系统资源查看"><a href="#系统资源查看" class="headerlink" title="系统资源查看"></a>系统资源查看</h1><h2 id="free"><a href="#free" class="headerlink" title="free"></a>free</h2><ul><li>mem物理内存</li><li>swap交换内存，放在硬盘上的，性能差，最好不要超过20%</li><li>shared 已使用中共享的内存 </li><li>buffer 已使用中缓冲量</li><li>cached 已使用中缓存量</li></ul><h2 id="top"><a href="#top" class="headerlink" title="top"></a>top</h2><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><ul><li>-d 更新频率-s，默认5s</li><li>-b 按照批次执行</li><li>-n 与-b配合，要执行几次top -b</li><li>-p 指定某个pid进行观察监测</li><li>-p  ：指定某些个 PID 来进行观察监测而已。 </li><li>在 top 执行过程当中可以使用的按键指令：<br>? ：显示在 top 当中可以输入的按键指令；<br>P ：以 CPU 的使用资源排序显示；<br>M ：以 Memory 的使用资源排序显示；<br>N ：以 PID 来排序喔！<br>T ：由该 Process 使用的 CPU 时间累积 (TIME+) 排序。<br>k ：给予某个 PID 一个讯号  (signal)<br>r ：给予某个 PID 重新制订一个 nice 值。 todo:这里不懂</li></ul><p>top 主要分为两个画面，上面的画面为整个系统的资源使用状态，基本上总共有六行， 显示的内容依序是：  </p><ul><li>第一行：显示系统已启动的时间、目前上线人数、系统整体的负载(load)。 比较需要注意的是系<br>统的负载，三个数据分别代表 1, 5, 10 分钟的平均负载。 一般来说，这个负载值应该不太可能<br>超过 1 才对，除非您的系统很忙碌。 如果持续高于 5 的话，那么…..仔细的看看到底是那个<br>程序在影响整体系统吧！ </li><li>第二行：显示的是目前的观察程序数量，比较需要注意的是最后的 zombie 那个数值，如果不是<br>0 ，嘿嘿！好好看看到底是那个 process 变成疆尸了吧？！ </li><li>第三行：显示的是 CPU 的整体负载，每个项目可使用 ? 查阅。需要观察的是 id (idle) 的数值，<br>一般来说，他应该要接近 100% 才好，表示系统很少资源被使用啊！ ^_^。 </li><li>第四行与第五行：表示目前的物理内存与虚拟内存 (Mem/Swap) 的使用情况。 </li><li>第六行：这个是当在 top 程序当中输入指令时，显示状态的地方。 比如输入k或者r<br>至于 top 底下的画面，则是每个 process 使用的资源情况。比较需要注意的是：  </li><li>PID ：每个 process 的 ID 啦！  </li><li>USER：该 process 所属的使用者；  </li><li>PR ：Priority 的简写，程序的优先执行顺序，越小越早被执行；  </li><li>NI ：Nice 的简写，与 Priority 有关，也是越小越早被执行；  </li><li>%CPU：CPU 的使用率；  </li><li>%MEM：内存的使用率；  </li><li>TIME+：CPU 使用时间的累加； </li></ul><h1 id="打印-1"><a href="#打印-1" class="headerlink" title="打印"></a>打印</h1><h2 id="nl（NL）"><a href="#nl（NL）" class="headerlink" title="nl（NL）"></a>nl（NL）</h2><p>添加行号打印</p><h3 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h3><ul><li>-b 空行是否列出行号</li><li>-n 行号在左边还是右边显示</li><li>-w 行号占用的位数</li></ul><h3 id="tac"><a href="#tac" class="headerlink" title="tac"></a>tac</h3><p>tac log.log |more </p><h1 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h1><h2 id="参数-2"><a href="#参数-2" class="headerlink" title="参数"></a>参数</h2><ul><li>[n1,[n2]]function,function包括 a-新增 ，c-取代，d-删除，i-插入，p-打印，s-取代<h1 id="i-直接编辑文件选项-i，会匹配file文件中每一行的第一个book替换为books"><a href="#i-直接编辑文件选项-i，会匹配file文件中每一行的第一个book替换为books" class="headerlink" title="i 直接编辑文件选项-i，会匹配file文件中每一行的第一个book替换为books"></a>i 直接编辑文件选项-i，会匹配file文件中每一行的第一个book替换为books</h1></li></ul><h3 id="仅列出5-7行"><a href="#仅列出5-7行" class="headerlink" title="仅列出5-7行"></a>仅列出5-7行</h3><p> sed -n ‘5,7p’ </p><h2 id="输入与输出"><a href="#输入与输出" class="headerlink" title="输入与输出"></a>输入与输出</h2><p>stdin 0<br>stdout 1<br>stderr 2</p><p>#内容处理</p><h1 id="cut"><a href="#cut" class="headerlink" title="cut"></a>cut</h1><p>  [root@linux ~]# cut -d’分隔字符’ -f fields<br>  [root@linux ~]# cut -c 字符区间<br>  参数：<br>  -d  ：后面接分隔字符。与 -f 一起使用；<br>  -f  ：依据 -d 的分隔字符将一段讯息分割成为数段，用 -f 取出第几段的意思；<br>  -c  ：以字符 (characters) 的单位取出固定字符区间；<br>  范例： </p><p>  范例一：将 PATH 变量取出，我要找出第三个路径。<br>  [root@linux ~]# echo $PATH<br>  /bin:/usr/bin:/sbin:/usr/sbin:/usr/local/bin:/usr/X11R6/bin:/usr/games:<br>  [root@linux ~]# echo $PATH | cut -d ‘:’ -f 5<br>  # 嘿嘿！如此一来，就会出现 /usr/local/bin 这个目录名称！<br>  # 因为我们是以 : 作为分隔符，第五个就是 /usr/local/bin 啊！<br>  # 那么如果想要列出第 3 与第 5 呢？，就是这样：<br>  [root@linux ~]# echo $PATH | cut -d ‘:’ -f 3,5 </p><p>  范例二：将 export 输出的讯息，取得第 12 字符以后的所有字符串<br>  [root@linux ~]# export<br>  declare -x HISTSIZE=”1000”<br>  declare -x INPUTRC=”/etc/inputrc”<br>  declare -x KDEDIR=”/usr”<br>  declare -x LANG=”zh_TW.big5”<br>  ……其它省略……<br>  [root@linux ~]# export | cut -c 12-<br>  HISTSIZE=”1000”<br>  INPUTRC=”/etc/inputrc”<br>  KDEDIR=”/usr”<br>  LANG=”zh_TW.big5”<br>  ……其它省略……<br>  # 知道怎么回事了吧？用 -c 可以处理比较具有格式的输出数据！<br>  # 我们还可以指定某个范围的值，例如第 12-20 的字符，就是 cut -c 12-20 等等！ </p><p>  范例三：用 last 将这个月登入者的信息中，仅留下使用者大名<br>  [root@linux ~]# last<br>  vbird  tty1  192.168.1.28   Mon Aug 15 11:55 - 17:48  (05:53)<br>  vbird  tty1  192.168.1.28   Mon Aug 15 10:17 - 11:54  (01:37)<br>  [root@linux ~]# last | cut -d ‘ ‘ -f 1<br>  # 用 last 可以取得最近一个月登入主机的使用者信息，<br>  # 而我们可以利用空格符的间隔，取出第一个信息，就是使用者账号啰！<br>  # 但是因为 vbird tty1 之间空格有好几个，并非仅有一个，所以，如果要找出<br>  # tty1 其实不能以 cut -d ‘ ‘ -f 1,2 喔！输出的结果会不是我们想要的。</p><p>不过， cut 在处理多空格相连的数据<br>时，可能会比较吃力一点～</p><h2 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h2><p>  root@linux ~]# grep [-acinv] ‘搜寻字符串’ filename<br>  参数：<br>  -a ：将 binary 档案以 text 档案的方式搜寻数据<br>  -c ：计算找到 ‘搜寻字符串’ 的次数<br>  -i ：忽略大小写的不同，所以大小写视为相同<br>  -n ：顺便输出行号<br>  -v ：反向选择，亦即显示出没有 ‘搜寻字符串’ 内容的那一行！<br>  范例： </p><p>  范例一：将 last 当中，有出现 root 的那一行就取出来；<br>  [root@linux ~]# last | grep ‘root’ </p><p>  范例二：与范例一相反，只要没有 root 的就取出！<br>  [root@linux ~]# last | grep -v ‘root’ </p><p>  范例三：在 last 的输出讯息中，只要有 root 就取出，并且仅取第一栏<br>  [root@linux ~]# last | grep ‘root’ |cut -d ‘ ‘ -f1<br>  # 在取出 root 之后，利用上个指令 cut 的处理，就能够仅取得第一栏啰！ </p><h2 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h2><p>sort 是很有趣的指令，他可以帮我们进行排序，而且可以依据不同的数据型态来排序喔！ 例如数字与文<br>字的排序就不一样。此外，排序的字符与语系的编码有关，因此， 如果您需要排序时，建议使用 LC_ALL=C<br>来让语系统一，数据排序比较好一些。 </p><p>  [root@linux ~]# sort [-fbMnrtuk] [file or stdin]<br>  参数：<br>  -f  ：忽略大小写的差异，例如 A 与 a 视为编码相同；<br>  -b  ：忽略最前面的空格符部分；<br>  -M  ：以月份的名字来排序，例如 JAN, DEC 等等的排序方法；<br>  -n  ：使用『纯数字』进行排序(预设是以文字型态来排序的)；<br>  -r  ：反向排序；<br>  -u  ：就是 uniq ，相同的数据中，仅出现一行代表；<br>  -t  ：分隔符，预设是 tab 键；<br>  -k  ：以那个区间 (field) 来进行排序的意思，<br>  范例： </p><p>  范例一：个人账号都记录在 /etc/passwd 下，请将账号进行排序。<br>  [root@linux ~]# cat /etc/passwd | sort<br>  adm:x:3:4:adm:/var/adm:/sbin/nologin<br>  apache:x:48:48:Apache:/var/www:/sbin/nologin<br>  bin:x:1:1:bin:/bin:/sbin/nologin<br>  daemon:x:2:2:daemon:/sbin:/sbin/nologin </p><h1 id="我省略很多的输出～由上面的数据看起来，-sort-是预设『以第一个』数据来排序，"><a href="#我省略很多的输出～由上面的数据看起来，-sort-是预设『以第一个』数据来排序，" class="headerlink" title="我省略很多的输出～由上面的数据看起来， sort 是预设『以第一个』数据来排序，"></a>我省略很多的输出～由上面的数据看起来， sort 是预设『以第一个』数据来排序，</h1><h1 id="而且预设是以『文字』型态来排序的喔！所以由-a-开始排到最后啰！"><a href="#而且预设是以『文字』型态来排序的喔！所以由-a-开始排到最后啰！" class="headerlink" title="而且预设是以『文字』型态来排序的喔！所以由 a 开始排到最后啰！"></a>而且预设是以『文字』型态来排序的喔！所以由 a 开始排到最后啰！</h1><p>  范例二：/etc/passwd 内容是以 : 来分隔的，我想以第三栏来排序，该如何？<br>  [root@linux ~]# cat /etc/passwd | sort -t ‘:’ -k 3<br>  root:x:0:0:root:/root:/bin/bash<br>  iiimd:x:100:101:IIIMF server:/usr/lib/iiim:/sbin/nologin<br>  uucp:x:10:14:uucp:/var/spool/uucp:/sbin/nologin<br>  operator:x:11:0:operator:/root:/sbin/nologin<br>  bin:x:1:1:bin:/bin:/sbin/nologin<br>  games:x:12:100:games:/usr/games:/sbin/nologin </p><h1 id="看到特殊字体的输出部分了吧？怎么会这样排列啊？呵呵！没错啦～"><a href="#看到特殊字体的输出部分了吧？怎么会这样排列啊？呵呵！没错啦～" class="headerlink" title="看到特殊字体的输出部分了吧？怎么会这样排列啊？呵呵！没错啦～"></a>看到特殊字体的输出部分了吧？怎么会这样排列啊？呵呵！没错啦～</h1><h1 id="如果是以文字型态来排序的话，原本就会是这样，想要使用数字排序："><a href="#如果是以文字型态来排序的话，原本就会是这样，想要使用数字排序：" class="headerlink" title="如果是以文字型态来排序的话，原本就会是这样，想要使用数字排序："></a>如果是以文字型态来排序的话，原本就会是这样，想要使用数字排序：</h1><h1 id="cat-etc-passwd-sort-t-‘-’-k-3-n"><a href="#cat-etc-passwd-sort-t-‘-’-k-3-n" class="headerlink" title="cat /etc/passwd | sort -t ‘:’ -k 3 -n"></a>cat /etc/passwd | sort -t ‘:’ -k 3 -n</h1><h1 id="这样才行啊！用那个-n-来告知-sort-以数字来排序啊！"><a href="#这样才行啊！用那个-n-来告知-sort-以数字来排序啊！" class="headerlink" title="这样才行啊！用那个 -n 来告知 sort 以数字来排序啊！"></a>这样才行啊！用那个 -n 来告知 sort 以数字来排序啊！</h1><p>  范例三：利用 last ，将输出的数据仅取账号，并加以排序<br>  [root@linux ~]# last | cut -d ‘ ‘ -f1 | sort<br>  cut的f1表示取出第一段</p><h1 id="uniq"><a href="#uniq" class="headerlink" title="uniq"></a>uniq</h1><p>如果我排序完成了，想要将重复的资料仅列出一个显示，可以怎么做呢？ </p><p>  [root@linux ~]# uniq [-ic]<br>  参数：<br>  -i  ：忽略大小写字符的不同；<br>  -c  ：进行计数<br>  范例： </p><p>  范例一：使用 last 将账号列出，仅取出账号栏，进行排序后仅取出一位；<br>  [root@linux ~]# last | cut -d ‘ ‘ -f1 | sort | uniq </p><p>  范例二：承上题，如果我还想要知道每个人的登入总次数呢？<br>  [root@linux ~]# last | cut -d ‘ ‘ -f1 | sort | uniq -c </p><p>  这个指令用来将『重复的行删除掉只显示一个』，举个例子来说， 你要知道这个月份登入你主机的使用者<br>  有谁，而不在乎他的登入次数，那么就使用上面的范例， (1)先将所有的数据列出；(2)再将人名独立出来；<br>  (3)经过排序；(4)只显示一个！ 由于这个指令是在将重复的东西减少，所以当然需要『配合排序过的档案』<br>  来处理啰！ </p><h1 id="wc"><a href="#wc" class="headerlink" title="wc"></a>wc</h1>]]></content>
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>bash使用技巧大全</title>
      <link href="/2018/05/20/bash%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%E5%A4%A7%E5%85%A8/"/>
      <url>/2018/05/20/bash%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%E5%A4%A7%E5%85%A8/</url>
      <content type="html"><![CDATA[<h3 id="移动"><a href="#移动" class="headerlink" title="移动"></a>移动</h3><p>Ctrl + a ：移到命令行首<br>Ctrl + e ：移到命令行尾</p><p>Ctrl + xx：在命令行首和光标之间跳跃</p><p>Ctrl+左右键移动单词</p><p>左右移n个单词：Alt+n,ctrl+左键，右移用ctrl+右键</p><p>最快捷的方式：Ctrl+r搜索，当前的命令也会搜索，光标跳转过去，然后ESC,如果有多个命令匹配，按CTRl+R切换</p><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>Ctrl + u ：从光标处删除至命令行首</p><p>Ctrl + k ：从光标处删除至命令行尾</p><p>Ctrl + w ：从光标处删除至单位首</p><p>Alt + d ：从光标处删除至单词尾</p><p>在单词中间删除整个单词的没找到，如果需要配置删除多个单词，可以尝试ctrl+左右键移动单词，配合Esc+数字参数，然后ctrl+w以及alt+d删除多个单词。</p><p>Ctrl + l：清屏</p><p>清空当前的命令，最好用Ctrl+C，不会计入历史</p><p>用ctrl+e，ctrl+u两步，不喜欢</p><h3 id="改动"><a href="#改动" class="headerlink" title="改动"></a>改动</h3><p>Alt + c ：从光标处更改为首字母大写的单词（还没想到什么用处）</p><p>Alt + u ：从光标处更改为全部大写的单词，有些命令需要大写可以转换</p><p>Alt + l ：从光标处更改为全部小写的单词</p><p>Ctrl + t ：交换光标处和之前的字符</p><p>Alt + t ：交换光标处和之前的单词（这个可能有用）</p><h3 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h3><p>Ctrl+(x u) 按住Ctrl的同时再先后按x和u，撤销刚才的操作</p><p>ctrl+/ ，这个方便一点。</p><p>反撤销不知道。</p><h3 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h3><p>Ctrl + r：逆向搜索命令历史，继续按Ctrl-R，它将遍历您的历史记录。</p><p>Alt + .：使用上一条命令的最后一个参数，可以用上看一下上一条命令，用ctrl+u清空，然后用alt+.使用。比如cp redis.conf /usr/local/redis,先输入cd，然后alt+.,这样可以直接跳过去</p><p>!!：执行上一条命令</p><p>!-n  倒数第n个历史命令</p><p>!blah：执行最近的以 blah 开头的命令，如 !ls</p><p>!blah:p：仅打印输出，而不执行</p><p>!$：上一条命令的最后一个参数，与 Alt + . 相同</p><p>!$:p：打印输出 !$ 的内容</p><p>!*：上一条命令的所有参数</p><p>!<em>:p：打印输出 !</em> 的内容</p><p>^blah：删除上一条命令中的 blah</p><p>^blah^foo：将上一条命令中的 blah 替换为 foo</p><p>^blah^foo^：将上一条命令中所有的 blah 都替换为 foo</p><p>magic-space  让历史记录表达式和参数符号立即显出原形，用bind Space:magic-space，比如!rm是 rm -rf /ruby-bin,我输入！rm按空格！rm就变成rm -rf /ruby-bin</p><p>可以把这句放到.bashrc中，让设置持久生效</p><p>HISTCONTROL=ignoredups  去除重复命令</p><p>使用上一条命令的输出结果</p><p>cat <code>find .git -name HEAD -o -name master|head -n 1</code></p>]]></content>
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bash </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>常用设计模式整理</title>
      <link href="/2018/05/20/%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%95%B4%E7%90%86/"/>
      <url>/2018/05/20/%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%95%B4%E7%90%86/</url>
      <content type="html"><![CDATA[<p><a href="https://github.com/zwxbest/DesignPatternLearning" target="_blank" rel="noopener">https://github.com/zwxbest/DesignPatternLearning</a></p>]]></content>
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>java线程基础</title>
      <link href="/2018/05/20/java%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
      <url>/2018/05/20/java%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/</url>
      <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="Sleep和Yield"><a href="#Sleep和Yield" class="headerlink" title="Sleep和Yield"></a>Sleep和Yield</h3><p>静态方法有两个，Sleep和Yield，相同点是都让出CPU，不同点是Sleep让出CU后休眠一段时间，这段时间不参与CPU竞争，Yield让出后还是继续参与竞争。PU一段时间</p><h3 id="Stop"><a href="#Stop" class="headerlink" title="Stop"></a>Stop</h3><p>已废弃</p><p><a href="https://github.com/zwxbest/Demo/blob/master/Concurrent/src/StopThreadUnsafe.java" target="_blank" rel="noopener">https://github.com/zwxbest/Demo/blob/master/Concurrent/src/StopThreadUnsafe.java</a></p><p>立即停止，暴力，会破坏逻辑，比如加锁了执行一半立即停止释放锁，会造成数据不同步问题。</p><h3 id="Suspend和Resume"><a href="#Suspend和Resume" class="headerlink" title="Suspend和Resume"></a>Suspend和Resume</h3><p>已废弃</p><p><a href="https://github.com/zwxbest/Demo/blob/master/Concurrent/src/SuspendAndResume.java" target="_blank" rel="noopener">https://github.com/zwxbest/Demo/blob/master/Concurrent/src/SuspendAndResume.java</a></p><p>Suspend暂停但不会释放锁</p><h3 id="线程创建的两种方式"><a href="#线程创建的两种方式" class="headerlink" title="线程创建的两种方式"></a>线程创建的两种方式</h3><p>继承Thread和实现Runnable</p><p><a href="https://github.com/zwxbest/Demo/blob/master/Concurrent/src/NewThread.java" target="_blank" rel="noopener">https://github.com/zwxbest/Demo/blob/master/Concurrent/src/NewThread.java</a></p><p><a href="https://github.com/zwxbest/Demo/blob/master/Concurrent/src/NewThreadRunnable.java" target="_blank" rel="noopener">https://github.com/zwxbest/Demo/blob/master/Concurrent/src/NewThreadRunnable.java</a></p><h3 id="实现Stop的方法"><a href="#实现Stop的方法" class="headerlink" title="实现Stop的方法"></a>实现Stop的方法</h3><ol><li>wait和notify</li></ol><p><a href="https://github.com/zwxbest/Demo/blob/master/Concurrent/src/StopThreadSafe.java" target="_blank" rel="noopener">https://github.com/zwxbest/Demo/blob/master/Concurrent/src/StopThreadSafe.java</a></p><ol start="2"><li>interrupt</li></ol><p><a href="https://github.com/zwxbest/Demo/blob/master/Concurrent/src/ThreadInterrupt2.java" target="_blank" rel="noopener">https://github.com/zwxbest/Demo/blob/master/Concurrent/src/ThreadInterrupt2.java</a></p><h3 id="实现suspend的方法"><a href="#实现suspend的方法" class="headerlink" title="实现suspend的方法"></a>实现suspend的方法</h3><p>wait和notify</p><p><a href="https://github.com/zwxbest/Demo/blob/master/Concurrent/src/WaitAmdNotify.java" target="_blank" rel="noopener">https://github.com/zwxbest/Demo/blob/master/Concurrent/src/WaitAmdNotify.java</a></p><p><a href="https://github.com/zwxbest/Demo/blob/master/Concurrent/src/WaitNotifyToResumeSuspend.java" target="_blank" rel="noopener">https://github.com/zwxbest/Demo/blob/master/Concurrent/src/WaitNotifyToResumeSuspend.java</a></p><h3 id="join的用法"><a href="#join的用法" class="headerlink" title="join的用法"></a>join的用法</h3><p><a href="https://github.com/zwxbest/Demo/blob/master/Concurrent/src/JoinAndYield.java" target="_blank" rel="noopener">https://github.com/zwxbest/Demo/blob/master/Concurrent/src/JoinAndYield.java</a></p><h3 id="线程组"><a href="#线程组" class="headerlink" title="线程组"></a>线程组</h3><p><a href="https://github.com/zwxbest/Demo/blob/master/Concurrent/src/ThreadGroupName.java" target="_blank" rel="noopener">https://github.com/zwxbest/Demo/blob/master/Concurrent/src/ThreadGroupName.java</a></p><h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><p><a href="https://github.com/zwxbest/Demo/blob/master/Concurrent/src/VolatileWrongUse.java" target="_blank" rel="noopener">https://github.com/zwxbest/Demo/blob/master/Concurrent/src/VolatileWrongUse.java</a></p><h3 id="原子性问题"><a href="#原子性问题" class="headerlink" title="原子性问题"></a>原子性问题</h3><p><a href="https://github.com/zwxbest/Demo/blob/master/Concurrent/src/MultiThreadLong.java" target="_blank" rel="noopener">https://github.com/zwxbest/Demo/blob/master/Concurrent/src/MultiThreadLong.java</a></p><h3 id="有序性和可见性"><a href="#有序性和可见性" class="headerlink" title="有序性和可见性"></a>有序性和可见性</h3><p><a href="https://github.com/zwxbest/Demo/blob/master/Concurrent/src/VisibilityAndOrdering.java" target="_blank" rel="noopener">https://github.com/zwxbest/Demo/blob/master/Concurrent/src/VisibilityAndOrdering.java</a></p><h3 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h3><p><a href="https://github.com/zwxbest/Demo/blob/master/Concurrent/src/ThreadInterrupt1.java" target="_blank" rel="noopener">https://github.com/zwxbest/Demo/blob/master/Concurrent/src/ThreadInterrupt1.java</a></p><p><a href="https://github.com/zwxbest/Demo/blob/master/Concurrent/src/ThreadInterrupt2.java" target="_blank" rel="noopener">https://github.com/zwxbest/Demo/blob/master/Concurrent/src/ThreadInterrupt2.java</a></p><p><a href="https://github.com/zwxbest/Demo/blob/master/Concurrent/src/ThreadInterruptWithSleep.java" target="_blank" rel="noopener">https://github.com/zwxbest/Demo/blob/master/Concurrent/src/ThreadInterruptWithSleep.java</a></p>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>java线程状态转换图</title>
      <link href="/2018/05/19/java%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E5%9B%BE/"/>
      <url>/2018/05/19/java%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E5%9B%BE/</url>
      <content type="html"><![CDATA[<img src="/2018/05/19/java线程状态转换图/thread.jpg" title="thread"><p>Sleep和yield并不会加锁或者解锁，</p><p>Sleep释放CPU，自己一段时间内不参与竞争</p><p>yield虽然释放CPU，还会竞争</p><p>两个都是静态方法</p><pre><code>@startuml[*]--&gt;NewNew-right--&gt;Runnable:t1.Start()Runnable-right--&gt;TERMINATE:don&#39;t use Stop(),\nuse flagRunnable--&gt;Blocked:遇到加锁Blocked--&gt;Runnable:获得锁Runnable--&gt;WAITING:遇到wait和joinWAITING--&gt;Runnable:遇到notify和join结束Runnable--&gt;TIMED_WATING:join限时TIMED_WATING--&gt;Runnable:join结束TERMINATE-&gt;[*]@enduml</code></pre>]]></content>
      
      
        <tags>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>hexo常用操作</title>
      <link href="/2018/05/19/hexo%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"/>
      <url>/2018/05/19/hexo%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</url>
      <content type="html"><![CDATA[<h3 id="添加图片"><a href="#添加图片" class="headerlink" title="添加图片"></a>添加图片</h3><p>好像需要hexo3以上,hexo -v查看。</p><ol><li><p>post_asset_folder: true</p></li><li><p>hexo new post “hexo常用操作大全” ,和之前创建文章一样,不过之后会在同级目录下创建一个”hexo常用操作大全”的目录,用来存放图片.</p></li></ol><p>3.</p><pre><code>{% asset_img 这是一个新的博客的图片.jpg 这是一个新的博客的图片的说明 %}</code></pre>]]></content>
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>不要在finally中处理返回值</title>
      <link href="/2018/05/19/%E4%B8%8D%E8%A6%81%E5%9C%A8finally%E4%B8%AD%E5%A4%84%E7%90%86%E8%BF%94%E5%9B%9E%E5%80%BC/"/>
      <url>/2018/05/19/%E4%B8%8D%E8%A6%81%E5%9C%A8finally%E4%B8%AD%E5%A4%84%E7%90%86%E8%BF%94%E5%9B%9E%E5%80%BC/</url>
      <content type="html"><![CDATA[<h3 id="下面会输出什么"><a href="#下面会输出什么" class="headerlink" title="下面会输出什么"></a>下面会输出什么</h3><pre><code>package com.nizouba;import java.util.zip.DataFormatException;/*** 不要在finally中处理返回值* Created by zwxbest on 2018/5/19.*/public class Advice113 {public static void main(String[] args){    try {        System.out.println(doSuff(-1));        System.out.println(doSuff(100));        System.out.println(doSuff1(-1));        System.out.println(doSuff1(100));        System.out.println(doSuff2(&quot;驼背李&quot;).name);        System.out.println(doSuff2(&quot;寡妇刘&quot;).name);    }    catch (Exception e)    {        System.out.println(&quot;这里是永远不会到达的&quot;);    }}public static int doSuff(int p) throws Exception{    try {        if(p&lt;0)        {            throw new DataFormatException(&quot;数据格式错误&quot;);        }        else        {            return p;        }    }    catch (Exception e)    {        throw e;    }    finally {        return 50;    }}public static int doSuff1(int p) throws Exception{    int a=p;    try {        return a;    }    catch (Exception e)    {        throw e;    }    finally {        //重新修改一下返回值        a=-1;    }//        return 0;}static class Person{   public String name;}public static Person doSuff2(String name) throws Exception{    Person p=new Person();    p.name=name;    try {        return p;    }    catch (Exception e)    {        throw e;    }    finally {        p.name=&quot;finally&quot;;    }    p.name=&quot;王二麻子&quot;;    return p;}</code></pre><p>}</p><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p>编译错误，doSuff2：无法访问的语句</p><p>如果注释掉</p><pre><code>p.name=&quot;王二麻子&quot;;return p;</code></pre><p>结果是</p><pre><code>5050-1100finallyfinally</code></pre><h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h3><p>我们知道，finally中的代码块是一定会执行的</p><p>执行到finally时，如果finally中有return，就会覆盖掉前面的return以及try和catch中的throw。</p><p>如果finally中没有return，try中有一定会执行的return，会在执行完finally后执行return。如果在finally中修改了try的return的值，基本类型不会变，引用类型做相应改变。</p><p>同时因为try中的return一定会执行，所以在finally之后的代码标记为不可到达，编辑错误。</p><p>如果try中的return是根据条件执行，那么finally之后的代码可能会执行，不会报错。</p>]]></content>
      
      
        <tags>
            
            <tag> java建议 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>匿名类的构造函数</title>
      <link href="/2018/05/19/%E5%8C%BF%E5%90%8D%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"/>
      <url>/2018/05/19/%E5%8C%BF%E5%90%8D%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/</url>
      <content type="html"><![CDATA[<p>本文来源：改善Java程序的151个建议-建议39</p><h3 id="原文的开胃菜改了一下"><a href="#原文的开胃菜改了一下" class="headerlink" title="原文的开胃菜改了一下"></a>原文的开胃菜改了一下</h3><p>各位看官觉得五个输出是什么？</p><pre><code>    public class Advice39 {    public static void main(String[] args)    {        List l1=new ArrayList();        List l2=new ArrayList(){};        List l3=new ArrayList(){{add(1);}};        System.out.println(l2 instanceof  ArrayList);        System.out.println(l3 instanceof  ArrayList);        System.out.println(l1.getClass().isAssignableFrom(l2.getClass()));        System.out.println(l2.getClass().isAssignableFrom(l1.getClass()));        System.out.println(l1.getClass().isAssignableFrom(l3.getClass()));        System.out.println(l2.getClass().isAssignableFrom(l3.getClass()));    }}</code></pre><p>答案是true,true,true,false,true,false</p><h3 id="编译后再进行反编译的源码"><a href="#编译后再进行反编译的源码" class="headerlink" title="编译后再进行反编译的源码"></a>编译后再进行反编译的源码</h3><pre><code>public class Advice39 {public Advice39() {}public static void main(String[] args) {    List l1 = new ArrayList();    List l2 = new ArrayList() {    };    List l3 = new ArrayList() {        {            this.add(Integer.valueOf(1));        }    };    System.out.println(l2 instanceof ArrayList);    System.out.println(l3 instanceof ArrayList);    System.out.println(l1.getClass().isAssignableFrom(l2.getClass()));    System.out.println(l1.getClass().isAssignableFrom(l3.getClass()));    System.out.println(l2.getClass().isAssignableFrom(l3.getClass()));}}</code></pre><p>可以看出l2是一个匿名类，继承于ArrayList，L3也是继承与ArrayList的匿名内部类，第二层{}是构造块。</p><h3 id="语法糖"><a href="#语法糖" class="headerlink" title="语法糖"></a>语法糖</h3><pre><code>package com.nizouba;import java.util.ArrayList;import java.util.List;/*** Created by zwxbest on 2018/5/19.*/public class Advice39_Inside {static class ArrayList2 extends ArrayList {};static class ArrayList3 extends ArrayList {    {        this.add(1);    }};public static void main(String[] args) {    List l1 = new ArrayList();    List l2 = new ArrayList2();    List l3 = new ArrayList3();    System.out.println(l2 instanceof ArrayList);    System.out.println(l3 instanceof ArrayList);    System.out.println(l1.getClass().isAssignableFrom(l2.getClass()));    System.out.println(l2.getClass().isAssignableFrom(l1.getClass()));    System.out.println(l1.getClass().isAssignableFrom(l3.getClass()));    System.out.println(l2.getClass().isAssignableFrom(l3.getClass()));    }}</code></pre>]]></content>
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>shiro运作活动图</title>
      <link href="/2018/05/18/shiro%E8%BF%90%E4%BD%9C%E6%B4%BB%E5%8A%A8%E5%9B%BE/"/>
      <url>/2018/05/18/shiro%E8%BF%90%E4%BD%9C%E6%B4%BB%E5%8A%A8%E5%9B%BE/</url>
      <content type="html"><![CDATA[<img src="/2018/05/18/shiro运作活动图/shiro.jpg" title="shiro"><h3 id="uml"><a href="#uml" class="headerlink" title="uml"></a>uml</h3><pre><code>@startumlstartpartition login{:token=new UsernamePasswordToken(loginId, password,rememberMe);:SecurityUtils.setSecurityManager(securityManager);note right@Autowiredend note:SecurityUtils.getSubject().login(token);}partition shiro{:login(AuthenticationToken token);:securityManager.login();}partition 项目{:doGetAuthenticationInfo(token);note right继承接口，验证密码是否匹配数据库end note}:onSuccessfulLogin(token, info, loggedIn);:rememberMeSuccessfulLogin();: forgetIdentity(subject);: rememberIdentity(subject, token, info);: rememberIdentity(subject, principals);note rightremember存储principals并加密end notestop@enduml</code></pre>]]></content>
      
      
        <tags>
            
            <tag> Shiro </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>svn分支合并到主干</title>
      <link href="/2018/05/17/svn%E5%88%86%E6%94%AF%E5%90%88%E5%B9%B6%E5%88%B0%E4%B8%BB%E5%B9%B2/"/>
      <url>/2018/05/17/svn%E5%88%86%E6%94%AF%E5%90%88%E5%B9%B6%E5%88%B0%E4%B8%BB%E5%B9%B2/</url>
      <content type="html"><![CDATA[<h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><p>有时会在分支做一些实验性或者重构性的工作。<br>百度了，写的乱七八糟，svn右键我就没找到reintegrate这个功能选项。<br>百度第一页没搞定就直接谷歌了，通常前三条，基本上第一条就搞定。</p><h3 id="参考来源"><a href="#参考来源" class="headerlink" title="参考来源"></a>参考来源</h3><p><a href="https://stackoverflow.com/questions/7563693/merge-a-branch-into-trunk" target="_blank" rel="noopener">Merge a Branch into Trunk</a></p><h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><p>svn merge –reintegrate ^/project/branches/branch_1</p><p>一行搞定，冲突放到小乌龟或者idea中处理，处理完成运行一遍项目没问题提交到主干。</p><p>关于那个^(caret)，因为是特殊符号，应该用caret查。</p><p><a href="http://svnbook.red-bean.com/en/1.6/svn.basic.in-action.html" target="_blank" rel="noopener">http://svnbook.red-bean.com/en/1.6/svn.basic.in-action.html</a></p><p>代表svn仓库的根目录</p>]]></content>
      
      <categories>
          
          <category> 版本控制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> svn </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>apply用法</title>
      <link href="/2018/05/15/apply%E7%94%A8%E6%B3%95/"/>
      <url>/2018/05/15/apply%E7%94%A8%E6%B3%95/</url>
      <content type="html"><![CDATA[<h3 id="1-改变this指向"><a href="#1-改变this指向" class="headerlink" title="1.改变this指向"></a>1.改变this指向</h3><pre><code>    var obj1={        name:&#39;seven&#39;    };    var obj2={        name:&#39;anne&#39;    };global.name=&#39;global&#39;;var getName=function () {    console.log(this.name);};getName();//globalgetName.call(obj1);//sevengetName.call(obj2);//anne</code></pre><h3 id="2-function-prototype-bind"><a href="#2-function-prototype-bind" class="headerlink" title="2.function.prototype.bind"></a>2.function.prototype.bind</h3><pre><code>Function.prototype.bind=function (context) {//context表示obj    var self=this;//保存this引用，否则就变成去全局了。    return function () {        console.log(this);        return self.apply(context,arguments);//self指向=function () {console.log(this.name);}    }};var obj={name:&#39;seven&#39;};var func=function () {    console.log(this.name);    console.log(arguments);}.bind(obj);func(11,22);Function.prototype.bind=function () {    var self=this,//保存原函数        context=[].shift.call(arguments),//获取第一个参数        args=[].slice.call(arguments);//剩余参数转换成数组    return function () {        //组合两次的参数作为新参数        return self.apply(context,[].concat.call(args,[].slice.call(arguments)));    }};var obj={    name:&#39;svene&#39;};var func=function (a,b,c,d) {    console.log(this.name);    console.log([a,b,c,d]);}.bind(obj,1,2);func(3,4);</code></pre><h3 id="3-借用其他对象的方法"><a href="#3-借用其他对象的方法" class="headerlink" title="3 借用其他对象的方法"></a>3 借用其他对象的方法</h3><pre><code>var A=function (name) {    this.name=name;};var B=function () {    A.apply(this,arguments);};B.prototype.getName=function () {    return this.name;};var b=new B(&#39;seven&#39;);console.log(b.getName());(function () {        Array.prototype.push.call(arguments,3);        console.log(arguments);    })(1,2);var a={};Array.prototype.push.call(a,&#39;first&#39;);console.log(a.length);console.log(a[0]);</code></pre>]]></content>
      
      <categories>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> apply </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>js中的this</title>
      <link href="/2018/05/14/js%E4%B8%AD%E7%9A%84this/"/>
      <url>/2018/05/14/js%E4%B8%AD%E7%9A%84this/</url>
      <content type="html"><![CDATA[<pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;div1&quot;&gt;    好想家&lt;/div&gt;&lt;div id=&quot;div2&quot;&gt;    你走吧&lt;/div&gt;&lt;/body&gt;&lt;script&gt;    window.id=&quot;windo    w_id&quot;;    document.getElementById(&quot;div1&quot;).onclick=function () {        this.id=&quot;div11&quot;;        alert(this.id);        var callback=function () {            alert(this.id);        };        //只要赋值给普通函数，this就指向global        callback();    };    document.getElementById(&quot;div2&quot;).onclick=function () {        var that=this;        var callback=function () {            alert(that.id);        };        //只要赋值给普通函数，this就指向global        callback();    };    document.getElementById= (function (func) {        return function () {            return func.apply(document,arguments);        }    })(document.getElementById);    var getId=document.getElementById;    alert(getId(&quot;div1&quot;).id);&lt;/script&gt;&lt;/html&gt;</code></pre><h3 id="1-作为对象的方法调用"><a href="#1-作为对象的方法调用" class="headerlink" title="1.作为对象的方法调用"></a>1.作为对象的方法调用</h3><pre><code>var obj={    a:1,    getA:function () {        console.log(this==obj);        console.log(this.a);    }};//true//1obj.getA();*///——————————————————————————————————//1.5 测试作用于// global.name=&quot;globalName&quot;;// name=&quot;name&quot;;// var name=&quot;varName&quot;;// console.log(name);//——————————————————————————————————</code></pre><h3 id="2-作为普通函数调用"><a href="#2-作为普通函数调用" class="headerlink" title="2 作为普通函数调用"></a>2 作为普通函数调用</h3><pre><code>// //1和2一样，3不一样// global.name=&#39;globalName&#39;;// //不适用// name=&#39;globalName1&#39;;  // var name=&#39;partialName&#39;;// var getName=function () {//     return this.name;// };// //globalName// console.log(getName());//// var myObject={//     name:&#39;seven&#39;,//     getName:function () {//         return this.name;//     }// };// var getName=myObject.getName;// console.log(getName());//——————————————————————————————————/*</code></pre><h3 id="3-在构造器中调用"><a href="#3-在构造器中调用" class="headerlink" title="3.在构造器中调用"></a>3.在构造器中调用</h3><pre><code>var myClass=function () {    this.name=&#39;seven&#39;;};var obj=new myClass();console.log(obj.name);*///——————————————————————————————————/*//4 function.prototype.call或者apply调用var obj1={    name:&#39;zhangweixiao&#39;,    getName:function () {        return this.name;    }};var obj2={    name:&#39;anne&#39;};console.log(obj1.getName());console.log(obj1.getName.call(obj2));*///——————————————————————————————————</code></pre>]]></content>
      
      <categories>
          
          <category> Javascript </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>编程语言和工具的吉祥物们</title>
      <link href="/2018/05/12/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%92%8C%E5%B7%A5%E5%85%B7%E7%9A%84%E5%90%89%E7%A5%A5%E7%89%A9%E4%BB%AC/"/>
      <url>/2018/05/12/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%92%8C%E5%B7%A5%E5%85%B7%E7%9A%84%E5%90%89%E7%A5%A5%E7%89%A9%E4%BB%AC/</url>
      <content type="html"><![CDATA[<p>觉得go的吉祥物很可爱,所以搜集了一下常用的编程语言和软件工具的吉祥物和logo,有些比较大众的就不放上来了。</p><p>如果还有其他有趣的吉祥物或者logo,可以留言。</p><p>不定时更新。</p><h2 id="编程语言"><a href="#编程语言" class="headerlink" title="编程语言"></a>编程语言</h2><h3 id="php"><a href="#php" class="headerlink" title="php"></a>php</h3><img src="/2018/05/12/编程语言和工具的吉祥物们/php.jpg" title="php"><h3 id="go"><a href="#go" class="headerlink" title="go"></a>go</h3><img src="/2018/05/12/编程语言和工具的吉祥物们/go.jpg" title="go"><h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><img src="/2018/05/12/编程语言和工具的吉祥物们/python.jpg" title="python"><h3 id="lisp"><a href="#lisp" class="headerlink" title="lisp"></a>lisp</h3><img src="/2018/05/12/编程语言和工具的吉祥物们/lisp.jpg" title="lisp"><h3 id="perl"><a href="#perl" class="headerlink" title="perl"></a>perl</h3><img src="/2018/05/12/编程语言和工具的吉祥物们/perl.jpg" title="perl"><h3 id="ada"><a href="#ada" class="headerlink" title="ada"></a>ada</h3><img src="/2018/05/12/编程语言和工具的吉祥物们/ada.jpg" title="ada"><h2 id="常用软件"><a href="#常用软件" class="headerlink" title="常用软件"></a>常用软件</h2><h3 id="tomcat"><a href="#tomcat" class="headerlink" title="tomcat"></a>tomcat</h3><img src="/2018/05/12/编程语言和工具的吉祥物们/tomcat.jpg" title="tomat"><h3 id="github"><a href="#github" class="headerlink" title="github"></a>github</h3><img src="/2018/05/12/编程语言和工具的吉祥物们/github.jpg" title="github"><h3 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h3><img src="/2018/05/12/编程语言和工具的吉祥物们/docker.jpg" title="docker"><h3 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h3><img src="/2018/05/12/编程语言和工具的吉祥物们/mysql.jpg" title="mysql"><h3 id="postgresql"><a href="#postgresql" class="headerlink" title="postgresql"></a>postgresql</h3><img src="/2018/05/12/编程语言和工具的吉祥物们/postgresql.jpg" title="postgresql"><h3 id="llvm"><a href="#llvm" class="headerlink" title="llvm"></a>llvm</h3><img src="/2018/05/12/编程语言和工具的吉祥物们/llvm.jpg" title="llvm"><h3 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h3><img src="/2018/05/12/编程语言和工具的吉祥物们/RabbitMQ.jpg" title="RabbitMQ"><h3 id="MariaDB"><a href="#MariaDB" class="headerlink" title="MariaDB"></a>MariaDB</h3><img src="/2018/05/12/编程语言和工具的吉祥物们/MariaDB.jpg" title="MariaDB"><h3 id="suse"><a href="#suse" class="headerlink" title="suse"></a>suse</h3><img src="/2018/05/12/编程语言和工具的吉祥物们/suse.jpg" title="suse">]]></content>
      
      
        <tags>
            
            <tag> 有趣 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>设计一个有getMain功能的栈</title>
      <link href="/2018/05/11/%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E6%9C%89getMain%E5%8A%9F%E8%83%BD%E7%9A%84%E6%A0%88/"/>
      <url>/2018/05/11/%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E6%9C%89getMain%E5%8A%9F%E8%83%BD%E7%9A%84%E6%A0%88/</url>
      <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>实现一个栈,有压入、弹出功能,还要有返回当前最小值的功能。</p><h3 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h3><p>1.pop、push、getMain时间复杂度均为O（1）</p><p>2.可以使用现成的栈结构</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p><a href="https://github.com/zwxbest/algorithm/tree/master/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97-%E7%AE%97%E6%B3%95/%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E6%9C%89getMin%E5%8A%9F%E8%83%BD%E7%9A%84%E6%A0%88/src/GetMinStack" title="设计一个有getMain功能的栈" target="_blank" rel="noopener">设计一个有getMain功能的栈</a></p>]]></content>
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>vim常用操作大全</title>
      <link href="/2018/05/11/vim%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E5%A4%A7%E5%85%A8/"/>
      <url>/2018/05/11/vim%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E5%A4%A7%E5%85%A8/</url>
      <content type="html"><![CDATA[<h3 id="复制粘贴"><a href="#复制粘贴" class="headerlink" title="复制粘贴"></a>复制粘贴</h3><pre><code>&quot;+d --剪切&quot;+p --粘贴&quot;+y --复制</code></pre><p>“（引号）用来选择寄存器,+代表系统剪贴板</p><pre><code>yh --复制左边的一个字符yj --复制下一行yk --复制上一行yl --复制当前字符</code></pre><h3 id="跳转"><a href="#跳转" class="headerlink" title="跳转"></a>跳转</h3><pre><code>w --向右跳转一个单词b --向左跳转一个单词</code></pre><h3 id="撤销和反撤销"><a href="#撤销和反撤销" class="headerlink" title="撤销和反撤销"></a>撤销和反撤销</h3><pre><code>u 撤销ctrl+r 反撤销</code></pre><h3 id="增删改"><a href="#增删改" class="headerlink" title="增删改"></a>增删改</h3><pre><code>o 下一行r 更改一个字符</code></pre>]]></content>
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vim </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>通过文本为pdf添加书签</title>
      <link href="/2018/05/09/%E9%80%9A%E8%BF%87%E6%96%87%E6%9C%AC%E4%B8%BApdf%E6%B7%BB%E5%8A%A0%E4%B9%A6%E7%AD%BE/"/>
      <url>/2018/05/09/%E9%80%9A%E8%BF%87%E6%96%87%E6%9C%AC%E4%B8%BApdf%E6%B7%BB%E5%8A%A0%E4%B9%A6%E7%AD%BE/</url>
      <content type="html"><![CDATA[<h1 id="pmark"><a href="#pmark" class="headerlink" title="pmark"></a>pmark</h1><p>pdf书签生成工具和编辑工具。</p><p><a href="https://github.com/zwxbest/pmark" target="_blank" rel="noopener">github地址</a></p><p>个人收集了不少pdf，有的没有书签，不能跳页不方便。<br>有的书签每次跳页会把缩放页面。</p><p>针对这两个最常用的需求，实现一个简单的功能。</p><p>不想学javaFx，不喜欢 .net, (从wpf一路被微软坑的过来人)。考虑之后用springboot做一个内嵌tomcat的web页面。</p><p>复制当当或者亚马逊或者京东或者豆瓣的书签内容到txt中，即可为pdf生成书签。书签有层级，可跳转页码。<br>编辑全部书签可让书签跳转时不会缩放，即按照档当前的缩放比例。</p><p>此操作会删除已存在的书签，并新增书签，但不会对pdf中的文字和图形注释以及其他的产生影响。</p><p>提交后会在pdf同级目录生成一个XX-带书签.pdf的文件，为处理完成后的pdf文件。</p><h2 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h2><p>如图</p><img src="/2018/05/09/通过文本为pdf添加书签/web.jpg" title="pmarker"><p>处理之后</p><img src="/2018/05/09/通过文本为pdf添加书签/demo.jpg" title="demo"><ol><li>页码偏移：pdf文件从封面就开始计算页码，而目录页码是书上标的页码。偏移即差值</li><li>路径：pdf的绝对路径</li><li>书签文本：从上面说的网站粘贴过来</li><li>书签格式：{no}-数字序号，{content}- 内容,{page}-页码,不需要指定空格，每行代表一个层级，制作折叠书签。<br>注意{no}和{page}只包含数字，{content}表示除了no外要在书签中显示的内容<br>比如：传播过度的社会　/9 。这里没有序号，有页码，但是不希望书签中包含/，即定义格式{content}/{page}</li></ol><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><pre><code>java -jar pmark-0.0.1-SNAPSHOT.jar</code></pre><h2 id="待改进"><a href="#待改进" class="headerlink" title="待改进"></a>待改进</h2><ul><li style="list-style: none"><input type="checkbox"> 页面，要美，可是，好累。</li><li style="list-style: none"><input type="checkbox"> 整理出大量pdf书签格式表达式，先是自动识别格式位符定义格式。</li><li style="list-style: none"><input type="checkbox"> 爬虫抓取以上网站并让用户选择正确或者详细的那个，使用语言初步定为node.js。</li></ul>]]></content>
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iText </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
